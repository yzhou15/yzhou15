{"meta":{"title":"yzhou's blog","subtitle":null,"description":"You are here, welcome!","author":"yzhou","url":"https://yzhou15.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2021-08-08T08:26:29.797Z","updated":"2021-08-08T08:26:29.797Z","comments":true,"path":"categories/index.html","permalink":"https://yzhou15.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-08T08:26:29.798Z","updated":"2021-08-08T08:26:29.798Z","comments":true,"path":"tags/index.html","permalink":"https://yzhou15.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-08-08T08:26:29.796Z","updated":"2021-08-08T08:26:29.796Z","comments":true,"path":"about/index.html","permalink":"https://yzhou15.gitee.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Git+Jenkins+Harbor+Docker实现CICD一些记录","slug":"Git+Jenkins+Harbor+Docker实现CICD一些记录","date":"2021-08-07T17:18:00.000Z","updated":"2021-08-22T15:12:06.323Z","comments":true,"path":"2021/08/08/Git+Jenkins+Harbor+Docker实现CICD一些记录/","link":"","permalink":"https://yzhou15.gitee.io/2021/08/08/Git+Jenkins+Harbor+Docker%E5%AE%9E%E7%8E%B0CICD%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/","excerpt":"","text":"update: ‘2021/8/22’ 一. 环境准备:ctntos8.4 cpu:4 内存: 2048M 硬盘: 256G 192.168.1.102 Harbor 192.168.1.103 Jenkins 192.168.1.104 Docker 二. 一些问题:123456789101112131415161718192021222324# sshdsystemctl start sshdps -e | grep sshd# 修改hostnamevi /etc/hostnamehostnamectl set-hostname appjzw# ping 不通外网vim /etc/resolv.confnameserver 8.8.8.8nameserver 202.106.0.20nmcli c reload enp0s3# centos8 yum 换源# 1.备份旧的源mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup# 2.下载对应版本的阿里源（wget -O **下载并以指定的文件名保存**）wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repoyum makecache # 3.删除yum旧的缓存，生成新的换源后的缓存cat /etc/yum.repos.d/CentOS-Base.repo # 4.检查是否换源成功 三. 部署Harbor镜像仓库1.下载安装1234567891011121314151617181920212223wget [https://github.com/goharbor/harbor/releases/download/v2.3.1/harbor-offline-installer-v2.3.1.tgz](https://github.com/goharbor/harbor/releases/download/v2.3.1/harbor-offline-installer-v2.3.1.tgz)yum install lrzsz# 从服务器拉东西scp root@[公网地址]:/root/harbor-fooline-installer-v2.3.1.tgz /usr/yzhou/Desktopsystemctl start dockerdocker -vdocker —versiondocker infodocker imagesdocker pscp harbor.yml.tmpl harbor.ymlvim harbor.yml./install.shcd harbordocker-compose restartdocker-compose down -vdocker-compose up -d 2. 测试Harbor123# name# http登录 # port 3. Dockerfile文件1234567891011121314151617181920212223# cd /root/jenkins/docker-file/maven-docker-test_war# vim Dockerfile# Version 1.0# Base images.FROM tomcat:8.0.36-alpine# Author.MAINTAINER yzhou&lt;403708416@qq.com&gt;# Add war.ADD maven-docker.war /usr/local/tomcat/webapps/# Define working directory.ENV PATH /usr/local/tomcat/bin:$PATH# Define environment variavles.ENV PATH /usr/loacl/tomcat/bin:$PATH# Define default command.CMD &#123;&quot;catalina.sh&quot;, &quot;run&quot;&#125;# Expose ports.EXPOSE 8080 4. Harbor权限相关 四. 业务服务器1.安装软件1234567yum install -y yum-utils device-mapper-persistent-data lvm2docker -vyum-config-manager --add-repo [https://download.docker.com/linux/centos/docker-ce.repo](https://download.docker.com/linux/centos/docker-ce.repo)yum install docker-ce docker-ce-cli [containerd.io](http://containerd.io/) --nobestyum install container-selinuxsystemctl start dockeryum install jq -y 2.预先配置12345678# 在业务服务器上配置:(否则没有权限报错)[SSH] executing...sudo: sorry, you must have a tty to run sudodocker: invalid reference format.# visudo## Defaults requirettyDefaults:root !requiretty 五. jenkins1. 问题:123456789# 登录harbor遇到问题docker login -u admin -p Harbor12345 reg.mydomain.comError response from daemon: Get https://reg.mydomain.com/v2/: unauthorized: authentication required# vim /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;], &quot;insecure-registries&quot;:[&quot;192.168.1.102:8080&quot;] &#125;# sudo systemctl restart docker 2. 安装软件123456sudo wget -O /etc/yum.repos.d/jenkins.repo \\ https://pkg.jenkins.io/redhat-stable/jenkins.reposudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.keysudo yum upgradesudo yum install jenkins java-1.8.0-openjdk-develsudo systemctl daemon-reload 12345678[root@jenkins ~]# wget -o /etc/yum.repos.d/jenkins.repo [https://pkg.jenkins.io/redhat-stable/jenkins.repo](https://pkg.jenkins.io/redhat-stable/jenkins.repo)[root@jenkins ~]# rpm --import [https://pkg.jenkins.io/redhat-stable/jenkins.io.key](https://pkg.jenkins.io/redhat-stable/jenkins.io.key)yum install -y jenkins git mavensystemctl start jenkins[root@jenkins yum.repos.d]# lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 277770 jenkins 26u IPv6 754801 0t0 TCP *:webcache (LISTEN)ps -ef | grep jenkins 在CentOS 8 上安装Jenkins需要使用root账号或具有sudo权限的账号。 第一步、因为Jenkins是使用Java编写的，所以需要安装Java环境，Jenkins需要Java8或更高版本 这里使用OpenJDK，首先通过一下命令安装OpenJDK. 1sudo dnf install java-1.8.0-openjdk-devel 如果系统上安装了多个Java版本，请确保Java 8是默认Java版本。 你可能对关于更详细如何在CentOS上安装Java教程也感兴趣。 第二步、启用Jenkins存储库。运行以下命令下载并导入GPG密钥： 12sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.reposudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key 第三步、通过键入以下命令安装最新的Jenkins稳定版本： 1sudo dnf install jenkins 安装过程完成后，启动Jenkins服务并启用它以在系统引导时启动： 12sudo systemctl start jenkinssudo systemctl enable jenkins 检查Jenkins是否正在运行，请输入： 1systemctl status jenkins 输出应类似如下所示： 123Loaded: loaded (/etc/rc.d/init.d/jenkins; generated)Active: active (running) since Thu 2019-11-05 21:31:36 UTC; 3s ago... 2.1. 配置防火墙如果要在受防火墙保护的远程CentOS服务器上安装Jenkins，则需要开放8080端口。 使用以下命令打开必要的端口： 12sudo firewall-cmd --permanent --zone=public --add-port=8080/tcpsudo firewall-cmd --reload 2.2. 设置Jenkins安装完成并在防火墙上放开8080端口口，就可以开始Jenkins设置过程。首先，请打开浏览器并键入域或服务器的IP地址，然后键入port 8080： 1http://your_ip_or_domain:8080 3.预先配置12345678910111213141516由于在Jenkins机器上docker是使用root用户运行的，而Jenkins是使用普通用户jenkins运行的，所以要先配置下jenkins用户可以使用docker命令。[root@jenkins ~]# visudojenkins ALL=(root) NOPASSWD: /usr/bin/docker另外在Jenkins机器上配置：# Disable &quot;ssh hostname sudo &lt;cmd&gt;&quot;, because it will show the password in clear.# You have to run &quot;ssh -t hostname sudo &lt;cmd&gt;&quot;.##Defaults requirettyDefaults:jenkins !requiretty如果不配置这个，在执行下面脚本时，会报错误：+ cp -f /home/jenkins/.jenkins/workspace/godseyeBranchForNov/godseye-container/target/godseye-container-wisedu.war /home/jenkins/docker-file/godseye_war/godseye.war+ sudo docker login -u jkzhao -p Wisedu123 -e 01115004@wisedu.com 172.16.206.32sudo: sorry, you must have a tty to run sudo 安装git遇到问题 123456# 安装gcc环境# yum源没有对应版本包匹配wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.reposed -i &#x27;s/$releasever/8/g&#x27; /etc/yum.repos.d/CentOS-Base.repoyum repolist jenkins配置: 安装插件: maven intergation 和 ssh agent 配置远程机器 添加凭据 六. jenkins构建job1. 构建maven风格的job1. 代码地址:​ https://github.com/yzhou15/maven-docker Goals and options填写：clean package -Dmaven.test.skip=true 2. Post steps1234567891011121314151617181920212223242526272829# jenkins机器: 编译完成后,build生成一个新版本的镜像,push到远程docker仓库# VariablesJENKINS_WAR_HOME=&#x27;/var/lib/jenkins/workspace/maven-docker/target&#x27;DOCKERFILE_HOME=&#x27;/var/lib/jenkins/docker-file/maven-docker-test_war&#x27;HARBOR_IP=&#x27;192.168.1.102&#x27;REPOSTITORIES=&#x27;jenkins/maven-docker&#x27;HARBOR_USER=&#x27;yzhou&#x27;HARBOR_USER_PASSWS=&#x27;Harbor12345&#x27;HARBOR_USER_EMAIL=&#x27;403708416@qq.com&#x27;# Copy the nevest war to docker-file directory.\\cp -f $&#123;JENKINS_WAR_HOME&#125;/easy-springmvc-maven.war$&#123;DOCKERFILE_HOME&#125;/maven-docker.war# Delete image early versionsudo docker login -u $&#123;HARBOR_USER&#125; -p $&#123;HARBOR_USER_PASSWD&#125; $&#123;HARBOR_IP&#125;:8080IMAGE_ID=&#x27;sudo docker images | grep $&#123;REPOSITORIES&#125; | awk &#x27;&#123;print$3&#125;&#x27;&#x27;if [ -n &quot;&#123;IMAGE_ID&#125;&quot;];then sudo docker rmi $&#123;IMAGE_ID&#125;fi# Build image.cd $&#123;DOCKERFILE_HOME&#125;TAG=`date +%Y%m%d-%H%M%S`sudo docker build -t $&#123;HARBOR_IP&#125;:8080/$&#123;REPOSITORIES&#125;:$&#123;TAG&#125; . &amp;&gt;/dev/null# Push to the harbor registry.sudo docker push $&#123;HARBOR_IP&#125;:8080/$&#123;REPOSITORIES&#125;:$&#123;TAG&#125; &amp;&gt;/dev/null 3. 拉取镜像,发布12345678910111213141516171819202122232425262728293031323334353637# 拉取镜像.发布.HARBOR_IP=&#x27;192.168.1.102&#x27;REPOSITORIES=&#x27;jenkins/maven-docker&#x27;HARBOR_USERS=&#x27;yzhou&#x27;HARBOR_USER_PASSWD=&#x27;Harbor2345&#x27;# 登录harbordocker login -u $&#123;HARBOR_USER&#125; -p $&#123;HARBOR_USER_PASSWD&#125; $&#123;HARBOR_IP&#125;:8080Stop container, and delete the container.CONTAINER_ID=`docker ps | grep &quot;maven-docker&quot; | awk &#x27;&#123;print$1&#125;&#x27;`if [ -n &quot;$CONTAINER_ID&quot; ]; then docker stop $CONTAINER_ID docker rm $CONTAINER_IDelse # 如果容器启动失败,就需要docker ps -a才能找到哪个容器 CONTAINER_ID=`docker ps -a | grep &quot;maven-docker&quot; | awk &#x27;print$1&#x27;` if [ -n &quot;$CONTAINER_ID&quot;]; then # 如果是第一次在这台及其上拉取运行容器,那么docker ps -a也是找不到这个容器的 docker rm $CONTAINER_ID fifi# Deleteeasy-springmvc-maven image early version.IMAGE_ID=`sudo docker images | grep $&#123;REPOSITORIES&#125; | awk &#x27;print $3&#x27;`if [ -n &quot;$&#123;IMAGE_ID&#125;&quot;];then docker rmi $&#123;IMAGE_ID&#125;fi# Pull images.# TAG=`curl -s http://$&#123;HARBOR_IP&#125;/api/repositories/$&#123;REPOSITORIES&#125;/tags | jq &#x27;.[-1]&#x27; | sed &#x27;s/\\&quot;//g&#x27;`TAG=`curl http://192.168.1.102/api/repoditories/jenkins/maven-docker/tags | jq &#x27;.[-1]&#x27; | &#123;name:.name&#125; | awk -F &#x27;&quot;&#x27; &#x27;/name/&#123;print $4&#125;&#x27;`docker pull $&#123;HARBOR_IP&#125;:8080/$&#123;REPOSITORIES&#125;:$&#123;TAG&#125; &amp;&gt;/dev/null&#125;# Run.docker run -d --name maven-docker -p 8080:8080$&#123;HARBOR_ip&#125;:8080/$&#123;REPOSITORIES&#125;:$&#123;TAG&#125; 4. 项目构建![Untitled 2](Git+Jenkins+Harbor+Docker实现CICD一些记录/Untitled 2-162964417842316.png) 5. 遇到问题: 1234567891011121314151617181920212223242526# 查看maven版本sudo dnf install mavenmvn -version# 更新maven版本,Maven 3.3+需要安装JDK 1.7 或者更高版本的 JDK。sudo dnf install java-11-openjdk-develjava -version# 下载 Apache Maven http://maven.apache.org/download.cgiwget https://ftp.jaist.ac.jp/pub/apache/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.tar.gz -P /tmpsudo tar xf /tmp/apache-maven-3.8.1-bin.tar.gz -C /optsudo ln -s /opt/apache-maven-3.8.1 /opt/maven# 设置环境变量# vim /etc/profile.d/maven.shexport JAVA_HOME=/usr/lib/jvm/jre-openjdkexport M2_HOME=/opt/mavenexport MAVEN_HOME=/opt/mavenexport PATH=$&#123;M2_HOME&#125;/bin:$&#123;PATH&#125;sudo chmod +x /etc/profile.d/maven.shsource /etc/profile.d/maven.sh# 验证安装[root@jenkins ~]# mvn -versionApache Maven 3.8.1 (05c21c65bdfed0f71a2f2ada8b84da59348c4c5d)Maven home: /opt/mavenJava version: 1.8.0_302, vendor: Red Hat, Inc., runtime: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.302.b08-0.el8_4.x86_64/jreDefault locale: en_US, platform encoding: UTF-8OS name: &quot;linux&quot;, version: &quot;4.18.0-305.10.2.el8_4.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot; 6. 控制台输出过程 1# 修改git分支为默认 1234# jenkins找不到,新增mavenmvn -v# 配置全路径,清理工作空间$workspace/pom.xml","categories":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/categories/CICD/"}],"tags":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/tags/CICD/"}]},{"title":"Jenkins详解","slug":"第3天-Jenkins详解","date":"2021-08-07T13:05:00.000Z","updated":"2021-08-22T13:10:29.567Z","comments":true,"path":"2021/08/07/第3天-Jenkins详解/","link":"","permalink":"https://yzhou15.gitee.io/2021/08/07/%E7%AC%AC3%E5%A4%A9-Jenkins%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"第3天-Jenkins详解一、Jenkins介绍简单历史 ​ Jenkins的前身是Hudson，采用JAVA编写的持续集成开源工具。Hudson由Sun公司在2004年启动，第一个版本于2005年在java.net发布。2007年开始Hudson逐渐取代CruiseControl和其他的开源构建工具的江湖地位。在2008年的JavaOne大会上在开发者解决方案中获得杜克选择大奖（Duke’s Choice Award）。 在2010年11月期间，因为Oracle对Sun的收购带来了Hudson的所有权问题。主要的项目贡献者和Oracle之间，尽管达成了很多协议，但有个关键问题就是商标名称“Hudson”。甲骨文在2010年12月声明拥有该名称并申请商标的权利。 因此，2011年1月11日，有人要求投票将项目名称从“Hudson”改为“Jenkins”。2011年1月29日，该建议得到社区投票的批准，创建了Jenkins项目。 2011年2月1日，甲骨文表示，他们打算继续开发Hudson，并认为Jenkins只是一个分支，而不是重命名。因此，Jenkins和Hudson继续作为两个独立的项目，每个都认为对方是自己的分支。到2013年12月，GitHub上的Jenkins拥有567个项目成员和约1,100个公共仓库，与此相对的Hudson有32个项目成员和17个公共仓库。到现在两者的差异更多，应该说Jenkins已经全面超越了Hudson。此外，大家可能是出于讨厌Oracle的情绪，作为Java开发者天然地应该支持和使用Jenkins。 后面Hudson被Oracle捐给了Eclipse基金会，所以右边这老头有个Eclipse的光环加持。 为什么Jenkins更受大家欢迎。 由开发者主导、面向开发者 首先，曾经是Hudson开发人员中的99%都转向了Jenkins的开发，其中包括最初的创建者川口清子（Kohsuke Kawaguchi）。他独自写了大部分代码，并且他的经验是Hudson各种高级特性的关键来源。Jenkins的开发社区更活跃。所以对很多人而言，从血统上看Hudson是后娘养的，Jenkins才是亲生的！ 治理和社区 Jenkins开发社区的管理是很开放的。 有一个独立的董事会，其中包括来自Yahoo!, CloudBees，Cloudera和Apture等多家公司的长期以来的Hudson开发人员。每次会议后，他们定期举行治理会议并发表意见，征询公众意见。他们还将所有代码都捐赠给公共利益软件组织（SPI），以确保社区持续开放。 稳定性 分手后，针对Jenkins的贡献不断持续增加，Jenkins制定了新的长期支持发布线。社区定大约每三个月发布一次稳定版本的补丁。 插件的平台 Jenkins支持超过1000个插件。凭借多样而强大的插件Jenkins成了整个开发生命周期中的一个中心点。 到了2017年，两者的发展差异更大了。Jenkins应该说是CI工具中公认的老大，而Hudson不仅不能与Jenkins比，跟其他CI工具比也没什么优势，完全沉沦了。 slant网站对一系列CI工具做了一次对比，其中Jenkins和Hudson的情况如下。 1、基本面问题 工具 Jenkins Hudson 最好的CI工具 1 22 最好的JAVA CI工具 1 7 最好的自托管CI工具 3 4 2、其他支持 工具 Jenkins Hudson 对Window支持最好 1 无排名 最好的开源CI工具 1 无排名 对BitBucket的支持 2 无排名 对移动开发者支持最好的CI 4 无排名 3、更多特征 Jenkins Hudson 免费且开源 与Jenkins共享了很多代码，安装还是挺简单的 关键的环境变量可以安全存储 支持多个SCM，包括SVN, Mercurial, Git。集成了GitHub和Bitbucket 高度可配置 资源和教程很多 安装运行简单 分布式的构建也能高效运行 可跨平台部署 很多高质量的插件 得奖无数 庞大的社区 1、Jenkins 功能 持续的软件版本发布/测试项目。 监控外部调用执行的工作。 3、Jenkins 概念Jenkins是一个功能强大的应用程序，允许持续集成和持续交付项目，无论用的是什么平台。这是一个免费的开源项目，可以处理任何类型的构建或持续集成。集成Jenkins可以用于一些测试和部署技术。Jenkins是一种软件允许持续集成。 4、Jenkins 目的 持续、自动地构建/测试软件项目。 监控软件开放流程，快速问题定位及处理，提提高开发效率。 5、Jenkins 特性 开源的java语言开发持续集成工具，支持CI，CD。 易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可方便web界面配置管理。 消息通知及测试报告：集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生成JUnit/TestNG测试报告。 分布式构建：支持Jenkins能够让多台计算机一起构建/测试。 文件识别:Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。 丰富的插件支持:支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven，docker等。 6、产品发布流程产品设计成型 -&gt; 开发人员开发代码 -&gt; 测试人员测试功能 -&gt; 运维人员发布上线 持续集成（Continuous integration，简称CI） 持续交付（Continuous delivery） 持续部署（continuous deployment） 二、Jenkins CI/CD 流程 说明：这张图稍微更形象一点，上线之前先把代码git到版本仓库，然后通过Jenkins将Java项目通过maven去构建，这是在非容器之前，典型的自动化的一个版本上线流程。那它有哪些问题呢？ 如：它的测试环境，预生产环境，测试环境。会存在一定的兼容性问题 （环境之间会有一定的差异） 说明：它这里有一个docker harbor 的镜像仓库，通常会把你的环境打包为一个镜像，通过镜像的方式来部署。 三、部署Jenkins IP 主机名 172.16.1.2 jenkins 172.16.1.3 web 172.16.1.4 git/gitlab 1、部署GITIP：172.16.1.4，git 服务器进行如下操作 1、安装 git1[root@qfedu.com ~]# yum install -y git 创建git用户并设置密码为123456（为开发人员拉代码时设置的用户） 12[root@qfedu.com ~]# useradd git[root@qfedu.com ~]# passwd git 2、创建仓库1234567[root@qfedu.com ~]# su - git #切换到git用户下[git@qfedu.com ~]$ mkdir -p repos/app.git #在git用户家目录下创建一个repos目录，repos目录下创建各个项目的目录[git@qfedu.com ~]$ cd repos/app.git[git@qfedu.com ~]$ git --bare init #初始化仓库，如果不初始化，这仅仅就只是一个目录#查看初始化后仓库信息[git@qfedu.com app.git]$ ls -a. .. branches config description HEAD hooks info objects refs 配置完仓库后，我们需要找一台机器测试是否能够成功从仓库中拉取代码，或者上传代码到该仓库。 IP：172.16.1.5，web服务器进行测试 3、安装 git 客户端拉取代码 123456[root@qfedu.com ~]# yum install -y git #首先还是安装git[root@qfedu.com ~]# mkdir -p test[root@qfedu.com ~]# cd test[root@qfedu.com test]# git clone git@172.16.1.4:/home/git/repos/app.git ##测试clone远端git仓库[root@qfedu.com test]# ls app 4、push 测试12345[root@qfedu.com app]# touch index.html[root@qfedu.com app]# git add .[root@qfedu.com app]# git commit -m &quot;test&quot; #第一次的话会有报错警告，说让配置邮箱和姓名。配置一下即可，或者直接执行给出的命令执行即可。[root@qfedu.com app]# git push origin master #提交到主分支（默认分支） 测试成功！ 5、补充：配置免秘钥1、172.16.1.5 服务器生成公钥123[root@qfedu.com ~]# ssh-keygen[root@qfedu.com ~]# cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmmIOOJCRjlcNyM9zQ4yNeSFgJhBYZUTHMJ3D6sy6IgyOQi/LW9IzBF8mVjmc9wBzQBzg9obCJ/2YiGtvgl00v8A6Clamx6XdQpHPbnVcgHznhEhaa5X0TONcyJ0/z9e8wdppafAsrgRYdpRcXfrPC7xlzDIRpjgWG9YEMzrqCDcWAoWLMYvr2GHwhFyJa5OpMNGH5NjaWJbzYlgdP5cwh/QX04xVZ0QKghQsol9HmbRbqJ8Hl8WrgDoy2BPE41XKEwR4drgUGCFXZDH4s9ZodC4zI76TWIyCeKKM0XbTNHRU6Cb6xWb/iFhpsa7m14A5usUH6RfIjzJBr3IcyUkk3 root@qfedu.com 2、172.16.1.4 git 服务器进行配置12345678[git@qfedu.com ~]$ mkdir -p .ssh[git@qfedu.com ~]$ chmod 700 .ssh/ # 给予目录700权限[git@qfedu.com ~]$ vi .ssh/authorized_keys # 写入172.16.1.5服务器的公钥ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDmmIOOJCRjlcNyM9zQ4yNeSFgJhBYZUTHMJ3D6sy6IgyOQi/LW9IzBF8mVjmc9wBzQBzg9obCJ/2YiGtvgl00v8A6Clamx6XdQpHPbnVcgHznhEhaa5X0TONcyJ0/z9e8wdppafAsrgRYdpRcXfrPC7xlzDIRpjgWG9YEMzrqCDcWAoWLMYvr2GHwhFyJa5OpMNGH5NjaWJbzYlgdP5cwh/QX04xVZ0QKghQsol9HmbRbqJ8Hl8WrgDoy2BPE41XKEwR4drgUGCFXZDH4s9ZodC4zI76TWIyCeKKM0XbTNHRU6Cb6xWb/iFhpsa7m14A5usUH6RfIjzJBr3IcyUkk3 root@qfedu.com[git@qfedu.com ~]$ chmod 600 .ssh/authorized_keys # 给予文件600权限 2、Jenkins 安装配置1、jenkins 安装官网： https://jenkins.io 插件：http://updates.jenkins-ci.org/download/plugins/ 1、安装 java 环境（jenkins 依赖 java 环境）123456789101112131415[root@qfedu.com tools]# ls # 查看解压包jdk-8u45-linux-x64.tar.gz[root@qfedu.com tools]# tar zxf jdk-8u45-linux-x64.tar.gz # 解压[root@qfedu.com tools]# mv jdk1.8.0_45/ /usr/local/jdk1.8 # 移动至指定目录[root@qfedu.com tools]# vim /etc/profile # 配置环境变量JAVA_HOME=/usr/local/javaexport MAVEN_HOME=/usr/local/mavenexport JRE_HOME=/usr/local/java/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$MAVEN_HOME/bin:$PATH[root@qfedu.com tools]# source /etc/profile # 配置生效[root@qfedu.com tools]# java -version # 查看java版本java version &quot;1.8.0_45&quot;Java(TM) SE Runtime Environment (build 1.8.0_45-b14)Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode) 2、yum 安装 jenkins1234567891011121314151617[root@qfedu.com ~]# wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo# 导入jenkins源[root@qfedu.com ~]# rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key# 导入jenkins官方证书[root@qfedu.com ~]# yum install -y jenkins# 安装jenkins（安装的是最新的LTS版本）[root@qfedu.com ~]# rpm -ql jenkins # 查看yum都安装了哪些东西/etc/init.d/jenkins/etc/logrotate.d/jenkins/etc/sysconfig/jenkins/usr/lib/jenkins/usr/lib/jenkins/jenkins.war/usr/sbin/rcjenkins/var/cache/jenkins/var/lib/jenkins/var/log/jenkins 2、配置文件1、查询 yum 下载 Jenkins 安装的文件12345678910[root@qfedu.com ~]# rpm -ql jenkins/etc/init.d/jenkins # 启动文件/etc/logrotate.d/jenkins # 日志分割配置文件/etc/sysconfig/jenkins # jenkins主配置文件/usr/lib/jenkins # 存放war包目录/usr/lib/jenkins/jenkins.war # war 包 /usr/sbin/rcjenkins # 命令/var/cache/jenkins # war包解压目录 jenkins网页代码目录/var/lib/jenkins # jenkins 工作目录/var/log/jenkins # 日志 2、修改配置文件配置文件说明： 12345678910111213141516[root@qfedu.com ~]# grep &quot;^[a-Z]&quot; /etc/sysconfig/jenkinsJENKINS_HOME=&quot;/var/lib/jenkins&quot; # jenkins工作目录JENKINS_JAVA_CMD=&quot;&quot;JENKINS_USER=&quot;jenkins&quot; # jenkinx启动用户JENKINS_JAVA_OPTIONS=&quot;-Djava.awt.headless=true&quot;JENKINS_PORT=&quot;8080&quot; # 端口JENKINS_LISTEN_ADDRESS=&quot;&quot;JENKINS_HTTPS_PORT=&quot;&quot;JENKINS_HTTPS_KEYSTORE=&quot;&quot;JENKINS_HTTPS_KEYSTORE_PASSWORD=&quot;&quot;JENKINS_HTTPS_LISTEN_ADDRESS=&quot;&quot;JENKINS_DEBUG_LEVEL=&quot;5&quot;JENKINS_ENABLE_ACCESS_LOG=&quot;no&quot;JENKINS_HANDLER_MAX=&quot;100&quot; # 最大连接JENKINS_HANDLER_IDLE=&quot;20&quot;JENKINS_ARGS=&quot;&quot; 3、启动 jenkins 首先需要修改一下启动脚本，文件在/etc/init.d/jenkins 因为jenkins的启动脚本默认java路径为：/usr/bin/java 但是我们新安装的java路径并不是在这个，所以我们需要新添加路径。如图下所示： 新路径地址为：/usr/local/jdk1.8/bin/java 接下来启动： 1[root@qfedu.com ~]# systemctl start jenkins 3、验证安装123456[root@qfedu.com ~]# ps -ef|grep jenkinsjenkins 16037 1 1 16:20 ? 00:00:13 /usr/local/jdk1.8/bin/java -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -DJENKINS_HOME=/var/lib/jenkins -jar /usr/lib/jenkins/jenkins.war --logfile=/var/log/jenkins/jenkins.log --webroot=/var/cache/jenkins/war --daemon --httpPort=8080 --debug=5 --handlerCountMax=100 --handlerCountMaxIdle=20root 16107 1215 0 16:39 pts/1 00:00:00 grep --color=auto jenkins[root@qfedu.com ~]# netstat -lnutp|grep jenkins[root@qfedu.com ~]# netstat -lnutp|grep 8080tcp6 0 0 :::8080 :::* LISTEN 16037/java 3、jenkins配置（web页面）1、管理员密码获取 12[root@qfedu.com ~]# cat /var/lib/jenkins/secrets/initialAdminPassword5d3f57bea6e546139fc48ea28f9d5ae5 2、安装插件 （选择在线安装） 出现离线安装解决方法： 1、修改 /var/lib/jenkins/updates/default.jsonjenkins 在下载插件之前会先检查网络连接，其会读取这个文件中的网址。默认是访问谷歌，肯定监测失败，所以将图下的google改为www.baidu.com即可，更改完重启服务。 2、 修改/var/lib/jenkins/hudson.model.UpdateCenter.xml该文件为jenkins下载插件的源地址，改地址默认jenkins默认为：https://updates.jenkins.io/update-center.json，就是因为https的问题，此处我们将其改为http即可，之后重启jenkins服务即可。 其他国内备用地址（也可以选择使用）： https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json http://mirror.esuni.jp/jenkins/updates/update-center.json 在修复完之后，我们发现离线问题已经解决 选择安装推荐的插件： 3、创建第一个管理员用户 4、url 配置之前版本没有这个选项，这里默认即可: 5、安装完成出现如下页面时，表示安装完成 这里面有很多配置，下面我们只介绍我们要用到的要修改的配置（之后案例会用到的）。我们不需要全部都配置，等需要什么的时候再去研究一下即可。 6、配置 jdk、git、maven系统管理-&gt;全局工具配置 jdk：可以自动安装，但是我们已经安装了，这里写入我们jdk的路径即可 git: maven： 7、jenkins 下载插件失败处理办法jenkins 下载插件失败,提示： 123456789101112java.io.IOException: Downloaded file /app/jenkins_home/plugins/jacoco.jpi.tmp does not match expected SHA-1, expected &#x27;CtK02wHdFOxTutqhUQzmue6uvpg=&#x27;, actual &#x27;YGO05utKyaaFzpGCgCE95GS0WsU=&#x27; at hudson.model.UpdateCenter.verifyChecksums(UpdateCenter.java:1783) at hudson.model.UpdateCenter.access$1100(UpdateCenter.java:147) at hudson.model.UpdateCenter$InstallationJob.replace(UpdateCenter.java:1934) at hudson.model.UpdateCenter$UpdateCenterConfiguration.install(UpdateCenter.java:1178) at hudson.model.UpdateCenter$DownloadJob._run(UpdateCenter.java:1653) at hudson.model.UpdateCenter$InstallationJob._run(UpdateCenter.java:1848) at hudson.model.UpdateCenter$DownloadJob.run(UpdateCenter.java:1624) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at hudson.remoting.AtmostOneThreadExecutor$Worker.run(AtmostOneThreadExecutor.java:110) at java.lang.Thread.run(Thread.java:745) 中国源的问题。需要换个源就可，换源方法： jenkins-&gt;系统管理-&gt;管理插件-&gt;高级选择升级站点 把：http://updates.jenkins-ci.org/update-center.json 换成：http://mirror.esuni.jp/jenkins/updates/update-center.json 镜像地址查询： http://mirrors.jenkins-ci.org/status.html 四、使用Jenkins1、Jenkins 用户权限管理1、 用户管理背景针对开发、运维、测试针对不同角色进行不同权限划分， 基于插件： Role-based Authorization Strategy ，Authorize Project 来实现。 2、 安装用户管理插件安装该插件： 系统管理-&gt;管理插件-可选插件-&gt;搜索该插件选中直接安装即可。 3、 开启该插件功能系统管理-&gt;全局安全设置-授权策略-&gt;选中该插件功能即可-&gt;保存 4、 验证用户管理关闭用户管理功能来进行实践测试 1、策略改回原来的（全局安全配置） 2、开启允许用户注册（全局安全配置） 3、注册一个新用户 4、登录之后，其默认就是管理员用户，可以进行任何操作 5、开启 Role-Based Strategy6、重新登录新创建 test1 用户，显示已经没有任何权限了 5、 权限划分安装 Role-Based Strategy 插件后，系统管理 中多了如图下所示的一个功能，用户权限的划分就是靠他来做的。 1、Manage Roles（管理角色） Manage Roles：管理角色，相当于针对角色赋予不同权限，然后在将该角色分配给用户。角色就相当于一个组。其里面又有Global roles（全局）、Project roles（项目）、Slave roles（），来进行不同划分。 默认如图下所示： 1、Global roles默认是有一个admin用户的，是所有权限都有的，所有权限都是勾选了的。 接下来我们来添加一个角色：user 给其一个读的权限。 2、Project roles roles to add：表示项目角色 Pattern：是用来做正则匹配的（匹配的内容是Job(项目名)），比如说根据正则匹配到的项目项目角色就都有权限； 接下来新建一个 ItemA 项目角色，改项目角色一般给其构建、取消、读取、读取空间权限，一般配置这4个即可 还可以在新建一个 ItemB 项目角色： Slave roles（奴隶角色）：节点相关的权限 roles to add：表示项目角色 Pattern：是用来做正则匹配的（匹配的内容是节点(slavej节点）），比如说根据正则匹配到的项目项目角色就都有权限； 2、Assigin roles（分配角色）1、给予test1用户分配 user 角色这样其就有 manage roles 中刚才创建的user角色的权限了。 此时再去看 test1用户，已有查看的权限了 2、针对指定用户分配项目角色（一般最常用的就是针对不同用户进行项目角色分配）比如将test1用户分配有 ItemA 项目角色，这样其就可以有刚才我们创建的 ItemA 项目角色正则匹配到的项目的权限了。 test2 也为其分配一个 ItemB 项目角色 此时可以在 test1 用户这里看到 ItemA 项目角色所匹配到的项目 A-web1 新建一个B-web1项目，同理 test2 用户这里看到I temB 项目角色所匹配到的项目B-web1 为了方便项目管理，可以对不同项目进行分类（借助视图）： 分类完如图下所示： 2、Jenkins 参数化构建1、 参数化构建背景 如果只是简单的构建，jenkins自己默认的插件可以做，但是如果我们想要在构建过程中有更多功能，比如说：选择性构建、传参、项目指定变量等等其他功能，基础的参数化构建可以实现一些简单功能，但是要想使用更多功能这时候我们就需要借助参数化构建来实现交互的功能。此处我们来借助以下插件来进行实现： Extended Choice Parameter（更丰富的参数化构建插件） Git Parameter 2、安装插件首先还是安装该插件，去管理插件里面进行安装 Extended Choice Parameter 1、项目配置 2、选择安装过的插件 3、进行配置​ 这里这个branch 我们就相当于给其当做一个变量，然后来为其进行传参。 4、构建选择执行shell进行测试 5、参数化配置已经生效 6、构建 test02可以发现控制台的输出也是成功了的 7、数据来源选择文件在jenkins所在服务器进行如下操作： 12[root@qfedu.com ~]# vim /opt/jenkins.property # 建立一个文件abc=t1,t2,t3,t4 web 端配置： 进行测试： 构建前：（可以发现也是生效的） 构建后查看结果：（也是成功的） 3、Git 插件再用 git 时使用该插件是非常方便的。 1、安装插件 Git Parameter 2、进行配置在配置之前我们先来说一个坑，当我们在配置git中写了远端地址后，会有如下报错： 这是因为 jenkins 我们 yum 装的运行用户是 jenkins 用户，此处是 jenkins 用户去 git 仓库进行拉取，而 jenkins 用户的话默认是 /bin/false 的，不但不能登录，也没有 git 命令权限，所以肯定是失败的。 解决此问题两种办法： 更改jenkins用户为root用户； 更改jenkins用户为正常的普通用户/bin/bash，将其的公钥加入到git服务器的git用户中。 此处暂时先用第一种解决办法，更改 jenkins 的运行用户为 root 用户，通过如下方式进行更改： 将/etc/sysconfig/jenkins文件由改为 然后再重启即可。 3、进行相关配置 4、配置 git 仓库 凭据这里有两种方式： 第一种：选择无 其实就是基于免秘钥的。 第二种：用户（其实就是git用户） 当构建时给一个选择列表，这个变量是代表分支。有哪些分支传递给这个变量。 5、进行构建1、列表中已经有了可选的分支 2、构建成功 3、新建分支增添内容再来验证插件123456789101112131415161718192021[root@qfedu.com app]# git branch * master[root@qfedu.com app]# git branch test[root@qfedu.com app]# git checkout testSwitched to branch &#x27;test&#x27;[root@qfedu.com app]# git branch master* test[root@qfedu.com app]# touch a[root@qfedu.com app]# git add .[root@qfedu.com app]# git commit -m &quot;a&quot;[test c286460] a 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 a[root@qfedu.com app]# git push origin testCounting objects: 3, done.Compressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 231 bytes | 0 bytes/s, done.Total 2 (delta 0), reused 0 (delta 0)To git@172.16.1.3:/home/git/repos/app.git * [new branch] test -&gt; test 4、jenkins 构建查看 可以发现已经有了我们新建的分支。 构建成功！！ 3、Jenkins Master-Slave 架构 jenkins的Master-slave分布式架构主要是为了解决jenkins单点构建任务多、负载较高、性能不足的场景。 Master/Slave相当于Server和agent的概念。Master提供web接口让用户来管理job和slave，job可以运行在master本机或者被分配到slave上运行构建。一个master（jenkins服务所在机器）可以关联多个slave用来为不同的job或相同的job的不同配置来服务。 1、安装前提：slave 所在服务器必须有 java环境 jenkins web 端进行操作： 系统管理-&gt;管理节点-&gt;新建节点 1、进行基础配置 配置选项中的内容是可变的，根据情况来 注意这里需要配置凭据，也就是配置slave所在服务器用户和密码 之后保存，如果无误的话就会直接启动了，如图下所示是有问题的 通过看输出日志，发现是 jdk 的问题，一般来说，其会判断 slave 所在服务器有没有 jdk，如果有就会进行检测，如下图所示，就是没有检查到（因为jdk是我们自己装的，路径并不是默认的路径）。 没有检查到的话其就会去oracle官网下载，来为 slave 所在服务器进行安装，但是因为中国的原因，被墙了，所以也会下载失败，最终就导致彻底失败了，失败如图下： 有两种方法解决：推荐方法1： 方法1： 在配置时高级的选项里指定java路径：如下图所示： 方法2： 为 java 路径做一个软链接，保证 jenkins 可以检测到 java。 123[root@qfedu.com ~]# ln -s /usr/local/jdk1.8/bin/java /usr/bin/java[root@qfedu.com ~]# ll /usr/bin/java lrwxrwxrwx 1 root root 26 Jul 25 17:33 /usr/bin/java -&gt; /usr/local/jdk1.8/bin/java 之后在看已经成功了！ 并且也可以在 slave 所在服务器看到： jar 包就是负责接收 master 任务的。 2、配置在项目 job 中进行配置： 可通过标签或者名称进行匹配（标签可在安装时配置） 3、构建 可以发现控制台的日志，其也是 slave 构建的 之后查看构建完的工作目录，也有预想中的文件。 这样基本上就实现了借助 jenkins 的 slave 去构建 job了。 目前是在 slave 构建也在 slave 上部署，之后我们可以通过脚本，比如借助 rsync、ansible 等部署在其他服务器上。 4、扩展可以为slave服务器在配置时候加上标签，这样也会方便我们选择，用法也不单单局限在一台服务器上，可以让多台 slave 去竞选。 4、Jenkins pipeline1、概览 2、安装在对 jenkins 进行初始化安装时，默认已经安装了 jenkins 的相关插件，如下图所示： 3、实操1、新建任务 2、编写 pipeline 脚本 可以借助流水线语法去做。 test 流水线脚本： 123456789101112131415node &#123; def mvnHome stage(&#x27;git checkout&#x27;) &#123; #for display purposes checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/master&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &#x27;git@172.16.1.3:/home/git/repos/app.git&#x27;]]]) &#125; stage(&#x27;maven Build&#x27;) &#123; echo &quot;maven build.........&quot; &#125; stage(&#x27;deploy&#x27;) &#123; echo &quot;deploy...........&quot; &#125; stage(&#x27;test&#x27;) &#123; echo &quot;test...........&quot; &#125;&#125; 3、构建测试 可以去服务器上验证一下（git checkout）刚才拉取下来的代码： 补充： 可以从代码版本管理仓库中读取 pipeline 脚本（相当于将 pipeline 脚本放在仓库中）我们可以选择git。 首先需要将 pipeline 脚本提交到我们新建的 git仓库中（步骤再此忽略。） jenkins 项目中需要进行如下配置： 其中脚本路径的配置，一定要和版本仓库中的路径相一致。 之后如果要更改步骤，不需要再更改 jenkins 的步骤，直接更改文件即可。 补充： 此外之前的测试一直是在 master上构建的，我们还可以通过在 jenkinsfile 中指定节点在相应节点去构建 具体在 jenkinsfile 的 node 后进行指定： 如下图所示： 格式为：node (“节点名称”) 具体配置详解请参考 https://jenkins.io/doc/book/pipeline/ 5、Jenkins 构建邮件状态通知1、 前提前提：服务器开启邮箱服务 2、 基础配置需要安装一个插件： 插件： Email Extension Plugin 进行配置： 系统管理-&gt;系统设置-&gt;相关配置如下图： 可以在此处进行测试发送！检验配置是否正确 3、 配置到项目中在项目的配置中选择构建后操作 选择我们对应的插件 填写发件人信息 配置构建成功发送邮件 控制台也有邮件发送成功输出 检查实际是否接收到邮件 6、Jenkins 流水线自动化发布PHP项目1、前提环境为：lnmp PHP项目：wordpress（此处我们下载一个wordpress的源码。将其模拟为我们的代码上传到我们的git仓库） 12345678910[root@qfedu.com ~]# git config --global user.name &quot;Administrator&quot;[root@qfedu.com ~]# git config --global user.email &#x27;18611142071@163.com&#x27;[root@qfedu.com ~]# git status[root@qfedu.com ~]# git clone git@192.168.152.138:plat-sp/wordpress.git[root@qfedu.com ~]# tar xf wordpress-5.2.1.tar.gz[root@qfedu.com ~]# cd wordpress[root@qfedu.com ~]# mv /root/wordpress/* .[root@qfedu.com ~]# git add .[root@qfedu.com ~]# git commit -m &#x27;new1&#x27;[root@qfedu.com ~]# git push -u origin master 部署节点： node 节点需要在系统管理中配置节点 2、配置1、创建job 2、参数化构建 3、配置pipeline脚本 （直接配置或者git获取） 4、保存3、编写 jenkinsfile接下里编写jenkinsfile文件： jenkinsfile-PHP： 源码文件： 123456789101112131415161718192021222324252627282930node (&quot;jenkins-slave2&quot;) &#123; stage(&#x27;git checkout&#x27;) &#123; checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;branch&#125;&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &#x27;git@192.168.152.138:plat-sp/wordpress.git&#x27;]]]) &#125; stage(&#x27;code copy&#x27;) &#123; sh &#x27;&#x27;&#x27;rm -rf $&#123;WORKSPACE&#125;/.git mkdir -p /data/backup/web-$(date +&quot;%F&quot;) mv /home/wwwroot/default/* /data/backup/web-$(date +&quot;%F&quot;) cp -rf $&#123;WORKSPACE&#125;/* /home/wwwroot/default/&#x27;&#x27;&#x27; &#125; stage(&#x27;test&#x27;) &#123; sh &quot;curl http://192.168.152.153/status.html&quot; &#125;&#125;node (&quot;slave01-172.16.1.2&quot;) &#123; stage(&#x27;git checkout&#x27;) &#123; checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;branch&#125;&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &#x27;git@172.16.1.3:/home/git/repos/wordpress&#x27;]]]) &#125; stage(&#x27;code copy&#x27;) &#123; sh &#x27;&#x27;&#x27;rm -rf $&#123;WORKSPACE&#125;/.git mv /usr/share/nginx/html/wp.com /data/backup/wp.com-$(date +&quot;%F_%T&quot;) cp -rf $&#123;WORKSPACE&#125; /usr/share/nginx/html/wp.com&#x27;&#x27;&#x27; &#125; stage(&#x27;test&#x27;) &#123; sh &quot;curl http://wp.test.com/status.html&quot; &#125;&#125; 下面为带解释版，但不可以使用，部分注释会造成问题 1234567891011121314151617181920node (&quot;slave01-172.16.1.2&quot;) &#123; # 绑定到该节点去执行 stage(&#x27;git checkout&#x27;) &#123; # 拉代码 checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;branch&#125;&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &#x27;git@172.16.1.3:/home/git/repos/wordpress&#x27;]]]) &#125; # $class: &#x27;GitSCM&#x27; git插件获取代码的工具 # branches 分支名称 # doGenerateSubmoduleConfigurations 是否包含子模块配置 # extensions 扩展功能 # submoduleCfg 子模块配置 # userRemoteConfigs 远程用户配置（仓库地址） stage(&#x27;code copy&#x27;) &#123; # 复制代码 sh &#x27;&#x27;&#x27;rm -rf $&#123;WORKSPACE&#125;/.git # 删除拉下来的项目的.git敏感文件 mv /usr/share/nginx/html/wp.com /data/backup/wp.com-$(date +&quot;%F_%T&quot;) # 备份旧文件 cp -rf $&#123;WORKSPACE&#125; /usr/share/nginx/html/wp.com&#x27;&#x27;&#x27; # 新文件复制到站点目录 &#125; stage(&#x27;test&#x27;) &#123; # 测试 sh &quot;curl http://wp.test.com/status.html&quot; &#125;&#125; 4、构建构建概览： 控制台输出详情： 可以看到每一步的执行详情，最后也是成功的！！！！！！ 此外我们可以查看服务器及网页实际体验效果进行验证。 7、Jenkins流水线自动化发布Java项目1、前提插件：Maven Integration plugin 环境：maven、tomcat，git 用的博客系统代码： git clone https://github.com/b3log/solo.git 远端git服务器： 1234[root@qfedu.com ~]# mkdir -p solo[root@qfedu.com ~]# cd solo/[root@qfedu.com ~]# git --bare initInitialized empty Git repository in /home/git/repos/solo/ 本地web： 123456789101112131415161718[root@qfedu.com ~]# git remote -vorigin git@172.16.1.3:/home/git/repos/solo (fetch)origin git@172.16.1.3:/home/git/repos/solo (push)[root@qfedu.com ~]# git remote rm origin[root@qfedu.com ~]# git initReinitialized existing Git repository in /root/solo/.git/[root@qfedu.com ~]# git remote add origin git@172.16.1.3:/home/git/repos/solo[root@qfedu.com ~]# git add .[root@qfedu.com ~]# git commit -m &quot;java solo all&quot;# On branch masternothing to commit, working directory clean[root@qfedu.com ~]# git push origin masterCounting objects: 29058, done.Compressing objects: 100% (9854/9854), done.Writing objects: 100% (29058/29058), 47.77 MiB | 39.28 MiB/s, done.Total 29058 (delta 15768), reused 29058 (delta 15768)To git@172.16.1.3:/home/git/repos/solo * [new branch] master -&gt; master 因为solo需要改如下配置才可以访问：（改serverhost为指定的域名） 1[root@qfedu.com ~]# vim /root/solo/src/main/resources/latke.properties 然后再重新提交上去 部署节点： node 节点需要在系统管理中配置节点 2、配置1、新建job 2、参数化构建 3、配置git仓库（针对jenkinsfile） 3、编写Jenkinsfile源码配置文件： 12345678910111213141516171819202122232425262728293031node (&quot;slave02-172.16.1.3&quot;) &#123; # def mvnHome = &#x27;/usr/local/maven&#x27; stage(&#x27;git checkout&#x27;) &#123; checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;branch&#125;&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &#x27;git@172.16.1.3:/home/git/repos/solo&#x27;]]]) &#125; stage(&#x27;maven build&#x27;) &#123; sh &#x27;&#x27;&#x27;export JAVA_HOME=/usr/local/java /usr/local/maven/bin/mvn clean package -Dmaven.test.skip=true&#x27;&#x27;&#x27; &#125; stage(&#x27;deploy&#x27;) &#123; sh &#x27;&#x27;&#x27; JENKINS_NODE_COOKIE=dontkillme export JAVA_HOME=/usr/local/java TOMCAT_NAME=tomcat TOMCAT_HOME=/usr/local/$TOMCAT_NAME WWWROOT=$TOMCAT_HOME/webapps/ROOT if [ -d $WWWROOT ]; then mv $WWWROOT /data/backup/$&#123;TOMCAT_NAME&#125;-$(date +&quot;%F_%T&quot;) fi unzip $&#123;WORKSPACE&#125;/target/*.war -d $WWWROOT PID=$(ps -ef |grep $TOMCAT_NAME |egrep -v &quot;grep|$$&quot; |awk \\&#x27;&#123;print $2&#125;\\&#x27;) [ -n &quot;$PID&quot; ] &amp;&amp; kill -9 $PID /bin/bash $TOMCAT_HOME/bin/startup.sh &#x27;&#x27;&#x27; &#125; stage(&#x27;test&#x27;) &#123; sh &quot;curl http://192.168.152.138:8080/status.html&quot; echo &quot;test ok!!!!!!!&quot; &#125;&#125; 下面为带解释版，但不可以使用，部分注释会造成问题 123456789101112131415161718192021222324252627282930node (&quot;slave02-172.16.1.3&quot;) &#123; # 绑定到该节点构建 # def mvnHome = &#x27;/usr/local/maven&#x27; stage(&#x27;git checkout&#x27;) &#123; # 拉代码 checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;$&#123;branch&#125;&#x27;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: &#x27;git@172.16.1.3:/home/git/repos/solo&#x27;]]]) &#125; stage(&#x27;maven build&#x27;) &#123; # maven build sh &#x27;&#x27;&#x27;export JAVA_HOME=/usr/local/java # 在指定java环境变量 /usr/local/maven/bin/mvn clean package -Dmaven.test.skip=true&#x27;&#x27;&#x27; # 构建maven包 clean package表示构建之前会清理之前构建的包，-Dmaven.test.skip=true表示跳过单元测试 &#125; stage(&#x27;deploy&#x27;) &#123; # 部署 sh &#x27;&#x27;&#x27; JENKINS_NODE_COOKIE=dontkillme # tomcat启动时会衍生出一些子进程，然后才能成功启动，但是jenkins会在构建结束杀掉tomcat的那些衍生子进程，造成tomcat启动失败，此处加上这个参数可以解决这个问题。 export JAVA_HOME=/usr/local/java TOMCAT_NAME=tomcat TOMCAT_HOME=/usr/local/$TOMCAT_NAME WWWROOT=$TOMCAT_HOME/webapps/ROOT if [ -d $WWWROOT ]; then # 如果目录存在，先备份 mv $WWWROOT /data/backup/$&#123;TOMCAT_NAME&#125;-$(date +&quot;%F_%T&quot;) fi unzip $&#123;WORKSPACE&#125;/target/*.war -d $WWWROOT # 项目包解压到站点目录 PID=$(ps -ef |grep $TOMCAT_NAME |egrep -v &quot;grep|$$&quot; |awk \\&#x27;&#123;print $2&#125;\\&#x27;) # 重启tomcat [ -n &quot;$PID&quot; ] &amp;&amp; kill -9 $PID /bin/bash $TOMCAT_HOME/bin/startup.sh&#x27;&#x27;&#x27; &#125; stage(&#x27;test&#x27;) &#123; # 测试 # sh &quot;curl http://wp.test.com/status.html&quot; echo &quot;test ok!!!!!!!&quot; &#125;&#125; 4、构建 5、访问 报错处理 pipeline script from SCM方式下： 1234567Started by user ***java.io.FileNotFoundException at jenkins.plugins.git.GitSCMFile$3.invoke(GitSCMFile.java:167) at jenkins.plugins.git.GitSCMFile$3.invoke(GitSCMFile.java:159) at jenkins.plugins.git.GitSCMFileSystem$3.invoke(GitSCMFileSystem.java:193) ...lFinished: FAILURE ​ 原因是git工程下，没有找到Script Path路径下的脚本文件。 8、Jenkins 结合 gitlab 使用1、创建一个新的任务 输入项目的名称，选择构建只有分风格的软件 2、将Jenkins与gitlab联合1、Jenkins创建公钥和私钥1234567891011121314151617181920212223[root@qfedu.com ~]# ssh-keygen Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:5SGYye8oxCKFJjddb4W8JC0RAQhBWCvuG8aZL8eMJs4 root@JenkinsThe key&#x27;s randomart image is:+---[RSA 2048]----+|==....=* .. ||...o oo==. ||+.= . =++.o ||++ o o.+ . ||... o S . ||o.oo o || B+ . . . ||++++ . ||+Eo. |+----[SHA256]-----+[root@qfedu.com ~]# cat .ssh/id_rsa.pub [root@qfedu.com ~]# cat .ssh/id_rsa 2、在gitlab中添加公钥id_rsa.pub 3、在jenkins中添加私钥id_rsa​ 在首页中，点击项目名称的下拉监听 ​ 选择源码管理，先将gitlab的项目地址复制过来 ​ 选择SSH密钥和证书，然后选择直接输入，将私钥复制到下框中即可 ​ 添加完成后，点击保存 ​ 选择刚才创建的证书，完成后，选择构建 选择构建 ​ 拉到最底部，选择使用shell脚本 ​ 脚本内容 ​ 创建测试环境 12[root@qfedu.com ~]# mkdir -p /data/www[root@qfedu.com ~]# chown -R jenkins.jenkins /data/ ​ 选择构建后的操作，让每次构建完成后都将结果发送给管理员 3、测试手动集成回到主页，点击右侧的按钮进行测试 部署完成 查看部署日志 查看部署结果 1234[root@qfedu.com ~]# ll &#x2F;data&#x2F;www&#x2F;总用量 4-rw-r--r-- 1 jenkins jenkins 4 11月 30 21:22 flag-rw-r--r-- 1 jenkins jenkins 0 11月 30 21:22 README.md 4、自动测试（gitlab主动通知Jenkins测试）该功能会使用到一个插件 gitlab plugin 配置gitlab认证 添加一个新的凭证 从gitlab的设置中将 token复制过来（需要手动创建token） 将复制的token粘贴到api token中，点ok 在系统配置中找到Gitlab 将信息进行填写，Credentials 选择刚刚创建对的即可 打开项目，编辑项目的构建触发器 在gitlab上配置连接jenkins ，将Jenkins的Secret token 与Build URL 复制到gitlab中 注意： 在项目设置中的集成 保存之前先进程测试，测试成功后进行保存 在gitlab进行上传文件，可以测试。 在日志中显示是 Started by GitLab push by Administrator 即表示自动集成成功 5、错误解决 错误提示： 12#很多朋友使用最新版本的gitlab做自动部署时，在增加web钩子那一步，#点击test push events时会报错：Url is blocked: Requests to the local network are not allowed 解决方法： 这是因为新版的gitlab为了安全默认禁止了本地局域网地址调用web hook我们在设置里允许就行，具体步骤如下：","categories":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/categories/CICD/"}],"tags":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/tags/CICD/"}]},{"title":"CI/CD入门","slug":"第2天-持续集成持续发布入门","date":"2021-08-07T10:12:00.000Z","updated":"2021-08-22T13:10:29.564Z","comments":true,"path":"2021/08/07/第2天-持续集成持续发布入门/","link":"","permalink":"https://yzhou15.gitee.io/2021/08/07/%E7%AC%AC2%E5%A4%A9-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E6%8C%81%E7%BB%AD%E5%8F%91%E5%B8%83%E5%85%A5%E9%97%A8/","excerpt":"","text":"第2天-CI/CD入门一、代码上线方案1、早期手动部署代码 纯手动Scp、Rsync上传代码。 纯手动登陆，Git pull 或者 Svn update。 纯手动xftp、ftp、filezilla上传代码。 开发发送压缩包，rz上传，解压部署代码。 缺点： 全程运维参与，占用大量时间。 如果节点多，上线速度慢。 人为失误多，目录管理混乱。 回滚不及时，或者难以回退。 上线方案示意图： 2、合理化上线方案 开发人员(rd)需在个人电脑搭建LAMP环境测试开发好的网站代码，并且在办公室或 IDC机房的测试环境测试通过，最好有专职测试人员(ts)。 程序代码上线要规定时间，例如：三天上线一次，如网站需经常更新可每天下午 20 点上线，这个看网站业务性质而定，原则就是影响用户体验最小。 代码上线之前需备份，网站程序出了问题方便回退，另外，从上线技巧上讲，上传代码时尽可能先传到服务器网站临时目录，传完整后一步mv过去，或者通过In做软链接— 线上更新代码的思路。如果严格更新，把应用服务器从集群节点平滑下线，然后更新。 尽量由运维人员管理上线，对于代码的功能性，开发人员更在意，而对于代码的性能优化和上线后服务器的稳定，运维更在意服务器的稳定，因此，如果网站宕机问题归运维管，就要让运维上线，这样更规范科学。否则，开发随意更新，出了问题运维负责，这样就错了，运维永远无法抬头。 ​ web代码规范化上线流程图 3、大型企业上线制度和流程JAVA代码环境上线时，有数台机器同时需要更新或者分批更新 本地开发人员取svn代码。当天上线提交到trunk，否则，长期项目单开分支开发，然后在合并主线(trunk) 办公内网开发测试时，由开发人员或配置管理员通过部署平台jenkins实现统一部署，（即在部署平台上控制开发机器从svn取代码，编译，打包，发布到开发机，包名如idc_dep.war）. 开发人员通知或和测试人员一起测试程序，没有问题后，由配置管理员打上新的tag标记。这里要注意，不同环境的配置文件是随代码同时发布的。 配置管理员，根据上一步的tag标记，checkout出上线代码，并配置好IDC测试环境的所有配置，执行编译，打包(mvn,ant)(php不需要打包)，然后发布到IDC内的统一分发服务器。 配置管理员或SA上线人员，把分发的程序代码内容推送到相关测试服务器（包名如idc_test.war），然后通知开发及测试人员进行测试。如果有问题向上回退，继续修改。 如果IDC测试没有问题，继续打好tag标记，此时，配置管理员，根据上步的tag标记，checkout出测试好的代码，并配置好IDC正式环境的所有配置，执行编译，打包(mvn,ant)(php不需要打包)，然后发布到IDC内的统一分发服务器主机，准备批量发布。 配置管理员或SA上线人员，把分发的内容推送到相关正式服务器（包名如idc_product.war）,然后通知开发及测试人员进行测试。如果有问题直接发布回滚指令。 IDC正式上线的过程对于JAVA程序，可以是AB组分组上线的思路，即平滑下线一半的服务器，然后发布更新代码，重启测试，无问题后，挂上更新后的服务器，同时再平滑下线另一半的服务器，然后发布更新代码测试（或者直接发布后，重启，挂上线） 4 、php程序代码上线的具体方案 对于PHP上线方法：发布代码时（也需要测试流程）可以直接发布到正式线临时目录 ，然后mv或更改link的方式发布到正式上线目录 ，不需要重启http服务。这是新朗，赶集的上线方案。 5 、Java程序代码上线的具体方案对于java上线方法:较大公司需要分组平滑上线（如从负载均衡器上摘掉一半的服务器），发布代码后，重启服务器测试，没问题后，挂上上好线的一半，再下另外一半。如果前端有DNS智能解析，上线还可以分地区上线若干服务器，逐渐普及到全国的服务器，这个被称为“灰度发布”，在后面门户网站上线的知识里我们在讲解。 6 、代码上线解决方案注意事项上线的流程里，办公室测试环境–&gt;IDC测试环境–&gt;正式生产环境，所有环境中的所有软件均应版本统一，其次尽量单一，否则将后患无穷，开发测试成功，IDC测试就可能有问题（如:操作系统，web服务器，jdk,php,tomcat,resin等版本） 开发团队小组办公内部测试环境测试（该测试环境属于开发小组维护，或定时自动更新代码），代码有问题返回给某开发人员重新开发。 有专门的测试工程师，程序有问题直接返回给开发人员（此时返回的一般为程序的BUG，称为BUG库），无问题进行IDC测试 IDC测试由测试人员和运维人员参与，叫IDCtest,进行程序的压力测试，有问题直接返回给开发人员，无问题进行线上环境上线。 数台服务器代码分发上线方案举例（JAVA程序） A:假设同业务服务器有6台，将服务器分为A,B两组，A组三台，B组三台，先对A组进行从负载均衡器上平滑下线，B组正常提供服务，避免服务器因上线影响业务。 B:下线过程是通过脚本将A组服务器从RS池（LVS,NGINX,HAPROXY,F5等均有平滑方案）中踢出，避免负裁均衡器将请求发送给A组服务器（此时的时间应该为网站流量少时，一般为晚上） C:将代码分发到A组服务器的站点目录下，对A组服务器上线并重启服务，并由专业的测试人员进行访问测试，测试成功后，挂上A组的服务器，同时下线B组服务器，B组代码上线操作测试等和A组相同，期间也要观察上线提供服务的服务器状况，有问题及时回滚。 如果是PHP程序，则上线可以简单化，直接将上线代码（最好全量）发布到所有上线服务器的特定目录后，分发完成后，一次性mv或ln到站点目录，当然测试也是少不了的。测试除了人员测试外，还有各种测试脚本测试各个相关业务接口。 二、理解持续集成、持续交付、持续部署软件开发的连续方法基于自动执行脚本，以最大限度地减少在开发应用程序时引入错误的可能性。从新代码的开发到部署，它们需要较少的人为干预甚至根本不需要干预。它涉及在每次小迭代中不断构建，测试和部署代码更改，从而减少基于有缺陷或失败的先前版本开发新代码的机会。有三种主要方法，分别为持续集成、持续交付、持续部署，每种方法都根据最适合您的策略进行应用。 1、持续集成代码合并，构建，部署，测试都在一起，不断地执行这个过程，并对结果反馈。 持续集成（英语：Continuous integration，缩写为 CI），一种软件工程流程，将所有工程师对于软件的工作复本，每天集成数次到共用主线（mainline）上。 这个名称最早由葛来迪·布区（Grady Booch）在他的布区方法中提出，但是他并没有提到要每天集成数次。之后成为极限编程（extreme programming，缩写为XP）的一部分。在测试驱动开发（TDD）的作法中，通常还会搭配自动单元测试。 持续集成的提出，主要是为了解决软件进行系统集成时面临的各项问题，极限编程称这些问题为集成地狱（integration hell）。 持续集成主要是强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。简单来讲就是：频繁地（一天多次）将代码集成到主干。 持续集成的目的 及早发现集成错误且由于修订的内容较小所以易于追踪，这可以节省项目的时间与成本。 避免发布日期的前一分钟发生混乱，当每个人都会尝试为他们所造成的那一点点不兼容的版本做检查。 当单元测试失或发生错误，若开发人员需要在不除错的情况下还原代码库到一个没有问题的状态，只需要放弃一小部分的更改 (因为集成的次数频繁)。 让 “最新” 的程序可保持可用的状态供测试、展示或发布用。 频繁的提交代码会促使开发人员创建模块化，低复杂性的代码。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 2、持续交付部署到测试环境、预生产环境 持续交付（英语：Continuous delivery，缩写为 CD），是一种软件工程手法，让软件产品的产出过程在一个短周期内完成，以保证软件可以稳定、持续的保持在随时可以释出的状况。 它的目标在于让软件的建置、测试与释出变得更快以及更频繁。这种方式可以减少软件开发的成本与时间，减少风险。 持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。 3、持续部署将最终产品发布到生成环境，给用户使用 持续部署（英语：Continuous Deployment，缩写为 CD），是持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。 有时候，持续部署也与持续交付混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。 持续部署即在持续交付的基础上，把部署到生产环境的过程自动化。 三、Maven 私服 Nexus31、Maven和Nexus3 简介Maven是一个采用纯Java编写的开源项目管理工具 采用一种被称之为Project Object Model(POM)概念来管理项目，所有的项目配置信息都被定义在一个叫做POM.xml的文件中, 通过该文件Maven可以管理项目的整个生命周期，包括清除、编译，测试，报告、打包、部署等等。 目前Apache下绝大多数项目都已经采用Maven进行管理. 而Maven本身还支持多种插件, 可以方便更灵活的控制项目, 开发人员的主要任务应该是关注商业逻辑并去实现它, 而不是把时间浪费在学习如何在不同的环境中去依赖jar包,项目部署等。 Maven和ant都是软件构建工具（软件管理工具),Maven比Ant更加强大，已经取代了ant,jar包的声明式依赖描述。Maven有jar包的仓库。 私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。 公司如果没有maven私服，则需要用手动打jar包的方式添加依赖 2、安装 Maven1、下载 maven1[root@qfedu.com ~]# wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.5.4/binaries/apache-maven-3.5.4-bin.tar.gz 2、解压安装123[root@qfedu.com ~]# tar xf apache-maven-3.5.4-bin.tar.gz -C /usr/local/[root@qfedu.com ~]# cd /usr/local/[root@qfedu.com ~]# ln -s apache-maven-3.5.4/ maven 3、安装 java 环境123[root@qfedu.com ~]# tar xf jdk-8u201-linux-x64.tar.gz -C /usr/local/[root@qfedu.com ~]# cd /usr/local/[root@qfedu.com ~]# ln -s jdk1.8.0_201/ java 4、添加环境变量1[root@qfedu.com ~]# vim /etc/profile 添加如下内容（这里的MAVEN_HOME需要改为你自己的maven解压目录）： 12345JAVA_HOME=/usr/local/javaexport MAVEN_HOME=/usr/local/mavenexport JRE_HOME=/usr/local/java/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$MAVEN_HOME/bin:$PATH 重载环境变量 1[root@qfedu.com ~]# source /etc/profile 5、验证 maven 安装输入命令 mvn -version 看到如下内容说明安装成功了。 3、安装 nexus31、下载专业版的nexus收费，下载开源版 Nexus OSS,下载地址为 https://www.sonatype.com/download-oss-sonatype Wing下载的时候可以获取链接用迅雷下载，我是直接把https改成了http下载，下载下来的包大小不一样，我暂时使用的是小一点的120多M的安装包 2、解压12[root@qfedu.com ~]# cd /usr/local[root@qfedu.com ~]# tar -zxf nexus-3.13.0-01-unix.tar.gz 解压后会多出两个目录，nexus-3.13.0-01和sonatype-work。 3、启动12[root@qfedu.com ~]# cd nexus-3.13.0-01/bin/[root@qfedu.com ~]# ./nexus start 看到如图所示内容表明我们已经启动成功了，游览器输入http://localhost:8081即可访问。 注意： 启动后如果你立即访问可能发现什么都没有，不要急这个启动需要一定时间，1分钟后再尝试访问 登录 ： 点击右上角的sign in登录，输入账户admin 密码: 12# cat /root/sonatype-work/nexus3/admin.password91c37108-809a-495b-942d-3932b9b33e04 4、仓库介绍点击“设置-Repositories”，就可以看到仓库，分三种类型： proxy：是远程仓库的代理。比如说在nexus中配置了一个central repository的proxy，当用户向这个proxy请求一个artifact，这个proxy就会先在本地查找，如果找不到的话，就会从远程仓库下载，然后返回给用户，相当于起到一个中转的作用。 Hosted：是宿主仓库，用户可以把自己的一些构件，deploy到hosted中，也可以手工上传构件到hosted里。比如说oracle的驱动程序，ojdbc6.jar，在central repository是获取不到的，就需要手工上传到hosted里，一般用来存放公司自己的jar包； Group：是仓库组，在maven里没有这个概念，是nexus特有的。目的是将上述多个仓库聚合，对用户暴露统一的地址，这样用户就不需要在pom中配置多个地址，只要统一配置group的地址就可以了右边那个Repository Path可以点击进去，看到仓库中artifact列表。不过要注意浏览器缓存，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。 maven-public：maven-central、maven-release和maven-snapshot三个库的合集。 maven-release：用来存放release版本的jar包。 maven-snapshot：用来存放snapshot版本的jar包。 关于Maven的Snapshot版本与Release版本 Snapshot版本代表不稳定、尚处于开发中的版本 Release版本则代表稳定的版本 什么情况下该用SNAPSHOT?协同开发时，如果A依赖构件B，由于B会更新，B应该使用SNAPSHOT来标识自己。这种做法的必要性可以反证如下： a.如果B不用SNAPSHOT，而是每次更新后都使用一个稳定的版本，那版本号就会升得太快，每天一升e68a84e8a2ade79fa5e9819331333363396362甚至每个小时一升，这就是对版本号的滥用。 b.如果B不用SNAPSHOT, 但一直使用一个单一的Release版本号，那当B更新后，A可能并不会接受到更新。因为A所使用的repository一般不会频繁更新release版本的缓存（即本地repository)，所以B以不换版本号的方式更新后，A在拿B时发现本地已有这个版本，就不会去远程Repository下载最新的B 不用Release版本，在所有地方都用SNAPSHOT版本行不行？不行。正式环境中不得使用snapshot版本的库。 比如说，今天你依赖某个snapshot版本的第三方库成功构建了自己的应用，明天再构建时可能就会失败，因为今晚第三方可能已经更新了它的snapshot库。你再次构建时，Maven会去远程repository下载snapshot的最新版本，你构建时用的库就是新的jar文件了，这时正确性就很难保证了。 5、向 nexus3 私服上传 jar 包1、准备环境1、创建3rd_part库使用默认用户 admin/admin123 登陆 点击左侧的repository\\repositories后,在右侧点击create repository 然后选择maven2(hosted),填写如下 跳到首页后选择maven-public 将3rd_part移到member中,即将3rd_part由maven-public管理，点击save 至此,创建仓库完成 2、创建 3rd_part 管理用户创建用户: 用户名/密码-dev/dev123 2、直接浏览器使用dev/dev123登陆，点击upload 填写上传jar包的信息后，点击upload 可以看到已经上传成功 4、常见错误问题1：上传报错误码405，Failed to transfer file。 ​ 解决：仔细查看报错信息就会发现，是上传的url错了,原因就是repository的地址写错了。 问题2：错误码401或者403 ​ 解决：其实403错误就是“禁止访问”的含义，所以问题的根源肯定在授权上面。Maven在默认情况下会使用deployment帐号(默认密码deploy)登录的系统，但是关键的Nexus中Releases仓库默认的Deployment Policy是“Disable Redeploy”，所以无法部署的问题在这个地方，方法是将其修改为“Allow Redeploy”就可以了。401就是Maven settings.xml没有设置密码","categories":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/categories/CICD/"}],"tags":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/tags/CICD/"}]},{"title":"Immutable.js了解一下？(转载)","slug":"Immutable.js了解一下？(转载)","date":"2021-08-06T09:50:00.000Z","updated":"2021-08-08T08:26:29.743Z","comments":true,"path":"2021/08/06/Immutable.js了解一下？(转载)/","link":"","permalink":"https://yzhou15.gitee.io/2021/08/06/Immutable.js%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F(%E8%BD%AC%E8%BD%BD)/","excerpt":"","text":"**桂圆_noble**关注 4March 29, 2018 4:36 PM字数 3,214阅读 43,215 本篇只是对Immutable.js的简单介绍，后续会继续分享其具体实践应用。 immutable.jpeg 什么是Immutable Data？ Immutable data encourages pure functions (data-in, data-out) and lends itself to much simpler application development and enabling techniques from functional programming such as lazy evaluation.– 官方文档对其描述 Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画： https://upload-images.jianshu.io/upload_images/2165169-cebb05bca02f1772?imageMogr2/auto-orient/strip|imageView2/2/w/613/format/webp 结构共享 Immutable的优缺点一览优点1. 降低 Mutable 带来的复杂度共享的可变状态是万恶之源，举个简单的例子就是js中的引用赋值： 1var obj &#x3D; &#123; a: 1 &#125;; var copy_obj &#x3D; obj; copy_obj.a &#x3D; 2; console.log(obj.a); &#x2F;&#x2F; 2 引用赋值虽然可以节省内存，但当应用复杂之后，可变状态往往会变成噩梦，通常一般的做法是使用shallowCopy或者deepCopy来避免被修改，但这样造成了CPU和内存的消耗，不过Immulate可以很好地解决这些问题。 2. 节省内存空间上面提到了结构共享，Immutable.js 使用这种方式会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。 `import { Map } from ‘immutable’; let a = Map({ select: ‘users’, filter: Map({ name: ‘Cam’ }) }) let b = a.set(‘select’, ‘people’); a === b; // false a.get(‘filter’) === b.get(‘filter’); // true` 上面 a 和 b 共享了没有变化的 filter 节点。 3. Undo/Redo，Copy/Paste，随意穿越！因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 4. 拥抱函数式编程Immutable（持久化数据结构）本身就是函数式编程中的概念。函数式编程关心数据的映射，命令式编程关心解决问题的步骤，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。 缺点抛开学习成本和额外引入的资源文件这些不说，我们来看看使用过程中有哪些不爽的地方。 1. 容易与原生对象混主要是Immutable的API设计的和原生对象类似，容易混淆操作。例如其中Map和List的操作： `// Immutable const map = Map({ a: 1, b: 2 }); const list = List([1,2,3]); // 原生js const obj = { a: 1, b: 2 }; const arry = [1,2,3]; // 取值方式对比 console.log(map.get(‘a’)); console.log(list.get(0)); console.log(obj.a); console.log(arry[0]);` Immutable.js简介Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce``find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。 immutablejs-getters-and-setters-everywhere.jpg Immutable.js 的几种数据类型 List: 有序索引集，类似JavaScript中的Array。Map: 无序索引集，类似JavaScript中的Object。OrderedMap: 有序的Map，根据数据的set()进行排序。Set: 没有重复值的集合。OrderedSet: 有序的Set，根据数据的add进行排序。Stack: 有序集合，支持使用unshift()和shift()添加和删除。Record: 一个用于生成Record实例的类。类似于JavaScript的Object，但是只接收特定字符串为key，具有默认值。Seq: 序列，但是可能不能由具体的数据结构支持。Collection: 是构建所有数据结构的基类，不可以直接构建。 用的最多就是List和Map，所以在这里主要介绍这两种数据类型的API。 Immutable.js 的常用APIfromJS()作用：将一个js数据转换为Immutable类型的数据用法：fromJS(value, converter)简介：value是要转变的数据，converter是要做的操作。第二个参数可不填，默认情况会将数组准换为List类型，将对象转换为Map类型，其余不做操作 代码实现： 1234&#96;const obj &#x3D; Immutable.fromJS(&#123;a:&#39;123&#39;,b:&#39;234&#39;&#125;,function (key, value, path) &#123; console.log(key, value, path) return isIndexed(value) ? value.toList() : value.toOrderedMap())&#125;)&#96; toJS()作用：将一个Immutable数据转换为JS类型的数据用法：value.toJS() is()作用：对两个对象进行比较用法：is(map1,map2)简介：和js中对象的比较不同，在js中比较两个对象比较的是地址，但是在Immutable中比较的是这个对象hashCode和valueOf，只要两个对象的hashCode相等，值就是相同的，避免了深度遍历，提高了性能 代码实现： 1import &#123; Map, is &#125; from &#39;immutable&#39; const map1 &#x3D; Map(&#123; a: 1, b: 1, c: 1 &#125;) const map2 &#x3D; Map(&#123; a: 1, b: 1, c: 1 &#125;) map1 &#x3D;&#x3D;&#x3D; map2 &#x2F;&#x2F;false Object.is(map1, map2) &#x2F;&#x2F; false is(map1, map2) &#x2F;&#x2F; true List() 和 Map()作用：用来创建一个新的List/Map对象用法: `//List Immutable.List(); // 空List Immutable.List([1, 2]); //Map Immutable.Map(); // 空Map Immutable.Map({ a: ‘1’, b: ‘2’ });` List.isList() 和 Map.isMap()作用：判断一个数据结构是不是List/Map类型用法： `List.isList([]); // false List.isList(List()); // true Map.isMap({}) // false Map.isMap(Map()) // true` size作用：属性，获取List/Map的长度，等同于ImmutableData.count(); get() 、 getIn()作用：获取数据结构中的数据 `//获取List索引的元素 ImmutableData.get(0); // 获取Map对应key的value ImmutableData.get(‘a’); // 获取嵌套数组中的数据 ImmutableData.getIn([1, 2]); // 获取嵌套map的数据 ImmutableData.getIn([‘a’, ‘b’]);` has() 、 hasIn()作用：判断是否存在某一个key用法： 1Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has(&#39;0&#39;); &#x2F;&#x2F;true Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).has(&#39;0&#39;); &#x2F;&#x2F;true Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).hasIn([3,&#39;b&#39;]) &#x2F;&#x2F;true includes()作用：判断是否存在某一个value用法： 1Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(2); &#x2F;&#x2F;true Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(&#39;2&#39;); &#x2F;&#x2F;false 不包含字符2 Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(5); &#x2F;&#x2F;false Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(&#123;a:4,b:5&#125;) &#x2F;&#x2F;false Immutable.fromJS([1,2,3,&#123;a:4,b:5&#125;]).includes(Immutable.fromJS(&#123;a:4,b:5&#125;)) &#x2F;&#x2F;true first() 、 last()作用：用来获取第一个元素或者最后一个元素，若没有则返回undefined代码： `Immutable.fromJS([1,2,3,{a:4,b:5}]).first()//1 Immutable.fromJS([1,2,3,{a:4,b:5}]).last()//{a:4,b:5} Immutable.fromJS({a:1,b:2,c:{d:3,e:4}}).first() //1 Immutable.fromJS({a:1,b:2,c:{d:3,e:4}}).first() //{d:3,e:4}` 数据修改注：这里对于数据的修改，是对原数据进行操作后的值赋值给一个新的数据，并不会对原数据进行修改，因为Immutable是不可变的数据类型。 设置 set()作用：设置第一层key、index的值用法： `const originalList = List([ 0 ]); // List [ 0 ] originalList.set(1, 1); // List [ 0, 1 ] originalList.set(0, ‘overwritten’); // List [ “overwritten” ] originalList.set(2, 2); // List [ 0, undefined, 2 ] List().set(50000, ‘value’).size; // 50001 const originalMap = Map() const newerMap = originalMap.set(‘key’, ‘value’) const newestMap = newerMap.set(‘key’, ‘newer value’) originalMap // Map {} newerMap // Map { “key”: “value” } newestMap // Map { “key”: “newer value” }` List在使用的时候，将index为number值设置为value。Map在使用的时候，将key的值设置为value。 在List中使用时，若传入的number为负数，则将index为size+index的值设置为value，例，若传入-1，则将size-1的值设为value。若传入的number的值超过了List的长度，则将List自动补全为传入的number的值，将number设置为value，其余用undefined补全。注：跟js中不同，List中不存在空位，[,,,],List中若没有值，则为undefined。 setIn()作用：设置深层结构中某属性的值用法： `const originalMap = Map({ subObject: Map({ subKey: ‘subvalue’, subSubObject: Map({ subSubKey: ‘subSubValue’ }) }) }) const newMap = originalMap.setIn([‘subObject’, ‘subKey’], ‘ha ha!’) // Map { // “subObject”: Map { // “subKey”: “ha ha!”, // “subSubObject”: Map { “subSubKey”: “subSubValue” } // } // } const newerMap = originalMap.setIn( [‘subObject’, ‘subSubObject’, ‘subSubKey’], ‘ha ha ha!’ ) // Map { // “subObject”: Map { // “subKey”: “subvalue”, // “subSubObject”: Map { “subSubKey”: “ha ha ha!” } // } // }` 用法与set()一样，只是第一个参数是一个数组，代表要设置的属性所在的位置 删除 delete作用：用来删除第一层结构中的属性用法： `// List List([ 0, 1, 2, 3, 4 ]).delete(0); // List [ 1, 2, 3, 4 ] // Map const originalMap = Map({ key: ‘value’, otherKey: ‘other value’ }) // Map { “key”: “value”, “otherKey”: “other value” } originalMap.delete(‘otherKey’) // Map { “key”: “value” }` deleteIn()用来删除深层数据，用法参考setIn deleteAll() (Map独有，List没有)作用：用来删除Map中的多个key用法：deleteAll(keys: Iterable): this代码示例： 1const names &#x3D; Map(&#123; a: &quot;Aaron&quot;, b: &quot;Barry&quot;, c: &quot;Connor&quot; &#125;) names.deleteAll([ &#39;a&#39;, &#39;c&#39; ]) &#x2F;&#x2F; Map &#123; &quot;b&quot;: &quot;Barry&quot; &#125; 更新 update()作用：对对象中的某个属性进行更新，可对原数据进行相关操作用法： `////List const list = List([ ‘a’, ‘b’, ‘c’ ]) const result = list.update(2, val =&gt; val.toUpperCase()) ///Map const aMap = Map({ key: ‘value’ }) const newMap = aMap.update(‘key’, value =&gt; value + value)` updateIn()用法参考setIn 清除 clear()作用：清除所有数据用法：clear(): this代码示例： 1Map(&#123; key: &#39;value&#39; &#125;).clear() &#x2F;&#x2F;Map List([ 1, 2, 3, 4 ]).clear() &#x2F;&#x2F; List List中的各种删除与插入 List对应的数据结构是js中的数组，所以数组的一些方法在Immutable中也是通用的，比如push，pop,shift， unshift，insert。 push()在List末尾插入一个元素 pop()在List末尾删除一个元素 unshift在List首部插入一个元素 shift在List首部删除一个元素 insert在List的index处插入元素代码实现： 1List([ 0, 1, 2, 3, 4 ]).insert(6, 5) &#x2F;&#x2F;List [ 0, 1, 2, 3, 4, 5 ] List([ 1, 2, 3, 4 ]).push(5) &#x2F;&#x2F; List [ 1, 2, 3, 4, 5 ] List([ 1, 2, 3, 4 ]).pop() &#x2F;&#x2F; List[ 1, 2, 3 ] List([ 2, 3, 4]).unshift(1); &#x2F;&#x2F; List [ 1, 2, 3, 4 ] List([ 0, 1, 2, 3, 4 ]).shift(); &#x2F;&#x2F; List [ 1, 2, 3, 4 ] List中还有一个特有的方法用法设置List的长度，setSize() 1List([]).setSize(2).toJS() &#x2F;&#x2F;[undefined,undefined] 关于merge merge作用：浅合并，新数据与旧数据对比，旧数据中不存在的属性直接添加，就数据中已存在的属性用新数据中的覆盖 mergrWith作用：自定义浅合并，可自行设置某些属性的值 mergeIn作用：对深层数据进行浅合并 mergeDeep作用：深合并，新旧数据中同时存在的的属性为新旧数据合并之后的数据 mergeDeepIn作用：对深层数据进行深合并 mergrDeepWith作用：自定义深合并，可自行设置某些属性的值 这里用一段示例彻底搞懂merge，此示例为Map结构，List与Map原理相同 `const Map1 = Immutable.fromJS({a:111,b:222,c:{d:333,e:444}}); const Map2 = Immutable.fromJS({a:111,b:222,c:{e:444,f:555}}); const Map3 = Map1.merge(Map2); //Map {a:111,b:222,c:{e:444,f:555}} const Map4 = Map1.mergeDeep(Map2); //Map {a:111,b:222,c:{d:333,e:444,f:555}} const Map5 = Map1.mergeWith((oldData,newData,key)=&gt;{ if(key === ‘a’){ return 666; }else{ return newData } },Map2); //Map {a:666,b:222,c:{e:444,f:555}}` 序列算法 concat()作用：对象的拼接，用法与js数组中的concat()相同，返回一个新的对象。用法：const List = list1.concat(list2) map()作用：遍历整个对象，对Map/List元素进行操作，返回一个新的对象。用法： 1Map(&#123;a:1,b:2&#125;).map(val&#x3D;&gt;10*val) &#x2F;&#x2F;Map&#123;a:10,b:20&#125; Map特有的mapKey()作用：遍历整个对象，对Map元素的key进行操作，返回一个新的对象。用法： 1Map(&#123;a:1,b:2&#125;).mapKey(val&#x3D;&gt;val+&#39;l&#39;) &#x2F;&#x2F;Map&#123;al:10,bl:20&#125; Map特有的mapEntries()作用：遍历整个对象，对Map元素的key和value同时进行操作，返回一个新的对象。Map的map()也可实现此功能。用法： 1Map(&#123;a:1,b:2&#125;).map((key,val)&#x3D;&gt;&#123; return [key+&#39;l&#39;,val*10] &#125;) &#x2F;&#x2F;Map&#123;al:10,bl:20&#125; 过滤 filter作用：返回一个新的对象，包括所有满足过滤条件的元素用法： 1Map(&#123;a:1,b:2&#125;).filter((key,val)&#x3D;&gt;&#123; return val &#x3D;&#x3D; 2 &#125;) &#x2F;&#x2F;Map&#123;b:2&#125; 还有一个filterNot()方法，与此方法正好相反。 反转 reverse作用：将数据的结构进行反转代码示例： 1Immutable.fromJS([1, 2, 3, 4, 5]).reverse(); &#x2F;&#x2F; List [5,4,3,2,1] Immutable.fromJS(&#123;a:1,b:&#123;c:2,d:3&#125;,e:4&#125;).recerse(); &#x2F;&#x2F;Map &#123;e:4,b:&#123;c:2,d:3&#125;,a:1&#125; 排序 sort &amp; sortBy作用：对数据结构进行排序代码示例： `///List Immutable.fromJS([4,3,5,2,6,1]).sort() // List [1,2,3,4,5,6] Immutable.fromJS([4,3,5,2,6,1]).sort((a,b)=&gt;{ if (a &lt; b) { return -1; } if (a &gt; b) { return 1; } if (a === b) { return 0; } }) // List [1,2,3,4,5,6] Immutable.fromJS([{a:3},{a:2},{a:4},{a:1}]).sortBy((val,index,obj)=&gt;{ return val.get(‘a’) },(a,b)=&gt;{ if (a &lt; b) { return -1; } if (a &gt; b) { return 1; } if (a === b) { return 0; } }) //List [ {a:3}, {a:2}, {a:4}, {a:1} ] //Map Immutable.fromJS( {b:1, a: 3, c: 2, d:5} ).sort() //Map {b: 1, c: 2, a: 3, d: 5} Immutable.fromJS( {b:1, a: 3, c: 2, d:5} ).sort((a,b)=&gt;{ if (a &lt; b) { return -1; } if (a &gt; b) { return 1; } if (a === b) { return 0; } }) //Map {b: 1, c: 2, a: 3, d: 5} Immutable.fromJS( {b:1, a: 3, c: 2, d:5} ).sortBy((value, key, obj)=&gt; { return value }) //Map {b: 1, c: 2, a: 3, d: 5}` 分组 groupBy作用：对数据进行分组 1const listOfMaps &#x3D; List([ Map(&#123; v: 0 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 1 &#125;), Map(&#123; v: 0 &#125;), Map(&#123; v: 2 &#125;) ]) const groupsOfMaps &#x3D; listOfMaps.groupBy(x &#x3D;&gt; x.get(&#39;v&#39;)) &#x2F;&#x2F; Map &#123; &#x2F;&#x2F; 0: List [ Map&#123; &quot;v&quot;: 0 &#125;, Map &#123; &quot;v&quot;: 0 &#125; ], &#x2F;&#x2F; 1: List [ Map&#123; &quot;v&quot;: 1 &#125;, Map &#123; &quot;v&quot;: 1 &#125; ], &#x2F;&#x2F; 2: List [ Map&#123; &quot;v&quot;: 2 &#125; ], &#x2F;&#x2F; &#125; 查找数据indexOf() 、 lastIndexOf Map不存在此方法作用：和js数组中的方法相同，查找第一个或者最后一个value的index值，找不到则返回-1用法： 1Immutable.fromJS([1,2,3,4]).indexof(3) &#x2F;&#x2F;2 Immutable.fromJS([1,2,3,4]).lastIndexof(3) &#x2F;&#x2F;2 findIndex() 、 findLastIndex() Map不存在此方法作用：查找满足要求的元素的index值用法： 1Immutable.fromJS([1,2,3,4]).findIndex((value,index,array)&#x3D;&gt;&#123; return value%2 &#x3D;&#x3D;&#x3D; 0; &#125;) &#x2F;&#x2F; 1 Immutable.fromJS([1,2,3,4]).findLastIndex((value,index,array)&#x3D;&gt;&#123; return index%2 &#x3D;&#x3D;&#x3D; 0; &#125;) &#x2F;&#x2F; 3 find() 、 findLast()作用：查找满足条件的元素的value值用法： `Immutable.fromJS([1,2,3,4]).find((value,index,array)=&gt;{ return value%2 === 0; }) // 2 Immutable.fromJS([1,2,3,4]).findLast((value,index,array)=&gt;{ return value%2 === 0; }) // 4` findKey() 、 findLastKey()作用：查找满足条件的元素的key值用法： `Immutable.fromJS([1,2,3,4]).findKey((value,index,array)=&gt;{ return value%2 === 0; }) // 1 Immutable.fromJS([1,2,3,4]).findLastKey((value,index,array)=&gt;{ return value%2 === 0; }) // 3` findEntry() 、 findLastEntry()作用：查找满足条件的元素的键值对 key:value用法： `Immutable.fromJS([1,2,3,4]).findEntry((value,index,array)=&gt;{ return value%2 === 0; }) // [1,2] Immutable.fromJS([1,2,3,4]).findLastEntry((value,index,array)=&gt;{ return value%2 === 0; }) // [3,4]` keyOf() lastKeyOf()作用：查找某一个value对应的key值用法： 1Immutable.fromJS([1,2,3,4]).keyOf(2) &#x2F;&#x2F;1 Immutable.fromJS([1,2,3,4]).lastKeyOf(2) &#x2F;&#x2F;1 max() 、 maxBy()作用：查找最大值用法: `Immutable.fromJS([1, 2, 3, 4]).max() //4 Immutable.fromJS([{a;1},{a:2},{a: 3},{a:4}]).maxBy((value,index,array)=&gt;{ return value.get(‘a’) }) //{a:4}` min() 、 minBy()作用：查找最小值用法: `Immutable.fromJS([1, 2, 3, 4]).min() //1 Immutable.fromJS([{a;1},{a:2},{a: 3},{a:4}]).minBy((value,index,array)=&gt;{ return value.get(‘a’) }) //{a:1}` 创建子集 slice()作用： 和原生js中数组的slice数组一样，包含两个参数，start和end，start代表开始截取的位置，end代表结束的位置，不包括第end的元素。若不包括end，则返回整个对象，若end为负数，则返回（start，length-end）对应的数据。若start只有一个并且为负数，则返回最后的end个元素。用法： 1Immutable.fromJS([1, 2, 3, 4]).slice(0); &#x2F;&#x2F;[1,2,3,4] Immutable.fromJS([1, 2, 3, 4]).slice(0,2); &#x2F;&#x2F;[1,2] Immutable.fromJS([1, 2, 3, 4]).slice(-2); &#x2F;&#x2F;[3,4] Immutable.fromJS([1, 2, 3, 4]).slice(0,-2); &#x2F;&#x2F;[1,2] rest()作用：返回除第一个元素之外的所有元素用法: 1Immutable.fromJS([1, 2, 3, 4]).rest()&#x2F;&#x2F;[2,3,4] butLast()作用：返回除最后一个元素之外的所有元素用法: 1Immutable.fromJS([1, 2, 3, 4]).rest()&#x2F;&#x2F;[1,2,3] skip()作用：有一个参数n, 返回截掉前n个元素之后剩下的所有元素用法: 1Immutable.fromJS([1, 2, 3, 4]).skip(1)&#x2F;&#x2F;[2,3,4]\\\\ skipLast()作用：有一个参数n, 返回截掉最后n个元素之后剩下的所有元素用法: 1Immutable.fromJS([1, 2, 3, 4]).skip(1)&#x2F;&#x2F;[1,2,3] skipWhile()作用：返回从第一次返回false之后的所有元素 1Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.skipWhile((value,index,list)&#x3D;&gt;&#123; return value &gt; 2; &#125;))&#x2F;&#x2F; [1,2,3,4] skipUntil() 作用：返回从第一次返回true之后的所有元素 1Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.skipWhile((value,index,list)&#x3D;&gt;&#123; return value &gt; 2; &#125;))&#x2F;&#x2F; [3,4] take()作用：有一个参数n, 返回前n个元素用法： 1Immutable.fromJS([1, 2, 3, 4]).take(2)&#x2F;&#x2F;[1,2] takeLast()作用：有一个参数n, 返回最后n个元素用法： 1Immutable.fromJS([1, 2, 3, 4]).takeLast(2)&#x2F;&#x2F;[3,4] takeWhile()作用：返回从第一次返回false之前的所有元素 1Immutable.fromJS([1, 2, 3, 4]).skipWhile(list.takeWhile((value,index,list)&#x3D;&gt;&#123; return value &gt; 2; &#125;))&#x2F;&#x2F; [] takeUntil()作用：返回从第一次返回true之前的所有元素 1Immutable.fromJS([1, 2, 3, 4]).skipUntil(list.takeUntil((value,index,list)&#x3D;&gt;&#123; return value &gt; 2; &#125;))&#x2F;&#x2F; [1,2] 处理数据 reduce()作用：和js中数组中的reduce相同,按索引升序的顺序处理元素用法： 1Immutable.fromJS([1,2,3,4]).reduce((pre,next,index,arr)&#x3D;&gt;&#123; console.log(pre+next) return pre+next; &#125;) &#x2F;&#x2F; 3 6 10 reduceRight()作用：和js中数组中的reduce相同,按索引降序的顺序处理元素用法： 1Immutable.fromJS([1,2,3,4]).reduceRight((pre,next,index,arr)&#x3D;&gt;&#123; console.log(pre+next) return pre+next; &#125;) &#x2F;&#x2F; 7 9 10 every()作用：判断整个对象总中所有的元素是不是都满足某一个条件，都满足返回true，反之返回false。 代码： 1Immutable.fromJS([1,2,3,4]).every((value,index,arr)&#x3D;&gt;&#123; return value &gt; 2 &#125;) &#x2F;&#x2F; false some()作用：判断整个对象总中所有的元素是不是存在满足某一个条件的元素，若存在返回true，反之返回false。代码： 1Immutable.fromJS([1,2,3,4]).some((value,index,arr)&#x3D;&gt;&#123; return value &gt; 2 &#125;) &#x2F;&#x2F; true join()作用：同js中数组的join方法。把准换为字符串用法： 1Immutable.fromJS([1,2,3,4]).join(&#39;,&#39;) &#x2F;&#x2F;1,2,3,4 isEmpty()作用：判断是否为空用法: 1Immutable.fromJS([]).isEmpty(); &#x2F;&#x2F; true Immutable.fromJS(&#123;&#125;).isEmpty(); &#x2F;&#x2F; true count()作用：返回元素个数，可自定义条件，返回满足条件的个数用法： `const list = Immutable.fromJS([1,2,3,4]); const map = Immutable.fromJS({a:1,b:2,c:3,d:4}); list.count((value,index,list)=&gt;{ return value &gt; 2; }) //2 map.count((value,index,list)=&gt;{ return value &gt; 2; }) //2` countBy()作用：与count不同的是，countBy返回一个对象用法： `const list = Immutable.fromJS([1,2,3,4]); const map = Immutable.fromJS({a:1,b:2,c:3,d:4}); list.countBy((value,index,list)=&gt;{ return value &gt; 2; } //{false: 2, true: 2} map.countBy((value,index,list)=&gt;{ return value &gt; 2; } //{false: 2, true: 2}`","categories":[{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://yzhou15.gitee.io/categories/Immutable-js/"}],"tags":[{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://yzhou15.gitee.io/tags/Immutable-js/"}]},{"title":"30 分钟部署一个 Kubernetes 集群（转载自 - 阿良)","slug":"30 分钟部署一个 Kubernetes 集群（转载自 - 阿良)","date":"2021-08-05T16:59:00.000Z","updated":"2021-08-22T14:00:20.602Z","comments":true,"path":"2021/08/06/30 分钟部署一个 Kubernetes 集群（转载自 - 阿良)/","link":"","permalink":"https://yzhou15.gitee.io/2021/08/06/30%20%E5%88%86%E9%92%9F%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%20Kubernetes%20%E9%9B%86%E7%BE%A4%EF%BC%88%E8%BD%AC%E8%BD%BD%E8%87%AA%20-%20%E9%98%BF%E8%89%AF)/","excerpt":"","text":"kubeadm 是官方社区推出的一个用于快速部署 kubernetes 集群的工具。 这个工具能通过两条指令完成一个 kubernetes 集群的部署： 12345# 创建一个 Master 节点$ kubeadm init# 将一个 Node 节点加入到当前集群中$ kubeadm join &lt;Master节点的IP和端口 &gt; 1. 安装要求在开始之前，部署 Kubernetes 集群机器需要满足以下几个条件： 一台或多台机器，操作系统 CentOS7.x-86_x64 硬件配置：2GB 或更多 RAM，2 个 CPU 或更多 CPU，硬盘 30GB 或更多 集群中所有机器之间网络互通 可以访问外网，需要拉取镜像 禁止 swap 分区 2. 学习目标 在所有节点上安装 Docker 和 kubeadm 部署 Kubernetes Master 部署容器网络插件 部署 Kubernetes Node，将节点加入 Kubernetes 集群中 部署 Dashboard Web 页面，可视化查看 Kubernetes 资源 3. 准备环境 Untitled 1234567891011121314151617181920212223242526272829303132关闭防火墙：$ systemctl stop firewalld$ systemctl disable firewalld关闭selinux：$ sed -i &#39;s&#x2F;enforcing&#x2F;disabled&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config # 永久$ setenforce 0 # 临时关闭swap：$ swapoff -a # 临时$ vim &#x2F;etc&#x2F;fstab # 永久设置主机名：$ hostnamectl set-hostname &lt;hostname&gt;在master添加hosts：$ cat &gt;&gt; &#x2F;etc&#x2F;hosts &lt;&lt; EOF192.168.31.61 k8s-master192.168.31.62 k8s-node1192.168.31.63 k8s-node2EOF将桥接的IPv4流量传递到iptables的链：$ cat &gt; &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables &#x3D; 1net.bridge.bridge-nf-call-iptables &#x3D; 1EOF$ sysctl --system # 生效时间同步：$ yum install ntpdate -y$ ntpdate time.windows.com 4. 所有节点安装 Docker/kubeadm/kubeletKubernetes 默认 CRI（容器运行时）为 Docker，因此先安装 Docker。 4.1 安装 Docker12345678910$ wget &lt;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo&gt; -O &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo$ yum -y install docker-ce-18.06.1.ce-3.el7$ systemctl enable docker &amp;&amp; systemctl start docker$ docker --versionDocker version 18.06.1-ce, build e68fc7a# cat &gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt; EOF&#123; &quot;registry-mirrors&quot;: [&quot;&lt;https:&#x2F;&#x2F;b9pmyelo.mirror.aliyuncs.com&gt;&quot;]&#125;EOF 4.2 添加阿里云 YUM 软件源123456789$ cat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo &lt;&lt; EOF[kubernetes]name&#x3D;Kubernetesbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64enabled&#x3D;1gpgcheck&#x3D;0repo_gpgcheck&#x3D;0gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg &lt;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg&gt;EOF 4.3 安装 kubeadm，kubelet 和 kubectl由于版本更新频繁，这里指定版本号部署： 12$ yum install -y kubelet-1.17.0 kubeadm-1.17.0 kubectl-1.17.0$ systemctl enable kubelet 5. 部署 Kubernetes Master在 192.168.31.61（Master）执行。 123456$ kubeadm init \\\\ --apiserver-advertise-address&#x3D;192.168.31.61 \\\\ --image-repository registry.aliyuncs.com&#x2F;google_containers \\\\ --kubernetes-version v1.17.0 \\\\ --service-cidr&#x3D;10.96.0.0&#x2F;12 \\\\ --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 由于默认拉取镜像地址 k8s.gcr.io 国内无法访问，这里指定阿里云镜像仓库地址。 使用 kubectl 工具： 1234mkdir -p $HOME&#x2F;.kubesudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;configsudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config$ kubectl get nodes 6. 安装 Pod 网络插件（CNI）1$ kubectl apply -f &lt;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml&gt; 确保能够访问到 quay.io 这个 registery。 如果 Pod 镜像下载失败，可以改成这个镜像地址：lizhenliang/flannel:v0.11.0-amd64 7. 加入 Kubernetes Node在 192.168.31.62/63（Node）执行。 向集群添加新节点，执行在 kubeadm init 输出的 kubeadm join 命令： 12$ kubeadm join 192.168.31.61:6443 --token esce21.q6hetwm8si29qxwn \\\\ --discovery-token-ca-cert-hash sha256:00603a05805807501d7181c3d60b478788408cfe6cedefedb1f97569708be9c5 8. 测试 kubernetes 集群在 Kubernetes 集群中创建一个 pod，验证是否正常运行： 123$ kubectl create deployment nginx --image&#x3D;nginx$ kubectl expose deployment nginx --port&#x3D;80 --type&#x3D;NodePort$ kubectl get pod,svc 访问地址：http://NodeIP:Port 9. 部署 Dashboard1$ kubectl apply -f &lt;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;dashboard&#x2F;v2.0.0-beta8&#x2F;aio&#x2F;deploy&#x2F;recommended.yaml&gt; 默认 Dashboard 只能集群内部访问，修改 Service 为 NodePort 类型，暴露到外部： 12345678910111213kind: ServiceapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboardspec: ports: - port: 443 targetPort: 8443 selector: k8s-app: kubernetes-dashboard 访问地址：http://NodeIP:30001 创建 service account 并绑定默认 cluster-admin 管理员集群角色： 123kubectl create serviceaccount dashboard-admin -n kube-systemkubectl create clusterrolebinding dashboard-admin --clusterrole&#x3D;cluster-admin --serviceaccount&#x3D;kube-system:dashboard-adminkubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk &#39;&#x2F;dashboard-admin&#x2F;&#123;print $1&#125;&#39;) 使用输出的 token 登录 Dashboard。","categories":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/categories/CICD/"}],"tags":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://yzhou15.gitee.io/tags/Kubernetes/"}]},{"title":"分布式版本控制系统","slug":"第1天-分布式版本控制系统","date":"2021-08-01T05:23:00.000Z","updated":"2021-08-22T13:10:29.565Z","comments":true,"path":"2021/08/01/第1天-分布式版本控制系统/","link":"","permalink":"https://yzhou15.gitee.io/2021/08/01/%E7%AC%AC1%E5%A4%A9-%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"第1天-分布式版本控制系统一、Git、Github、Gitlab 的区别Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Github是在线的基于Git的代码托管服务。 GitHub是2008年由Ruby on Rails编写而成。GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，只有付费账户可以创建私有的代码仓库。 Gitlab解决了这个问题, 可以在上面创建免费的私人repo。 git 是一套软件 可以做本地私有仓库 github 本身是一个代码托管网站 公有和私有仓库(收费) 不能做本地私有仓库 gitlab 本身也是一个代码托管的网站 功能上和github没有区别 公有和私有仓库（免费） 可以部署本地私有仓库 二、Git 与 SVN 区别GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。 如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。 Git 与 SVN 区别 Git是分布式的，svn不是：这是GIT和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。 GIT把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。 GIT分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。 GIT没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。 GIT的内容完整性要优于SVN：GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 git 是分布式的版本控制器 没有客户端和服务器端的概念 svn 它是C/S结构的版本控制器 有客户端和服务器端 服务器如果宕机而且代码没有备份的情况下 完整代码就会丢失 三、部署Git 服务创建git仓库 git-server上的操作： 1234567891011121314[root@qfedu.com ~]# yum install git git-core gitweb -y[root@qfedu.com ~]# useradd git[root@qfedu.com ~]# passwd git[root@qfedu.com ~]# mkdir &#x2F;git-root&#x2F;[root@qfedu.com ~]# cd &#x2F;git-root&#x2F;[root@qfedu.com git-root]# git init --bare shell.gitInitialized empty Git repository in &#x2F;git-root&#x2F;shell.git&#x2F;注意：git init 和 git init --bare 的区别:使用--bare选项时,不再生成.git目录,而是只生成.git目录下面的版本历史记录文件,这些版本历史记录文件也不再存放在.git目录下面,而是直接存放在版本库的根目录下面.用&quot;git init&quot;初始化的版本库用户也可以在该目录下执行所有git方面的操作。但别的用户在将更新push上来的时候容易出现冲突。使用”git init --bare”方法创建一个所谓的裸仓库，之所以叫裸仓库是因为这个仓库只保存git历史提交的版本信息，而不允许用户在上面进行各种git操作，如果你硬要操作的话，只会得到下面的错误（”This operation must be run in a work tree”）这个就是最好把远端仓库初始化成bare仓库的原因[root@qfedu.com git-root]# chown -R git:git shell.git git仓库测试 git-client上的操作： 1234567891011121314151617181920212223[root@qfedu.com ~]# ssh-keygen[root@qfedu.com ~]# ssh-copy-id git@192.168.1.178[root@qfedu.com shell]# git config --global user.email &quot;you@example.com&quot;[root@qfedu.com shell]# git config --global user.name &quot;Your Name&quot;[root@qfedu.com ~]# git clone git@192.168.1.178:/git-root/shell.git[root@qfedu.com ~]# lsrh shell[root@qfedu.com ~]# cd shell/[root@qfedu.com shell]# vim test.sh[root@qfedu.com shell]# git add test.sh[root@qfedu.com shell]# git commit -m &#x27;first commit&#x27;[master (root-commit) 33c5fbf] first commit 1 file changed, 2 insertions(+) create mode 100644 test1.sh[root@qfedu.com shell]# git push origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 230 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To git@192.168.1.178:/git-root/shell.git * [new branch] master -&gt; master 四、Git工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 Git 的工作流程示意图： 五、Git基本概念 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在”git目录”下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 工作区、版本库中的暂存区和版本库之间的关系的示意图： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 六、Git 客户端安装使用1、 Git 安装配置1234[root@qfedu.com ~]# yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel[root@qfedu.com ~]# yum -y install git git-all git-core[root@qfedu.com ~]# git --versiongit version 2.18.4 2、Git 配置Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。 这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 1、Git 用户信息配置个人的用户名称和电子邮件地址： 12[root@qfedu.com ~]# git config --global user.name &quot;qfedu&quot;[root@qfedu.com ~]# git config --global user.email test@qq.com 如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 2、文本编辑器设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置 1[root@qfedu.com ~]# git config --global core.editor emacs 3、差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： 1[root@qfedu.com ~]# git config --global merge.tool vimdiff Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。 当然，你也可以指定使用自己开发的工具 4、查看配置信息要检查已有的配置信息，可以使用 git config –list 命令： 1234[root@qfedu.com ~]# git config --listhttp.postbuffer=2Muser.name=runoobuser.email=test@runoob.com 有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。 这些配置我们也可以在 ~/.gitconfig 或 /etc/gitconfig 看到，如下所示： 1[root@qfedu.com ~]# vim ~/.gitconfig 显示内容如下所示： 12345[http] postBuffer = 2M[user] name = git email = test@qfedu.com.com 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样： 12[root@qfedu.com ~]# git config user.namegit 3、Git 使用1、ssh 链接客户机上产生公钥上传到gitlab的SSH-Keys里，git clone下载和git push上传都没问题，这种方式很安全 2、http 链接（两种方式实现）1、修改代码里的 .git/config 文件添加登录用户名密码12345678910111213[root@qfedu.com ~]# cd .git[root@qfedu.com ~]# cat config[core]repositoryformatversion = 0filemode = truebare = falselogallrefupdates = true[remote &quot;origin&quot;]fetch = +refs/heads/*:refs/remotes/origin/*url = http://username:password@qfedu.com@172.17.0.39:sauser/ansible.git[branch &quot;master&quot;]remote = originmerge = refs/heads/master 2、 执行命令设置登录用户和密码1234567891011# cd到根目录，执行[root@qfedu.com ~]# git config --global credential.helper store # 执行之后会在.gitconfig文件中多添加以下选项 [credential] helper = store# cd到项目目录，执行git pull命令，会提示输入账号密码。输完这一次以后就不再需要，并且会在根目录生成一个.git-credentials文件[root@qfedu.com ~]# git pull Username for &#x27;http://172.17.0.39:sauser/ansible.git&#x27;: xxxx@xxxx.com Password for &#x27;https://xxxx@xxxx.com@172.17.0.39:sauser/ansible.git&#x27;:[root@qfedu.com ~]# cat .git-credentials https://Username:Password@qfedu.com.oschina.net# 之后pull/push代码都不再需要输入账号密码了 3、设置身份验证注意：设定本机用户名，绑定邮箱，让远程服务器知道机器的身份 12[root@qfedu.com ~]# git config --global user.name &quot;user_name&quot; [root@qfedu.com ~]# git config --global user.email &quot;XXXXX@XX.com&quot; 4、本地项目与远程服务器项目之间的交互1、如果你没有最新的代码，希望从头开始 123456[root@qfedu.com ~]# git clone git@XXX.git # 这里是项目的地址（可从项目主页复制），将远程服务器的内容完全复制过来 [root@qfedu.com ~]# cd BGBInspector_V01 # clone 之后进入该项目的文件夹 [root@qfedu.com ~]# touch README.md # 新建readme文件 [root@qfedu.com ~]# git add README.md # 将新的文件添加到git的暂存区 [root@qfedu.com ~]# git commit -m ‘Its note：add a readme file’ # 将暂存区的文件提交到某一个版本保存下来，并加上注释 [root@qfedu.com ~]# git push -u origin master # 将本地的更改提交到远程服务器 2、如果你已经有一个新版代码，希望直接把本地的代码替换到远程服务器 123456[root@qfedu.com ~]# cd existing_folder #进入代码存在的文件夹，或者直接在该文件夹打开[root@qfedu.com ~]# git init # 初始化 [root@qfedu.com ~]# git remote add origin git@master:/git-test/shell.git #添加远程项目&quot;shell&quot;库的地址（可从项目主页复制） ,前提是事先需要先在git远程服务器上创建相应的裸库&quot;shell&quot;[root@qfedu.com ~]# git add . #添加该文件夹中所有的文件到git的暂存区 [root@qfedu.com ~]# git commit -m ‘note’ #提交所有代码到本机的版本库 [root@qfedu.com ~]# git push -u origin master #将本地的更改提交到远程服务器 git 中 clone过来的时候，git 不会对比本地和服务器的文件，也就不会有冲突， 建议确定完全覆盖本地的时候用 clone，不确定会不会有冲突的时候用 git pull，将远程服务器的代码download下来 git pull=git fetch+git merge 实验如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758本地代码内容如下：[root@node1 shell]# cat mem.sh free -m | awk &#39;NR&#x3D;&#x3D;2&#123;print $4&#125;&#39;echo helloecho ni hao远程Git服务器代码内容如下：[root@node1 shell]# cat mem.sh free -m | awk &#39;NR&#x3D;&#x3D;2&#123;print $4&#125;&#39;echo helloecho ni haoecho ha ha本地机器做fetch操作：[root@node1 shell]# git fetch origin master:testremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5&#x2F;5), done.remote: Compressing objects: 100% (2&#x2F;2), done.remote: Total 3 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (3&#x2F;3), done.From master:&#x2F;git-test&#x2F;shell * [new branch] master -&gt; test b522245..10f9569 master -&gt; origin&#x2F;masterfetch是把远程代码作为本地的一个其他分支下载到本地，并不更新本地分支，这里的命令是把远程的”master“分支下载到本地作为一个新的分支”test“存在查看本地文件并没有发生变化[root@node1 shell]# ls mem.sh[root@node1 shell]# cat mem.sh free -m | awk &#39;NR&#x3D;&#x3D;2&#123;print $4&#125;&#39;echo helloecho ni hao用diff查看本地master分支和fetch下来的test分支有什么区别：[root@node1 shell]# git diff master testdiff --git a&#x2F;mem.sh b&#x2F;mem.shindex 7ce0803..c0c8cef 100644--- a&#x2F;mem.sh+++ b&#x2F;mem.sh@@ -1,3 +1,4 @@ free -m | awk &#39;NR&#x3D;&#x3D;2&#123;print $4&#125;&#39; echo hello echo ni hao+echo ha ha如果发现fetch下来的代码没什么问题，可以选择和本地分支进行合并[root@node1 shell]# git merge Updating eb8645c..10f9569Fast-forward mem.sh | 1 + 1 file changed, 1 insertion(+)[root@node1 shell]# cat mem.sh free -m | awk &#39;NR&#x3D;&#x3D;2&#123;print $4&#125;&#39;echo helloecho ni haoecho ha ha 5、常用的git 命令 12345678910111213[root@qfedu.com ~]# git init # 初始化 [root@qfedu.com ~]# git add main.cpp # 将某一个文件添加到暂存区 [root@qfedu.com ~]# git add . # 将文件夹下的所有的文件添加到暂存区 [root@qfedu.com ~]# git commit -m ‘note‘ # 将暂存区中的文件保存成为某一个版本 [root@qfedu.com ~]# git log # 查看所有的版本日志 [root@qfedu.com ~]# git status # 查看现在暂存区的状况 [root@qfedu.com ~]# git diff # 查看现在文件与上一个提交-commit版本的区别 [root@qfedu.com ~]# git reset --hard HEAD^ # 回到上一个版本 [root@qfedu.com ~]# git reset --hard XXXXX # XXX为版本编号，回到某一个版本 [root@qfedu.com ~]# git pull origin master # 从主分支pull到本地 [root@qfedu.com ~]# git push -u origin master # 从本地push到主分支 [root@qfedu.com ~]# git pull # pull默认主分支 [root@qfedu.com ~]# git push # push默认主分支 ... 6、版本穿梭1、版本回退1234# 用 git log 命令查看：# 每一个提交的版本都唯一对应一个 commit 版本号，# 使用 git reset 命令退到上一个版本：[root@qfedu.com ~]# git reset --hard HEAD^ 12[root@qfedu.com ~]# git reflog # 查看命令历史，以便确定要回到哪个版本[root@qfedu.com ~]# git reset --hard commit_id # 比如git reset --hard 3628164（不用全部输入，输入前几位即可） 2、分支管理1、创建分支 1234567[root@qfedu.com ~]# git checkout -b dev #创建dev分支，然后切换到dev分支[root@qfedu.com ~]# git checkout #命令加上-b参数表示创建并切换，相当于以下两条命令：[root@qfedu.com ~]# git branch dev git checkout dev[root@qfedu.com ~]# git branch #命令查看当前分支,[root@qfedu.com ~]# git branch #命令会列出所有分支，当前分支前面会标一个*号[root@qfedu.com ~]# git branch * dev master[root@qfedu.com ~]# git add readme.txt git commit -m &quot;branch test&quot; # 在dev分支上正常提交. 2、分支切换 12[root@qfedu.com ~]# git checkout master #切换回master分支# 查看一个readme.txt文件，刚才添加的内容不见了，因为那个提交是在dev分支上，而master分支此刻的提交点并没有变 3、合并分支 123[root@qfedu.com ~]# git merge dev #把dev分支的工作成果合并到master分支上[root@qfedu.com ~]# git merge #命令用于合并指定分支到当前分支。# 合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 12注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 12[root@qfedu.com ~]# git branch -d dev #删除dev分支了：删除后，查看branch，就只剩下master分支了. 3、解决冲突1234567891011121314151617181920[root@qfedu.com ~]# git checkout -b feature1 # 创建新的feature1分支# 修改readme.txt最后一行，改为：Creating a new branch is quick AND simple.[root@qfedu.com ~]# git add readme.txt # 在feature1分支上提交[root@qfedu.com ~]# git commit -m &quot;AND simple&quot;[root@qfedu.com ~]# git checkout master #切换到master分支Switched to branch &#x27;master&#x27; Your branch is ahead of &#x27;origin/master&#x27; by 1 commit.Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。在master分支上把readme.txt文件的最后一行改为：Creating a new branch is quick &amp; simple.[root@qfedu.com ~]# git add readme.txt [root@qfedu.com ~]# git commit -m &quot;&amp; simple&quot;现在，master分支和feature1分支各自都分别有新的提交这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 123456789101112131415readme.txt文件存在冲突，必须手动解决冲突后再提交。[root@qfedu.com ~]# git status 可以显示冲突的文件;直接查看readme.txt的内容：Git is a distributed version control system.Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Creating a new branch is quick &amp; simple. ======= Creating a new branch is quick AND simple. &gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改后保存再提交：[root@qfedu.com ~]# git add readme.txt [root@qfedu.com ~]# git commit -m &quot;conflict fixed&quot; [master 59bc1cb] conflict fixed最后，删除feature1分支：[root@qfedu.com ~]# git branch -d feature1 Deleted branch feature1 (was 75a857c). 七、Github 远程仓库1、github.com 注册账户 2、github 上创建仓库 3、本地服务器生成 ssh 公钥 123[root@qfedu.com ~]# ssh-keygen -t rsa -C &#x27;meteor@163.com&#x27; # 邮箱要与github上注册的相同[root@qfedu.com ~]# cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDVThfq4brrlsPGtAknVB0TLPx+7Dd3qlxTbSIrUOsGC5Y8JuNqVTlIntZB4oNj8cSQrWvec9CKm0a8o7WwaJIiqpxurz+YpQHP2KbapftKIxsX4hPf/z+p0El1U6arQa35/xmNsq+cJLH/bDdRG+EMDhuCBmjVZOlLj/hEdeIT6s56AnnCkaWoF+sq58KCF7Tk54jRbs/YiyE4SN7FuA70r+07sA/uj0+lmuk4E190KtQUELhjX/E9stivlqiRhxnKvVUqXDywsjfM8Rtvbi4Fg9R8Wt9fpd4QwnWksYUoR5qZJFYXO4hSZrUnSMruPK14xXjDJcFDcP2eHIzKgLD1 meteor@163.com 4、 github 添加 ssh 公钥 复制以上的公钥，在 github 中添加ssh key 5、测试连接 12345678910[root@qfedu.com ~]# yum install git........[root@qfedu.com ~]# ssh -T git@qfedu.comhub.comThe authenticity of host &#x27;github.com (13.250.177.223)&#x27; can&#x27;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.RSA key fingerprint is MD5:16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;github.com,13.250.177.223&#x27; (RSA) to the list of known hosts.Hi meteor! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.[root@qfedu.com ~]# 6、连接远程仓库（创建一个测试存储库） 12345678910111213141516171819202122232425262728293031# 在 github 网站新建一个仓库，命名为linux~~~[root@qfedu.com ~]# cd /opt[root@qfedu.com ~]# mkdir linux[root@qfedu.com ~]# mkdir linux[root@qfedu.com ~]# cd linux~~~# git 初始化，然后做第一个基本的git操作(需要在github上创建存储库)[root@qfedu.com ~]# git init[root@qfedu.com ~]# touch README[root@qfedu.com ~]# git add README[root@qfedu.com ~]# git commit -m &#x27;first commit&#x27;[root@qfedu.com ~]# git remote add origin git@qfedu.comhub.com:userhub/linux.git~~~# 若出现origin已经存在的错误，删除origin[root@qfedu.com linux]# git remote rm origin# 现在继续执行push到远端~~~[root@qfedu.com linux]# git remote add origin git@qfedu.comhub.com:userhub/linux.git[root@qfedu.com linux]# git push -u origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 205 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To git@qfedu.comhub.com:fakehydra/linux-.git * [new branch] master -&gt; master分支 master 设置为跟踪来自 origin 的远程分支 master。# 注意# 设置存储库链接[root@qfedu.com ~]# git remote set-url origin git@qfedu.comhub.com:userhub/linux.git# 如果 push 失败，合并分支到 master 再 push[root@qfedu.com ~]# git pull --rebase origin master 八、Gitlab Server 部署1、环境配置关闭防火墙、SELinux 开启邮件服务 12[root@qfedu.com ~]# systemctl start postfix[root@qfedu.com ~]# systemctl enable postfix 2、部署 Gitlab1、安装 gitlab 依赖包123456centos7:[root@qfedu.com ~]# yum install -y curl openssh-server openssh-clients postfix cronie policycoreutils-python# gitlab-ce 10.x.x以后的版本需要依赖policycoreutils-pythoncentos8:[root@qfedu.com ~]# yum install -y curl openssh-server openssh-clients postfix cronie policycoreutils-python-utils 2、添加官方源1[root@qfedu.com ~]# curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash 因为官方源太慢，可以使用国内清华yum源，配置如下 123456[root@qfedu.com ~]# vim /etc/yum.repos.d/gitlab-ce.repo[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1 3、安装 Gitlab12[root@qfedu.com ~]# yum -y install gitlab-ce # 自动安装最新版[root@qfedu.com ~]# yum -y install gitlab-ce-x.x.x # 安装指定版本Gitlab 4、配置 Gitlab1、查看Gitlab版本12[root@qfedu.com ~]# head -1 /opt/gitlab/version-manifest.txtgitlab-ce 10.1.1 2、Gitlab 配置登录链接123456789101112#设置登录链接[root@qfedu.com ~]# vim /etc/gitlab/gitlab.rb***## GitLab URL##! URL on which GitLab will be reachable.##! For more details on configuring external_url see:##! https://docs.gitlab.com/omnibus/settings/configuration.html#configuring-the-external-url-for-gitlab# 没有域名，可以设置为本机IP地址external_url &#x27;http://172.17.0.61&#x27;***[root@qfedu.com ~]# grep &quot;^external_url&quot; /etc/gitlab/gitlab.rbexternal_url &#x27;http://172.17.0.61&#x27; #绑定监听的域名或IP 3、初始化 Gitlab配置语言环境 gitlab要求语言环境为英文环境，必须切换，切换方法如下： 123456789101112131415注意：可以先尝试以下方案 语言环境问题：如果碰到之后的解决方案如下，需要重新登录 [root@wing ~]# echo &quot;export LC_ALL&#x3D;en_US.UTF-8&quot; &gt;&gt; &#x2F;etc&#x2F;profile 如果上面的方案不可以，再使用下面的方案： # yum install langpacks-zh_CN langpacks-en langpacks-en_GB -y# cat &gt; &#x2F;etc&#x2F;profile.d&#x2F;locale.sh&lt;&lt;-EOF export LANG&#x3D;en_US.UTF-8 export LANGUAGE&#x3D;en_US.UTF-8 export LC_COLLATE&#x3D;C export LC_CTYPE&#x3D;en_US.UTF-8 EOF# source &#x2F;etc&#x2F;profile.d&#x2F;locale.sh退出终端重新登陆 第一次使用配置时间较长 12[root@qfedu.com ~]# gitlab-ctl reconfigure ..... 4、启动 Gitlab 服务12345678910111213141516171819[root@qfedu.com ~]# gitlab-ctl startok: run: gitaly: (pid 22896) 2922sok: run: gitlab-monitor: (pid 22914) 2921sok: run: gitlab-workhorse: (pid 22882) 2922sok: run: logrotate: (pid 22517) 2987sok: run: nginx: (pid 22500) 2993sok: run: node-exporter: (pid 22584) 2974sok: run: postgres-exporter: (pid 22946) 2919sok: run: postgresql: (pid 22250) 3047sok: run: prometheus: (pid 22931) 2920sok: run: redis: (pid 22190) 3053sok: run: redis-exporter: (pid 22732) 2962sok: run: sidekiq: (pid 22472) 3005sok: run: unicorn: (pid 22433) 3011s[git@qfedu.com ~]# lsof -i:80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 22500 root 7u IPv4 50923 0t0 TCP *:http (LISTEN)nginx 22501 gitlab-www 7u IPv4 50923 0t0 TCP *:http (LISTEN) 5、Gitlab 设置 HTTPS 方式 （缺少配置） 如果想要以上的 https 方式正常生效使用，则需要把 letsencrypt 自动生成证书的配置打开，这样在执行重新让配置生效命令 (gitlab-ctl reconfigure) 的时候会自动给域名生成免费的证书并自动在 gitlab 自带的 nginx 中加上相关的跳转配置，都是全自动的，非常方便。 123[root@qfedu.com ~]# vim /etc/gitlab/gitlab.rbletsencrypt[&#x27;enable&#x27;] = true //如果因为这行报错，改成false即可letsencrypt[&#x27;contact_emails&#x27;] = [&#x27;276267003@qq.com&#x27;] # 添加联系人的电子邮件地址 6、Gitlab 添加smtp邮件功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[git@qfedu.com ~]# vim /etc/gitlab/gitlab.rbpostfix 并非必须的；根据具体情况配置，以 SMTP 的为例配置邮件服务器来实现通知；参考配置如下： ### Email Settingsgitlab_rails[&#x27;gitlab_email_enabled&#x27;] = truegitlab_rails[&#x27;gitlab_email_from&#x27;] = &#x27;276267003@qq.com&#x27;gitlab_rails[&#x27;gitlab_email_display_name&#x27;] = &#x27;gitlab&#x27;gitlab_rails[&#x27;gitlab_email_reply_to&#x27;] = &#x27;276267003@qq.com&#x27;gitlab_rails[&#x27;gitlab_email_subject_suffix&#x27;] = &#x27;[gitlab]&#x27;gitlab_rails[&#x27;smtp_enable&#x27;] = truegitlab_rails[&#x27;smtp_address&#x27;] = &quot;smtp.qq.com&quot;gitlab_rails[&#x27;smtp_port&#x27;] = 465gitlab_rails[&#x27;smtp_user_name&#x27;] = &quot;276267003@qq.com&quot;gitlab_rails[&#x27;smtp_password&#x27;] = &quot;kktohrvdryglbjjh&quot; #这是我的qq邮箱授权码gitlab_rails[&#x27;smtp_domain&#x27;] = &quot;smtp.qq.com&quot;gitlab_rails[&#x27;smtp_authentication&#x27;] = &quot;login&quot;gitlab_rails[&#x27;smtp_enable_starttls_auto&#x27;] = truegitlab_rails[&#x27;smtp_tls&#x27;] = true#修改配置后需要初始化配置，先关掉服务再重新初始化[git@qfedu.com ~]# gitlab-ctl stopok: down: gitaly: 0s, normally upok: down: gitlab-monitor: 1s, normally upok: down: gitlab-workhorse: 0s, normally upok: down: logrotate: 1s, normally upok: down: nginx: 0s, normally upok: down: node-exporter: 1s, normally upok: down: postgres-exporter: 0s, normally upok: down: postgresql: 0s, normally upok: down: prometheus: 0s, normally upok: down: redis: 0s, normally upok: down: redis-exporter: 1s, normally upok: down: sidekiq: 0s, normally upok: down: unicorn: 1s, normally up[git@qfedu.com ~]# gitlab-ctl reconfigure ......[git@qfedu.com ~]# gitlab-ctl startok: run: gitaly: (pid 37603) 0sok: run: gitlab-monitor: (pid 37613) 0sok: run: gitlab-workhorse: (pid 37625) 0sok: run: logrotate: (pid 37631) 0sok: run: nginx: (pid 37639) 1sok: run: node-exporter: (pid 37644) 0sok: run: postgres-exporter: (pid 37648) 1sok: run: postgresql: (pid 37652) 0sok: run: prometheus: (pid 37660) 1sok: run: redis: (pid 37668) 0sok: run: redis-exporter: (pid 37746) 0sok: run: sidekiq: (pid 37750) 1sok: run: unicorn: (pid 37757) 0s 7、Gitlab 发送邮件测试12345678910111213141516171819202122232425262728293031[git@qfedu.com ~]# gitlab-rails console [root@wing ~]# gitlab-rails console--------------------------------------------------------------------- GitLab: 12.10.1 (e658772bd63) FOSS GitLab Shell: 12.2.0 PostgreSQL: 11.7---------------------------------------------------------------------Loading production environment (Rails 6.0.2)irb(main):003:0&gt; irb(main):004:0&gt; Notify.test_email(&#x27;276267003@qq.com&#x27;, &#x27;Message Subject&#x27;, &#x27;Message Body&#x27;).deliver_now //输入测试命令，回车Notify#test_email: processed outbound mail in 5.2msDelivered mail 5eafceaa250a_1d063fb777add9a08601a@wing.mail (1430.1ms)Date: Mon, 04 May 2020 16:13:30 +0800From: gitlab &lt;276267003@qq.com&gt;Reply-To: gitlab &lt;276267003@qq.com&gt;To: 276267003@qq.comMessage-ID: &lt;5eafceaa250a_1d063fb777add9a08601a@wing.mail&gt;Subject: Message SubjectMime-Version: 1.0Content-Type: text/html; charset=UTF-8Content-Transfer-Encoding: 7bitAuto-Submitted: auto-generatedX-Auto-Response-Suppress: All&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/REC-html40/loose.dtd&quot;&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Message Body&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;=&gt; #&lt;Mail::Message:70056859616080, Multipart: false, Headers: &lt;Date: Mon, 04 May 2020 16:13:30 +0800&gt;, &lt;From: gitlab &lt;276267003@qq.com&gt;&gt;, &lt;Reply-To: gitlab &lt;276267003@qq.com&gt;&gt;, &lt;To: 276267003@qq.com&gt;, &lt;Message-ID: &lt;5eafceaa250a_1d063fb777add9a08601a@wing.mail&gt;&gt;, &lt;Subject: Message Subject&gt;, &lt;Mime-Version: 1.0&gt;, &lt;Content-Type: text/html; charset=UTF-8&gt;, &lt;Content-Transfer-Encoding: 7bit&gt;, &lt;Auto-Submitted: auto-generated&gt;, &lt;X-Auto-Response-Suppress: All&gt;&gt;irb(main):005:0&gt; 去qq邮箱web界面查看是否收到邮件 3、Gitlab 的使用在浏览器中输入 http://192.168.1.178/ ，然后 change password: ，并使用root用户登录 即可 (后续动作根据提示操作) 1、Gitlab 命令行修改密码12345[root@qfedu.com ~]# gitlab-rails console productionirb(main):001:0&gt;user = User.where(id: 1).first # id为1的是超级管理员irb(main):002:0&gt;user.password = &#x27;yourpassword&#x27; # 密码必须至少8个字符irb(main):003:0&gt;user.save! # 如没有问题 返回trueexit # 退出 2、Gitlab服务管理1234567[root@qfedu.com ~]# gitlab-ctl start # 启动所有 gitlab 组件；[root@qfedu.com ~]# gitlab-ctl stop # 停止所有 gitlab 组件；[root@qfedu.com ~]# gitlab-ctl restart # 重启所有 gitlab 组件；[root@qfedu.com ~]# gitlab-ctl status # 查看服务状态；[root@qfedu.com ~]# gitlab-ctl reconfigure # 初始化服务；[root@qfedu.com ~]# vim /etc/gitlab/gitlab.rb # 修改默认的配置文件；[root@qfedu.com ~]# gitlab-ctl tail # 查看日志； 3、登陆 Gitlab 如果需要手工修改nginx的port ，可以在gitlab.rb中设置 nginx[‘listen_port’] = 8000 ，然后再次 gitlab-ctl reconfigure即可 登录 gitlab 如下所示(首次登陆设置 root 密码)： 4、创建项目组 group组名为plat-sp , 5、去掉用户的自动注册功能（安全）admin are -&gt; settings -&gt; Sign-up Restrictions 去掉钩钩，然后拉到最下面保存，重新登录 九、Gitlab 开发代码提交处理流程1、公司代码提交合并流程 PM（项目主管/项目经理）在gitlab创建任务，分配给开发人员 开发人员领取任务后，在本地使用git clone拉取代码库 开发人员创建开发分支（git checkout -b dev），并进行开发 开发人员完成之后，提交到本地仓库（git commit ） 开发人员在gitlab界面上申请分支合并请求（Merge request） PM在gitlab上查看提交和代码修改情况，确认无误后，确认将开发人员的分支合并到主分支（master） 开发人员在gitlab上Mark done确认开发完成，并关闭issue。这一步在提交合并请求时可以通过描述中填写”close #1”等字样，可以直接关闭issue 2、创建项目管理用户 Tompson同样的方法，再创建 Eric 、Hellen 用户。用户添加完毕后，gitlab 会给用户发一封修改密码的邮件，各用户需要登录自己的邮箱，并点击相关的链接，设置新密码。 3、将 Tompson 用户添加到组中，指定T为本组的 owner 4、同样的方法将用户Eric、Hellen 添加到组中，并指定为Developer 5、使用 Tompson 用户的身份与密码登录到 gitlab 界面中，并创建项目 Project 6、指定项目的存储路径和项目名称 把客户端的公钥添加到这里之后才会出现下图的内容 7、为项目创建 Dev分支注意：因为版本的原因，需要先在项目里面添加一个文件，才能显示下图中创建分支的操作 8、在 client 上添加 Tompson 的用户1234567891011121314151617181920212223242526272829[git@qfedu.com ~]# useradd Tompson[git@qfedu.com ~]# useradd Hellen[git@qfedu.com ~]# useradd Eric[git@qfedu.com ~]# useradd test[git@qfedu.com ~]# su - Tompson[Tompson@qfedu.com ~]$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/Tompson/.ssh/id_rsa): Created directory &#x27;/home/Tompson/.ssh&#x27;.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/Tompson/.ssh/id_rsa.Your public key has been saved in /home/Tompson/.ssh/id_rsa.pub.The key fingerprint is:SHA256:SAoAH2zSxqEJqVgKKrxM5XMi6tKe61JMRdwMhwBNIrE Tompson@domain.cnThe key&#x27;s randomart image is:+---[RSA 2048]----+|XX==o=. ||*BOo+.o ||E*=. . ||*+.= + . ||=oo = . S ||.oo ||.o ||o... ||.+=. |+----[SHA256]-----+[Tompson@qfedu.com ~]$ cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDZ8cRGHej+sZzlmK36W5MUXMLOGdTwFI9Jj44mGuabZCrlYW4GDpL6ppezN+Sur0wHtnKonYJzm8ntqS0S0UHyaPPQPl9Mrs/6Z4VrXZ/4RlqHdWeSrmOwCBQld0l8HvrmP4TyGHrOreO8uZqimd/Z+OiMqnYRZzENX11Pti/Px5g1MtJcoCi9uLtF42QYrt1X/fzAyPU9C5/5ZUq4Jln3EF20bzcA52oAzZIl0jrhI0TeTeW6zYq+KxdHGshL+qG7+Ne+akPOe4Ma5BQjcMZ2dQ2kbGuozXmLT8RDcj9YRKceQsUdTI71lJpwrWKGn8Vhra0EaK3hgoTuvMYaGfOF Tompson@domain.cn 9、将 Tompson 的公钥复制到 gitlab 中使用 Tompson 用户的身份与密码登录到 gitlab界面中，然后在 ssh-key 中添加相关的key 10、为 Tompson 用户配置 git123456789101112131415161718[Tompson@qfedu.com ~]$ git config --global user.email &quot;222@qq.com&quot;[Tompson@qfedu.com ~]$ git config --global user.name &quot;tom&quot;[Tompson@qfedu.com ~]$ git clone git@192.168.60.119:plat-sp/chathall.gitCloning into &#x27;chathall&#x27;...The authenticity of host &#x27;192.168.60.119 (192.168.60.119)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:CDxAQmj6gUkIxB6XUofbZ853GuPM5LS2QO4a5dD7jRo.ECDSA key fingerprint is MD5:4e:20:72:a7:46:c6:d7:5d:bb:9d:ce:c3:f3:da:43:f9.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;192.168.60.119&#x27; (ECDSA) to the list of known hosts.remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0)Receiving objects: 100% (3/3), done.[Tompson@qfedu.com ~]$ [Tompson@qfedu.com ~]$ cd chathall/[Tompson@qfedu.com chathall]$ lsReadme.txt[Tompson@qfedu.com chathall]$ 11、创建新文件，添加内容，并提交到 master 分支12345678910111213141516171819[Tompson@qfedu.com chathall]$ vim test.sh[Tompson@qfedu.com chathall]$ cat test.sh #!/bin/bashecho &quot;gitlab test&quot;[Tompson@qfedu.com chathall]$ git add . [Tompson@qfedu.com chathall]$ git commit -m &#x27;201805101649&#x27;[master 80edf6b] 201805101649 1 file changed, 2 insertions(+) create mode 100644 test.sh[Tompson@qfedu.com chathall]$ [Tompson@qfedu.com chathall]$ git push -u origin master Counting objects: 4, done.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 305 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To git@192.168.60.119:plat-sp/chathall.git 4611654..80edf6b master -&gt; masterBranch master set up to track remote branch master from origin.[Tompson@qfedu.com chathall]$ 12、使用 Eric 用户登录，并 clone 项目123456789101112131415161718192021222324252627[git@qfedu.com ~]# su - Eric[Eric@qfedu.com ~]$ ssh-keygen -C Eric@domain.cnGenerating public/private rsa key pair.Enter file in which to save the key (/home/Eric/.ssh/id_rsa): Created directory &#x27;/home/Eric/.ssh&#x27;.Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/Eric/.ssh/id_rsa.Your public key has been saved in /home/Eric/.ssh/id_rsa.pub.The key fingerprint is:SHA256:VZaJvjA5SJZEB+yuRpDBNHCECCZ5R8X0DYcNE0f1B6E Eric@domain.cnThe key&#x27;s randomart image is:+---[RSA 2048]----+|*O=..B*o**+o+oo. ||*.+.. *o.*oooo . || . + + ..oo E . .|| o o =.. . || . . S+ . || . . . || . . || o || . |+----[SHA256]-----+[Eric@qfedu.com ~]$ cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDxQcn4UjRW/5PT5witeV9+S2w8WK5ouawHxEF7s9wuWsT4pqhcu5BN74NG3CPaq1jJZnkV+aQsTw+60BAd1gOK0FBbKWxmohmE61n9vfpUT5igJ72t2jpXjfKwLIHw+Iq5yM4yUhkwSsoBuZkxYSEltnj8OvXaOlCDYnXuGBa9+xO8f5yVIcOtiwRvv+Y1PRRzSIcazPVZax9FLK26t1R4NPiY4xWkIJyK2OrKMeiaBBzyMfWzHdmsCWa51oSrYSmz3PDBXpzIBs3OdKxcaJs9Lc5u87YCV5RMUjLrPcA7nPK6crOabLXhz3d5GSYggMTOByQkyKOo7WlYpARCHOt/ Eric@domain.cn[Eric@qfedu.com ~]$ 13、同样需要使用Eric用户登录gitlab web 界面，并添加相应的ssh-key。然后设置git ，并clone项目12345678910111213[Eric@qfedu.com ~]$ git config --global user.email &quot;Eric@domain.cn&quot;[Eric@qfedu.com ~]$ git config --global user.name &quot;Eric&quot;[Eric@qfedu.com ~]$ git clone git@192.168.60.119:plat-sp/chathall.gitCloning into &#x27;chathall&#x27;...The authenticity of host &#x27;192.168.60.119 (192.168.60.119)&#x27; can&#x27;t be established.ECDSA key fingerprint is SHA256:CDxAQmj6gUkIxB6XUofbZ853GuPM5LS2QO4a5dD7jRo.ECDSA key fingerprint is MD5:4e:20:72:a7:46:c6:d7:5d:bb:9d:ce:c3:f3:da:43:f9.Are you sure you want to continue connecting (yes/no)? yesremote: Counting objects: 6, done.remote: Compressing objects: 100% (3/3), done.remote: Total 6 (delta 0), reused 0 (delta 0)Receiving objects: 100% (6/6), done.[Eric@qfedu.com ~]$ 14、切换到dev分支，修改文件内容，并将新 code 提交到 dev分支 (Developer角色默认并没有提交master的权限)1234567891011121314151617181920212223242526272829303132[Eric@qfedu.com chathall]$ git checkout dev Branch dev set up to track remote branch dev from origin.Switched to a new branch &#x27;dev&#x27;[Eric@qfedu.com chathall]$ lsReadme.txt test.sh[Eric@qfedu.com chathall]$ vim eric.sh [Eric@qfedu.com chathall]$ cat eric.sh#!/bin/bashecho &quot;brahch test&quot;[Eric@qfedu.com chathall]$ git add . [Eric@qfedu.com chathall]$ git commit -m &#x27;201805101658&#x27;[dev 6687039] 201805101658 1 file changed, 1 insertion(+)[Eric@qfedu.com chathall]$ git push -u origin dev Counting objects: 5, done.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 306 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)remote: remote: To create a merge request for dev, visit:remote: http://192.168.60.119/plat-sp/chathall/merge_requests/new?merge_request%5Bsource_branch%5D=devremote: To git@192.168.60.119:plat-sp/chathall.git 80edf6b..6687039 dev -&gt; devBranch dev set up to track remote branch dev from origin.[Eric@qfedu.com chathall]$[Eric@qfedu.com chathall]$ git checkout master Switched to branch &#x27;master&#x27;[Eric@qfedu.com chathall]$ git branch dev* master[Eric@qfedu.com chathall]$ 15、使用Eric 用户登录gitlab web，在界面中 创建一个合并请求 提交合并请求： 16、使用Tompson用户登录 gitlab web ，找到“合并请求” ，然后将dev分支合并到master分支 十、Gitlab 备份与恢复1、查看系统版本和软件版本12345[root@qfedu.com gitlab]# cat /etc/redhat-release CentOS Linux release 7.3.1611 (Core) [root@qfedu.com gitlab]# cat /opt/gitlab/embedded/service/gitlab-rails/VERSION8.15.4 2、数据备份1、查看备份相关的配置项123[root@qfedu.com ~]# vim /etc/gitlab/gitlab.rbgitlab_rails[&#x27;manage_backup_path&#x27;] = truegitlab_rails[&#x27;backup_path&#x27;] = &quot;/data/gitlab/backups&quot; 该项定义了默认备份出文件的路径，可以通过修改该配置，并执行 gitlab-ctl reconfigure 或者 gitlab-ctl restart 重启服务生效。 2、执行备份命令进行备份1[root@qfedu.com ~]# /opt/gitlab/bin/gitlab-rake gitlab:backup:create 3、添加到 crontab 中定时执行12[root@qfedu.com ~]# crontab -e0 2 * * * bash /opt/gitlab/bin/gitlab-rake gitlab:backup:create 可以到/data/gitlab/backups找到备份包，解压查看，会发现备份的还是比较全面的，数据库、repositories、build、upload等分类还是比较清晰的。 4、设置备份保留时长防止每天执行备份，有目录被爆满的风险，打开/etc/gitlab/gitlab.rb配置文件，找到如下配置： 12[root@qfedu.com ~]# vim /etc/gitlab/gitlab.rbgitlab_rails[&#x27;backup_keep_time&#x27;] = 604800 设置备份保留7天（7360024=604800），秒为单位，如果想增大或减小，可以直接在该处配置，并通过gitlab-ctl restart 重启服务生效。 备份完成，会在备份目录中生成一个当天日期的tar包。 3、数据恢复1、安装部署 gitlab server 具体步骤参见上面：gitlab server 搭建过程 2、恢复 gitlab1、查看备份相关的配置项12[root@qfedu.com ~]# vim /etc/gitlab/gitlab.rbgitlab_rails[&#x27;backup_path&#x27;] = &quot;/data/gitlab/backups&quot; 修改该配置，定义了默认备份出文件的路径，并执行 gitlab-ctl reconfigure 或者 gitlab-ctl restart 重启服务生效。 2、恢复前需要先停掉数据连接服务12[root@qfedu.com ~]# gitlab-ctl stop unicorn[root@qfedu.com ~]# gitlab-ctl stop sidekiq 如果是台新搭建的主机，不需要操作，理论上不停这两个服务也可以。停这两个服务是为了保证数据一致性。 3、同步备份文件到新服务器将老服务器/data/gitlab/backups目录下的备份文件拷贝到新服务器上的/data/gitlab/backups 1[root@qfedu.com gitlab]# rsync -avz 1530773117_2019_03_05_gitlab_backup.tar 192.168.95.135:/data/gitlab/backups/ 注意权限：600权限是无权恢复的。 实验环境可改成了777，生产环境建议修改属主属组 123456[root@qfedu.com backups]# pwd/data/gitlab/backups[root@qfedu.com backups]# chown -R git.git 1530773117_2019_03_05_gitlab_backup.tar [root@qfedu.com backups]# lltotal 17328900-rwxrwxrwx 1 git git 17744793600 Jul 5 14:47 1530773117_2018_07_05_gitlab_backup.tar 4、执行命令进行恢复后面再输入两次 yes 就完成恢复了。 12[root@qfedu.com ~]# gitlab-rake gitlab:backup:restore BACKUP=1530773117_2018_07_05_gitlab_backup.tar注意：backups 目录下保留一个备份文件可直接执行 5、恢复完成启动服务恢复完成后，启动刚刚的两个服务，或者重启所有服务，再打开浏览器进行访问，发现数据和之前的一致： 1234[root@qfedu.com ~]# gitlab-ctl start unicorn[root@qfedu.com ~]# gitlab-ctl start sidekiq或[root@qfedu.com ~]# gitlab-ctl restart 注意：通过备份文件恢复gitlab必须保证两台主机的gitlab版本一致，否则会提示版本不匹配 十一、利用Gitlab管理k8s集群1、权限设置 2、获取k8s集群API地址12[root@master ~]# kubectl cluster-info | grep &#x27;Kubernetes master&#x27; | awk &#x27;/http/ &#123;print $NF&#125;&#x27;https://192.168.19.200:6443 3、获取k8s集群默认CA证书123[root@master ~]# kubectl get secretsNAME TYPE DATA AGEdefault-token-cvfqx kubernetes.io&#x2F;service-account-token 3 3d21h default-token-cvfqx 为上面获取到的secrets的名称，用以下命令查看证书 123456789101112131415161718[root@master ~]# kubectl get secret default-token-cvfqx -o jsonpath&#x3D;&quot;&#123;[&#39;data&#39;][&#39;ca\\.crt&#39;]&#125;&quot; | base64 --decode-----BEGIN CERTIFICATE-----MIICyDCCAbCgAwIBAgIBADANBgkqhkiG9w0BAQsFADAVMRMwEQYDVQQDEwprdWJlcm5ldGVzMB4XDTIwMDgxNzA5MjAwMFoXDTMwMDgxNTA5MjAwMFowFTETMBEGA1UEAxMKa3ViZXJuZXRlczCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANIMiOGHeolaxkE+kqZtc8kDbGFhwqGxNxg4orbIjrz&#x2F;&#x2F;Z6vrgqo2COn2NjKrVM11bmzVhHPCruc3snfTLIS+&#x2F;Z6gZqgpw5ruX8OjfH4nhr9npKxdBon3soa10EovPwMz1KWlaqbuLKTbtTm+oCtAKYXUlzqrFGR&#x2F;&#x2F;GW2D3bjl1QGOPbAR0pggdxSpPo6oUgtEQJQAsNOJ40qMjevi3fnrNDrMqmcNKlSlkw8+Gf4TqM1EfAERRHiEcb&#x2F;W3hOGWV0gdmvaq7CE&#x2F;ENeD1O11NE76BMmk5WO0u6ot4OmP35TTlx8K0N&#x2F;WPyq76RlH7somiIb8S1NpAzg+9K0vv1QmILScCAwEAAaMjMCEwDgYDVR0PAQH&#x2F;BAQDAgKkMA8GA1UdEwEB&#x2F;wQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAEVgIlTFDoFhb3KA0RMVjckgsP3OOB7vTEws6w9ZDGJsNlbbCa15f8q3VmERSkfjAhfG4I9gb4KI0CM5Xt3JhU76GWsOZXHDfK7AzDGpLPUxlygkK7c7XCES&#x2F;GEJe5agBxQyCo2pAvcj&#x2F;nb+JIBeSh8JcG05pzPhL11it9hDqmS5k92+63xGs&#x2F;SDEzXEbBVMnyZWiv+AOHlO1&#x2F;IFofUD3VHcSRMYwH5j6Irc0p0XTnFg+GHBpqjxwMWxP6IxdVrsOWUALM5oOJYn4aJQy5kSpJFkwNW8xDvVgtOWq5P9fVfnE4Am0LI&#x2F;DevzYtcr3O9hUmCfEOnF0hC0n4ghYOPqiB4&#x3D;-----END CERTIFICATE----- 4、设置rbac1234567891011121314151617181920212223[root@master ~]# vim gitlab-admin-service-account.yamlapiVersion: v1kind: ServiceAccountmetadata: name: gitlab-admin namespace: kube-system---apiVersion: rbac.authorization.k8s.io&#x2F;v1beta1kind: ClusterRoleBindingmetadata: name: gitlab-adminroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects:- kind: ServiceAccount name: gitlab-admin namespace: kube-system[root@master ~]# kubectl apply -f gitlab-admin-service-account.yamlserviceaccount&#x2F;gitlab-admin createdclusterrolebinding.rbac.authorization.k8s.io&#x2F;gitlab-admin created 5、获取gitlab-admin的token1234567891011121314[root@master ~]# kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep gitlab-admin | awk &#x27;&#123;print $1&#125;&#x27;)Name: gitlab-admin-token-pmb2hNamespace: kube-systemLabels: &lt;none&gt;Annotations: kubernetes.io/service-account.name: gitlab-admin kubernetes.io/service-account.uid: bc9e1f94-088d-41f4-8e18-f31f1e9a9369Type: kubernetes.io/service-account-tokenData====ca.crt: 1025 bytesnamespace: 11 bytestoken: eyJhbGciOiJSUzI1NiIsImtpZCI6InluNWZyY3V5T1BjNmFFQlpmRVBmOGFOenRmVkx1U0dCRDFhT0s5dEtGeXMifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJnaXRsYWItYWRtaW4tdG9rZW4tcG1iMmgiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZ2l0bGFiLWFkbWluIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQudWlkIjoiYmM5ZTFmOTQtMDg4ZC00MWY0LThlMTgtZjMxZjFlOWE5MzY5Iiwic3ViIjoic3lzdGVtOnNlcnZpY2VhY2NvdW50Omt1YmUtc3lzdGVtOmdpdGxhYi1hZG1pbiJ9.HGNf2_q_NS7ASk2ID6Y658PMpDIruFLr70VGk9I_dAP-rYt81FarjQhIQPn554SrtmiTp-iQ_j7slX_YRsGHlpo74VrBM2SirDToXobuSpe77v6MFx6Ol2UsUrxY0ulm_DAjOhZ16jlohPWlhkP0083KBfywwdpyF2oVdALQnT4sI1aDxgUHs-Pmg6D0NbdN0Ipb--s-Z59QKGr1XH4Pp0Qb9kze6KCJSWOk8-4pwtpQcT7K2MA1ucyEJB283D5ChQSddo9q7pBkEwq94TLy-ZbAhHgO89OqVIjY-3H-rb5Kd3meGrtGJZJscx7xnn6_DEvbBwp8DmCoM4vfFLUUow 6、添加k8s集群","categories":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/categories/CICD/"}],"tags":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/tags/CICD/"}]},{"title":"React","slug":"React","date":"2021-07-11T00:05:00.000Z","updated":"2021-08-08T08:26:29.744Z","comments":true,"path":"2021/07/11/React/","link":"","permalink":"https://yzhou15.gitee.io/2021/07/11/React/","excerpt":"","text":"一. React1.React 概述1.1 什么是React用于构建用户界面的JavaScript库 用户界面: HTML页面(前端) React主要用来写HTML页面,或者构建Web应用 如果从MVC的角度来看,React仅仅是视图层(V), 也就是只负责试图的渲染,而非提供了完整的M和C功能 1.2 React的特点 声明式 (只需要描述UI看起来是什么样,都跟写HTML一样) 123const jsx = &lt;div className = &quot;app&quot;&gt; &lt;h1&gt;Hello React! 动态变化数据: &#123;count&#125; &lt;/h1&gt;&lt;/div&gt; 基于组件 组件是Reat最重要的内容 组件表示页面中的部分内容 组合、复用多个组件,可以实现完整的页面功能 学习一次,随处使用 使用 React可以开发Web应用 使用 React可以开发移动端原生应用( react- native) 使用 React可以开发VR(虚拟现实)应用( react360) 2. React 的基本使用2.1 React的安装安装命令: npm i react react-dom react 包是核心,提供创建元素,组件等功能 react-dom包提供DOM相关功能等 123456789101112131415161718// 1. 引入react和react-dom两个js文件&lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;// 2. 创建React元素&lt;script&gt; // 参数一: 元素名称 // 参数二: 元素属性 // 参数三: 元素的子节点 const title = React.createElement(&#x27;h1&#x27;, null, &#x27;Hello React&#x27;)&lt;/script&gt; // 3. 渲染React元素到页面中&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //创建id属性为root的元素&lt;script&gt; const title = React.createElement(&#x27;h1&#x27;, null, &#x27;Hello React&#x27;) // 参数一: 要渲染的react元素 // 参数二: 挂载点 ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))&lt;/script&gt; 2.2 方法说明 React.creatElement()说明(知道) 12345678910111213141516&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //创建id属性为root的元素&lt;script&gt; // 参数一: 要渲染的react元素 // 参数二: 挂载点 // 第三个及其后面的参数: 元素的子节点 const title = React.createElement( &#x27;p&#x27;, &#123; title: &#x27;我是标题&#x27;, id: &#x27;p1&#x27; &#125;, &#x27;Hello React&#x27;, React.createElement(&#x27;span&#x27;, null, &#x27;我是span节点&#x27;) ) // 参数一: 要渲染的react元素 // 参数二: 挂载点 ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))&lt;/script&gt; ReactDOM.render()说明 123// 第一个参数: 要渲染的React元素// 第二个参数: DOM对象, 用于指定渲染到页面中的位置ReactDOM.render(el, document.getElementById(&#x27;root&#x27;)) 3. React脚手架的使用3.1 React脚手架意义 脚手架是开发现代Web应用的必备 充分利用Webpack, Babel, ESlint等工具辅助项目开发 零配置,无需手动配置繁琐的工具即可使用 关注业务而不是工具配置 3.2 使用React脚手架初始化项目 初始化项目,命令: npx create-react-app my-app 启动项目,在项目根目录执行 npm start 3.3 在脚手架中使用React 导入react 和react-dom两个包 12imoort React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27; 调用React.createElement()方法来创建React元素 调用ReactDOM.render()方法渲染react元素到页面中 3.4 React基础总结 Reat是构建用户界面的 JavaScript库 使用 react时,推荐使用脚手架方式 初始化项目命令: npx create- react- app my-app 启动项目命令: yarn start(或 npm start) React. createElement0方法用于创建 react元素(知道) ReactDoM. render0方法负责渲染 react元素到页面中 二. JSX目标: 能够知道什么是JSX 能够使用JSX创建 React元素 能够在JsX中使用 JavaScript表达式 能够使用JSX的条件渲染和列表渲染 能够给JsX添加样式 JSX的基本使用 JSX中使用 JavaScript表达式 JSX的条件渲染 JSX的列表渲染 JSX的样式处理 1. JSX的基本使用1.1 creatElement()的问题 繁琐不简洁 不直观,无法一眼看出所描述的结构 不优雅,用户体验不爽 1.2 JSX简介JsX是 JavaScript XML的简写,表示在 JavaScript代码中写XML(HTML)格式的代码 优势:声明式语法更加直观、与HTM结构相同,降低了学习成本、提升开发效率 JSX的React的核心内容 推荐使用JSX语法创建 React元素 写JSX就跟写HTML一样,更加直观、友好 JSX语法更能体现 React的声明式特点(描述U长什么样子) 使用步骤 使用JSX语法创建React元素 12// 使用JSX语法,创建React元素const tltle = &lt;h1&gt;Hello JSX&lt;/h1&gt; 使用ReactDOM.render()方法渲染react元素到页面中 12// 渲染创建好的React元素ReactDOM.render(title,root) 1.3 思考为什么脚手架中可以使用JSX语法? 1.J5X不是标准的 ECMAScript语法,它是 ECMAScript的语法扩展 2.需要使用 babel编译处理后,才能在浏览器环境中使用。 3. create-react-app脚手架中已经默认有该配置,无需手动配置 4.编译SX语法的包为:@ babel/preset-react 1.4 注意点 React元素的属性名使用驼峰命名法 特殊属性名: class-&gt; className、for-&gt; htmlFor、 tabindex-&gt; tabIndex 没有子节点的Reac元素可以用**/&gt;**结束 推荐:使用小括号包裹JSX,从而避免JS中的自动插入分号陷阱 1234567891011121314const title = &lt;h1 className=&quot;title&quot;&gt;Hello JSX &lt;span /&gt;&lt;/h1&gt;ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))// 使用小括号包裹JSXconst dv = ( &lt;div&gt;Hello JSX&lt;/div&gt;)const title = ( &lt;h1 className=&quot;title&quot;&gt; Hello JSX &lt;span /&gt; &lt;/h1&gt;) 2. JSX中使用JavaScript表达式嵌入JS表达式 数据存储在JS中 语法: {JavaScript表达式} 注意:语法中是单大括号,不是双大括号 1234const name = &#x27;Jack&#x27;const dv = ( &lt;div&gt;你好,我叫: &#123;name&#125;&lt;/div&gt;) 注意点: 单大括号中可以使用任意的 JavaScript表达式 JSX自身也是JS表达式 注意:JS中的对象是一个例外,一般只会出现在stye属性中 注意:不能在中出现语句(比如:if/for等 3. JSX的条件渲染1234567891011121314151617181920212223242526272829// 条件渲染// if-elseconst isloading = trueconst loadData = () =&gt; &#123; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return &lt;div&gt;数据加载完成,此处显示加载后的数据&lt;/div&gt;&#125;// 三元表达式const loadData = () =&gt; &#123; return isloading ? (&lt;div&gt;loading...&lt;/div&gt;) : (&lt;div&gt;数据加载完成,此处显示加载后的数据&lt;/div&gt;)&#125;// 逻辑与运算符const loadData = () +&gt; &#123; return isLoading &amp;&amp; (&lt;div&gt;loading...&lt;/div&gt;)&#125;const title = ( &lt;h1&gt; 条件渲染: &#123;loadData()&#125; &lt;/h1&gt;)// 渲染react元素ReactDOM.render(title, document.getElementById(&#x27;root&#x27;)) 4. JSX的列表渲染 如果要渲染一组数据,应该使用数组的map0方法 注意:渲染列表时应该添加key属性,key属性的值要保证唯一 原则:map0遍历谁,就给谁添加key属性 12345678910const songs = [ &#123;id:1,name:&quot;痴心绝对&#x27;&#125; &#123;id:2,name:·像我这样的人&#x27;&#125;, &#123;id:3,name:&quot;南山南&#x27;&#125;,]const list = ( &lt;ul&gt; &#123;songs. map(item =&gt;&lt;li key=&#123;item id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125; &lt;/u1&gt;) 5. JSX的样式处理1. 行内样式 - style123&lt;h1 style=&#123;&#123;color: &#x27;red&#x27;, backgroundColor: &#x27;skyblue&#x27;&#125;&#125;&gt; JSX的样式处理&lt;/h1&gt; 2. 类名 - className(推荐)123&lt;h1 className = &#x27;title&#x27;&gt; JSX的样式处理&lt;/h1&gt; 总结:JSX JSX是React的核心内容 JSX表示在J5代码中写HTML结构,是React声明式的体现 使用J5X配合嵌入的J5表达式、条件渲染、列表渲染,可以描述任意UI结构 推荐使用[lassName的方式给JSX添加样式 React完全利用J语言自身的能力来编写圈,而不是造轮子增强HTML功能 三. React组件基础1. React组件介绍 组件是Reat的一等公民,使用 React就是在用组件 组件表示页面中的部分功能 组合多个组件实现完整的页面功能 特点:可复用、独立、可组合 2. React组件的两种创建方式 使用函数创建组件 使用类创建组件 2.1 使用函数创建组件 函数组件:使用js的函数(或箭头函数)创建的组件叫做:函数组件 约定1:函数名称必须以大写字母开头,React据此区分组件和普通的 React元素 约定2: 函数组件必须有返回值,表示该组件的结构 如果返回值为null, 表示不渲染任何内容 渲染函数组件: 用函数名作为组件标签名 组件标签可以是单标签也可以是双标签 123456789101112// 函数组件function Hello()&#123; return ( &lt;div&gt;这是我的第一个函数组件!&lt;/div&gt; )&#125;// 箭头函数写法const Hello = () =&gt; &lt;div&gt;这是我的第一个函数组件!&lt;/div&gt;// 渲染组件ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;)) 2.2 使用类创建组件 类组件: 使用ES6的class创建的组 约定1: 类名称也必须以大写字母开头 约定2: 类组件应该继承React.Component父类,从而可以使用父类中提供的方法或属性 约定3: 类组件必须提供 render0方法 约定4: render0方法必须有返回值,表示该组件的结构 123456class Hello extends React.Compontent &#123; reder() &#123; return &lt;div&gt;Hello Class Component!&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;)) 2.3 抽离为独立JS文件组件作为一个独立的个体,一般都会放到一个单独的JS文件中 创建 Hello.js 在 Hello.js中导入 React 创建组件(函数或类) 在 Hello.js中导出该组件 在 index.js中导入Hllo组件 渲染组件 3. React事件处理3.1 事件绑定 React事件绑定语法与DOM事件语法相似 语法: on+事件名称={事件处理程序}, 比如: onClick={() = &gt; {}} 注意: React事件采用驼峰命名法, 比如: onMouseEnter, onFocus 1234567891011121314151617181920212223242526// 类组件事件绑定class Hello extends React.Compontent &#123; handleClick() &#123; console.log(&#x27;单击事件触发了&#x27;) &#125; reder() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/buttom&gt; ) &#125;&#125;ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;))// 函数组件事件绑定function App() &#123; // 事件处理程序 function handClick() &#123; console.log(&#x27;函数组件中的事件绑定,单击事件触发了&#x27;) &#125; return ( &lt;button onClick=&#123;handleClick&#125;&gt;点我&lt;/buttom&gt; //函数组件中没有this )&#125;// 渲染组件ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;)) 3.2 事件对象 可以通过事件处理程序的参数获取到事件对象 React中的事件对象叫做: 合成事件(对象) 合成事件: 兼容所有浏览器, 无需担心跨浏览器兼容的问题 123456789101112131415/* React事件对象 */class App extends React.Component &#123; handleClick(e) &#123; // 阻止浏览器的默认行为 e.preventDefault() console.log(&#x27;a标签的单机事件触发了&#x27;) &#125; render() &#123; return( &lt;a href=&quot;&lt;https://www.baidu.com/&gt;&quot; onCLick=&#123;this.handleClick&#125;&gt;baidu&lt;/a&gt;&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 4. 有状态组件和无状态组件 函数组件又叫做无状态组件,类组件又叫做有状态组件 状态( state)即数据 函数组件没有自己的状态,只负责数据展示(静) 类组件有自己的状态,负责更新UI,让页面“动”起来 5. 组件中的state 和setState5.1 state的基本使用 状态( state)即数据,是组件内部的私有数据,只能在组件内部使用 state的值是对象,表示一个组件中可以有多个数据 12345678910111213141516171819202122class Hello extends React.Component &#123; constructor() &#123; super() // 初始化state this.state = &#123; count: 0 &#125; &#125; // 简化语法初始化state state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) 5.2 setState()修改状态 状态是可变的 语法: this setstate((要修改的数据 注意:不要直接修改 state中的值,这是错误的!! 123456789101112131415161718class Hello extends React.Component &#123; state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) setState()作用: 1.修改state 2.更新UI 思想: 数据驱动视图 6. 事件绑定this指向6.1 从JSX中抽离事件处理程序 JSX中掺杂过多的JS逻辑代码,会显得非常混乱 推荐: 将逻辑抽离到单独的方法中,保证JSX结构清晰 原因: 事件处理程序中this的值为undefined 希望: this指向组件实例(render方法中的this即为组件实例) 6.2 如何处理事件绑定this指向的问题 箭头函数 利用箭头函数自身不绑定this的特点 render()方法中的this为组件实例,可以获取到setState() 1234567891011121314151617181920212223class Hello extends React.Component &#123; state = &#123; count: 0 &#125; // 事件处理程序 onIncrement() &#123; console.log(&#x27;事件处理程序中的this:&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; this.onIncrement()&#125;&gt;+1&lt;/button&gt; // &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) Function.prototype.bind() 利用ES5中的bind方法,将事件处理程序中的this与组件实例绑定到一起 12345678910111213141516171819202122232425class Hello extends React.Component &#123; constructor() &#123; super() this.state = &#123; count: 0 &#125; this.onIncrement = this.onIncrement.bind(this) &#125; // 事件处理程序 onIncrement() &#123; console.log(&#x27;事件处理程序中的this:&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) class的实例方法 利用箭头函数形式的实例方法 注意: 该语法是实验性语法,但是,由于babel的存在可以直接使用 1234567891011121314151617181920212223class Hello extends React.Component &#123; state = &#123; count: 0 &#125; // 事件处理程序 onIncrement = () =&gt; &#123; console.log(&#x27;事件处理程序中的this:&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; // &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) 6.3 总结 推荐: 使用class的实例方法 12345class Hello extends React.Component &#123; onIncrement = () =&gt; &#123; this.setState(&#123;...&#125;) &#125;&#125; 箭头函数 1&lt;button onClick=&#123;() =&gt; this.onIncrement()&#125; /&gt;&lt;/button&gt; bind 1234constructor() &#123; super() this.onIncrement = this.onIncrement.bind(this)&#125; 7. 表单处理 受控组件 非受控组件 7.1 受控组件 HTML中的表单元素是可输入的, 也就是有自己的可变状态 而React中可变状态通常保存在state中,并且只能通过setState() 方法来修改 React将state与表单元素值value绑定到一起,由state的值来控制表单元素的值 受控组件: 其值受到React控制的表单元素 123456789101112131415161718192021222324/*受控组件:其值受到React控制的表单元素操作文本框的值:*/class App extends React.component&#123; state = &#123; txt: &#x27;&#x27; &#125;&#125;handleChange = e =&gt; &#123; this.setState(&#123; txt: e.target.value &#125;)&#125;render () &#123; return ( &lt;div&gt; &lt;input type=&quot;txt&quot; value=&#123;this.state.txt&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; )&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementById(&#x27;root&#x27;)) 步骤: 在state中添加一个状态,作为表单元素的value值(控制表单元素值的来源) 给表单元素绑定change事件,将表单元素的值设置为state的值(控制表单元素值的变化) 1234state = &#123; txt: &#x27;&#x27; &#125;&lt;input type=&quot;text&quot; value=&#123;this.state.txt&#125; onChange=&#123;e =&gt; this.setState(&#123; txt: e.target.value &#125;)&#125;/&gt; 示例: 文本框,富文本框,下拉框 复选框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*受控组件示例*/class App extends React.component&#123; state = &#123; txt: &#x27;&#x27;, content: &#x27;&#x27;, city: &#x27;bj&#x27;, isChecked: false &#125;&#125;handleChange = e =&gt; &#123; this.setState(&#123; txt: e.target.value &#125;)&#125;//处理富文本框的变化handleContent = e =&gt; &#123; this.setState(&#123; content: e.target.value &#125;)&#125;//处理下拉框的变化handleCity = e =&gt; &#123; this.setState(&#123; city: e.target.value &#125;)&#125;// 处理复选框的变化handleChecked = e =&gt; &#123; this.setState(&#123; isChecked: e.target.checked &#125;)&#125;render () &#123; return ( &lt;div&gt; &#123;/*文本框*/&#125; &lt;input type=&quot;txt&quot; value=&#123;this.state.txt&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;br /&gt; &#123;/*富文本框*/&#125; &lt;textarea value=&#123;this.state.content&#125; onChange=&#123;this.handeleContent&#125;&gt;&lt;/textarea&gt; &lt;br /&gt; &#123;/*下拉框*/&#125; &lt;select value=&#x27;this.state.city&#x27; onChange=&#123;this.handleCity&#125;&gt; &lt;option value=&#x27;sh&#x27;&gt;上海&lt;/option&gt; &lt;option value=&#x27;bj&#x27;&gt;北京&lt;/option&gt; &lt;option value=&#x27;gz&#x27;&gt;广州&lt;/option&gt; &lt;/select&gt; &#123;/*复选框*/&#125; &lt;input type=&quot;checkbox&quot; checked=&#123;this.state.isChecked&#125; onChange=&#123;this.handleChecked&#125; /&gt; &lt;/div&gt; )&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementById(&#x27;root&#x27;))// 示例总结:// 1. 文本框,富文本框, 下拉框操作value属性// 2. 复选框操作checked属性 多表单元素优化步骤: 给表单元素添加name属性,名称与state相同 根据表单元素类型获取对应值 在change时间处理程序中通过[name]来修改对应的state 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*受控组件示例*/class App extends React.component&#123; state = &#123; txt: &#x27;&#x27;, content: &#x27;&#x27;, city: &#x27;bj&#x27;, isChecked: false &#125;&#125;handleFrom = e =&gt; &#123; // 获取当前的DOM对象 const target = e.target // 根据类型获取值 const value = target.type === &#x27;checkbox&#x27; ? target.checked : target.value // 获取name const name = target.name this.setState(&#123; [name]: value &#125;)&#125;render () &#123; return ( &lt;div&gt; &#123;/*文本框*/&#125; &lt;input type=&quot;txt&quot; name=&quot;txt&quot; value=&#123;this.state.txt&#125; onChange=&#123;this.handleFrom &#125; /&gt; &lt;br /&gt; &#123;/*富文本框*/&#125; &lt;textarea name=&quot;content&quot; value=&#123;this.state.content&#125; onChange=&#123;this.handleFrom &#125;&gt;&lt;/textarea&gt; &lt;br /&gt; &#123;/*下拉框*/&#125; &lt;select name=&quot;city&quot; value=&#x27;this.state.city&#x27; onChange=&#123;this.handleFrom &#125;&gt; &lt;option value=&#x27;sh&#x27;&gt;上海&lt;/option&gt; &lt;option value=&#x27;bj&#x27;&gt;北京&lt;/option&gt; &lt;option value=&#x27;gz&#x27;&gt;广州&lt;/option&gt; &lt;/select&gt; &#123;/*复选框*/&#125; &lt;input name=&quot;isChecked&quot; type=&quot;checkbox&quot; checked=&#123;this.state.isChecked&#125; onChange=&#123;this.handleFrom &#125; /&gt; &lt;/div&gt; )&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementById(&#x27;root&#x27;)) 7.2 非受控组件使用步骤: 调用React.createRef()方法创建一个ref对象 1234constructor() &#123; super() this.txtRef = React.createRef()&#125; 将创建好的ref对象添加到文本框中 1&lt;input type=&quot;text&quot; ref=&#123;this.txtRef&#125; /&gt; 通过ref对象获取到文本框的值 1console.log(this.txtRef.current.value) React组件基础小案例: 需求分析: 渲染评论列表(列表渲染) 没有评论数据时渲染:暂无评论(条件渲染) 获取评论信息,包括评论人和评论内容(受控组件) 发表评论,更新评论列表(setState() ) 1234567891011121314151617181920212223242526class App extends React.Component &#123; render() &#123; &lt;div className=&quot;app&quot;&gt; &lt;div&gt; &lt;inout className=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;请输入评论人&quot; /&gt; &lt;br /&gt; &lt;textarea&gt; className=&quot;content&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;请输入评论内容&quot; /&gt; &lt;br /&gt; &lt;button&gt;发表评论&lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;no-comment&quot;&gt;暂无评论,快去评论吧~&lt;/div&gt; &lt;ul&gt; &lt;li&gt; &lt;h3&gt;评论人: jack&lt;/h3&gt; &lt;p&gt;评论内容: 沙发!!!&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &#125;&#125; 实现步骤: 渲染评论列表 在state中初始化列表数据 使用数组的map方法遍历state中的列表数据 给每个被遍历的元素添加key属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 评论列表案例 comments: [ &#123;id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发!!!&#x27;&#125;, &#123;id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~~&#x27;&#125;, &#123;id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人~&#x27;&#125; ]*/import &#x27;/.index.css&#x27;class App extends React.Component &#123; // 初始化状态 state =&#123; comments: [ &#123;id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发!!!&#x27;&#125;, &#123;id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~~&#x27;&#125;, &#123;id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人~&#x27;&#125; ] &#125; render() &#123; return ( &lt;div className=&quot;app&quot;&gt; &lt;div&gt; &lt;input className=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;请输入评论人&quot; /&gt; &lt;br /&gt; &lt;textarea className=&quot;content&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;请输入评论内容&quot; /&gt; &lt;br /&gt; &lt;button&gt;发表评论&lt;/button&gt; &lt;/div&gt; &lt;div className=&quot;no-comment&quot;&gt;暂无评论,快去评论吧~&lt;/div&gt; &lt;ul&gt; &#123; this.state.comments.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;h3&gt;评论人: &#123;item.name&#125;&lt;/h3&gt; &lt;p&gt;评论内容: &#123;item.content&#125;&lt;/p&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; 渲染暂无评论 判断列表数据的长度是否为0 如果为0,则渲染暂无评论 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 评论列表案例 comments: [ &#123;id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发!!!&#x27;&#125;, &#123;id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~~&#x27;&#125;, &#123;id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人~&#x27;&#125; ]*/import &#x27;/.index.css&#x27;class App extends React.Component &#123; // 初始化状态 state =&#123; comments: [ &#123;id: 1, name: &#x27;jack&#x27;, content: &#x27;沙发!!!&#x27;&#125;, &#123;id: 2, name: &#x27;rose&#x27;, content: &#x27;板凳~~&#x27;&#125;, &#123;id: 3, name: &#x27;tom&#x27;, content: &#x27;楼主好人~&#x27;&#125; ] &#125; // 渲染评论列表 renderList() &#123; return this.state.comments.length === 0 ? ( &lt;div className=&quot;no-comment&quot;&gt;暂无评论,快去评论吧~&lt;/div&gt; ) : ( &lt;ul&gt; &#123; this.state.comments.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;h3&gt;评论人: &#123;item.name&#125;&lt;/h3&gt; &lt;p&gt;评论内容: &#123;item.content&#125;&lt;/p&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; ) &#125; render() &#123; return ( &lt;div className=&quot;app&quot;&gt; &lt;div&gt; &lt;input className=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;请输入评论人&quot; /&gt; &lt;br /&gt; &lt;textarea className=&quot;content&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;请输入评论内容&quot; /&gt; &lt;br /&gt; &lt;button&gt;发表评论&lt;/button&gt; &lt;/div&gt; &#123;/*通过条件渲染决定渲染什么内容*/&#125; &#123;this.renderList()&#125; /*&#123;this.state.comments.length === 0 ? ( &lt;div className=&quot;no-comment&quot;&gt;暂无评论,快去评论吧~&lt;/div&gt; ) : ( &lt;ul&gt; &#123; this.state.comments.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;h3&gt;评论人: &#123;item.name&#125;&lt;/h3&gt; &lt;p&gt;评论内容: &#123;item.content&#125;&lt;/p&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;*/ &lt;/div&gt; ) &#125;&#125; 7.3 React 组件基础综合案例 案例需求分析 渲染评论列表(列表渲染) 没有评论数据时渲染: 暂无评论(条件渲染) 获取评论信息,包括评论人和评论内容(受控组件) 发表评论,更新评论列表(setState()) 四. React组件进阶1. 组件通讯介绍2. 组件的props 组件是封闭的,要接收外部数据应该通过props来实现 props的作用: 接收传递给组件的数据 传递数据: 给组件标签添加属性 接收数据: 函数组件通过参数props接收数据,类组件通过this.props接收数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*props*/// 函数组件// 2. 接收数据const Hello = (props) =&gt; &#123; // props是一个对象 return ( &lt;div&gt; // 3. 使用 &lt;h1&gt;props: &#123;props.name&#125;&lt;/h1&gt; &lt;/div&gt; )&#125;// 1. 传递数据ReactDOM.render(&lt;Hello name=&quot;jack&quot; age=&#123;19&#125; /&gt;, document.getElementById(&#x27;root&#x27;))/*props*/// 类组件// 2. 接收数据class Hello extends React.Component &#123; render() &#123; // console.log(this.props); console.log(&#x27;props:&#x27;, props) props.fn() return ( &lt;div&gt; &lt;h1&gt;props:&#123;this.props.age&#125;&lt;/h1&gt; &#123;props.tag&#125; &lt;/div&gt; ) &#125;&#125;// 1. 传递数据ReactDOM.render( &lt;Hello name=&quot;rose&quot; age=&#123;19&#125; colors=&#123;[&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]&#125; fn=&#123;[() =&gt; console.log(&#x27;这是一个函数&#x27;)]&#125; tag=&#123;&lt;p&gt;这是一个p标签&lt;/p&gt;&#125; /&gt;, document.getElementById(&#x27;root&#x27;)) 特点: 可以传递任意类型的数据 props是只读的对象, 只能读取属性的值,无法修改对象 注意: 使用类组件时, 如果写了构造函数,应该将props传递给super() , 否则, 无法在构造函数中获取到props! 123456789101112131415161718// 类组件class Hello extends React.Component &#123; // 推荐使用props作为constructor的参数! constructor(props)&#123; super(props) &#125; console.log(props)&#125;render() &#123; console.log(&#x27;render:&#x27;, this.props) return ( &lt;div&gt; &lt;h1&gt;props: &lt;/h1&gt; &lt;/div&gt; )&#125; 3. 组件通讯的三种方式组件之间的通讯分为3种: 父组件 - &gt; 子组件 子组件 - &gt; 父组件 兄弟组件 3.1 父组件传递数据给子组件 父组件提供要传递的state数据 给子组件标签添加属性, 值为state中的数据 子组件中通过props接受父组件中传递的数据 123456789101112131415161718192021222324252627// 父组件class Parent extends React.Component &#123; state = &#123; lastName: &#x27;王&#x27; &#125; render() &#123; return ( &lt;div className=&quot;parent&quot;&gt; 父组件: &lt;child name=&#123;this.state.lastName&#125;/&gt; &lt;/div&gt; ) &#125;&#125;// 子组件const Child = (props) =&gt; &#123; console.log(&#x27;子组件&#x27;, props) return ( &lt;div className=&quot;child&quot;&gt; &lt;p&gt;子组件,接收到父组件的数据: &#123;props.name&#125;&lt;/p&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;Parent /&gt;, document.getElementById(&#x27;root&#x27;)) 3.2 子组件传递数据给父组件 思路: 利用回调函数,父组件提供回调,子组件调用,将要传递的数据作为回调函数的参数 父组件提供一个回调函数(用于接收数据) 将该函数作为属性的值,传递给子组件 子组件通过props调用回调函数 将子组件的数据作为参数传递给回调函数 12345678910111213141516171819202122232425262728293031323334353637// 父组件class Parent extends React.Component &#123; state = &#123; parentMsg: &#x27;&#x27; &#125; // 提供回调函数,用来接收数据 getChildMsg = (data) =&gt; &#123; console.log(&#x27;接收到子组件中传递过来的数据&#x27;, data) this.setState(&#123; parentMsg: data &#125;) &#125; render() &#123; return ( &lt;div&gt; 子组件: &lt;Child getMsg=&#123;this.getChildMsg&#125; /&gt; &lt;/div&gt; ) &#125;&#125;// 子组件class Child extends React.Component &#123; state = &#123; msg: &#x27;刷抖音&#x27; &#125; handClick = () =&gt; &#123; // 子组件调用父组件中传递过来的回调函数 this.props.getMsg() &#125; render() &#123; &lt;div className=&quot;child&quot;&gt; 子组件: &lt;button onClick=&#123;this.handleClick&#125;&gt;点我,给父组件传递数据&lt;/button&gt; &lt;/div&gt; &#125;&#125; 3.3 兄弟组件 将共享状态提升到最近的公共父组件中,由公共父组件管理这个状态 思想: 状态提升 公共父组件职责: 1. 提供共享状态 2. 提供操作共享状态的方法 4. Context作用 : 跨组件传递数据(比如: 主题,语言等) 使用步骤: 调用React.createContext()创建Provider(提供数据)和Consumer(消费数据)两个组件. 1const &#123; Provider, Consumer &#125; = React.createContext() 使用Provider组件作为父节点. 12345&lt;Provider&gt; &lt;div className=&quot;App&quot;&gt; &lt;child1 /&gt; &lt;/div&gt;&lt;/Provider&gt; 设置value属性,表示要传递的数据 1&lt;Provider value=&quot;pink&quot;&gt; 使用Consumer组件接收数据 123&lt;Consumer&gt; &#123;data =&gt; &lt;span&gt;data参数表示接收到的数据 -- &#123;data&#125;&lt;/span&gt;&#125;&lt;/Consumer&gt; 5. props深入5.1. children属性 children属性: 表示组件婊气啊俺的子节点.当组件标签有子节点时,props就会有该属性 5.2. prpos校验 安装包props-types( yarn add prop-types/npm i props-types) 导入props-types包 使用组件名.propTypes = {} 来给组件的props添加校验规则 校验规则通过PropTypes对象来指定 1234567891011import PropTypes from &#x27;prop-types&#x27;function App(props) &#123; return ( &lt;h1&gt;Hi,&#123;props.colors&#125;&lt;/h1&gt; )&#125;App.propTypes = &#123; // 约定colors属性为array类型 // 如果类型不对,则爆出明确错误,便于分析错误原因 colors: PropTypes.array&#125;","categories":[{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/tags/React/"}]},{"title":"ECMA Script6","slug":"ECMA Script6","date":"2021-06-30T15:20:00.000Z","updated":"2021-08-08T08:26:29.742Z","comments":true,"path":"2021/06/30/ECMA Script6/","link":"","permalink":"https://yzhou15.gitee.io/2021/06/30/ECMA%20Script6/","excerpt":"","text":"一. let声明变量1234let a;let b,c,d;let e = 100;let f = 521, g = &#x27;iloveyou&#x27;, h = []; 变量不能重复声明 123let star = &#x27;罗志祥&#x27;;let star = &#x27;小猪&#x27;;// &quot;star&quot; has already been declared 块级作用域 123456&#123; let girl = &#x27;周扬青&#x27;;&#125;console.log(girl);// referenceError: girl is not defined// if else while for循环 不存在变量提升 123console.log(song);var = song = &#x27;恋爱达人&#x27;;// Cannot access &#x27;song&#x27; before initialization 不影响作用域链 12345678&#123; let school = &#x27;peking&#x27;; function fn()&#123; console.log(school); &#125; fn();&#125;// peking 二. const声明常量12const SCHOOL = &#x27;尚硅谷&#x27;;console.log(SCHOOL); 一定要赋初始值 12const A;// Missing initializer in const declaration 一般常量使用大写(潜规则) 1const a = 100; 常量的值不能修改 12SCHOOL = &#x27;ATGUIGU&#x27;;// Assignment to constant variable 块级作用域 12345&#123; const PLAYER = &#x27;UZI&#x27;;&#125;console.log(PLAYER);// PLAYER is not defined 对于数组和对象的元素修改,不算做对常量的修改,不会报错 12const TEAM = [&#x27;UZI&#x27;, &#x27;MXLG&#x27;, &#x27;Letme&#x27;];TEAM.push(&#x27;Meiko&#x27;); 三. 变量解构赋值12345678910111213141516171819202122232425262728293031323334// ES6 允许按照一定模式从数组和对象中提取值,对变量进行复制// 这被称为解构赋值// 1. 数组的解构const F4 = [&#x27;小沈阳&#x27;, &#x27;刘能&#x27;, &#x27;赵四&#x27;, &#x27;宋小宝&#x27;];let [xiao, liu, zhao, song] = F4;console.log(xiao);console.log(liu);console.log(zhao);console.log(song);//小沈阳//刘能//赵四//宋小宝// 2. 对象的解构const zhao = &#123; name: &#x27;赵本山&#x27;, age: &#x27;不详&#x27;, xiaopin: function()&#123; console.log(&quot;我可以演小品&quot;); &#125;&#125;;let &#123;name, age, xiaopin&#125; = zhao;console.log(name);console.log(age);console.log(xiaopin);xiaopin();//赵本山//不详//f ()&#123;// console.log(&quot;我可以演小品&quot;);// &#125;// 我可以演小品 四. ES6引入新的声明字符串的方式 [``] ‘ ‘ “ “1234567891011121314151617// 1. 声明let str = `我也是一个字符串哦!`;console.log(str, typeof str);//我也是一个字符串哦! string// 2. 内容中可以直接出现换行符let str = `&lt;ul&gt; &lt;li&gt;沈腾&lt;li&gt; &lt;li&gt;玛丽&lt;li&gt; &lt;li&gt;魏翔&lt;li&gt; &lt;li&gt;艾伦&lt;li&gt; &lt;ul&gt;`;// 3. 变量拼接let lovest = &#x27;魏翔&#x27;;let out = `$&#123;lovest&#125;是我心目中最搞笑的演员!!`;console.log(out);// 魏翔是我心目中最搞笑的演员!! 五. 简化对象写法12345678910111213141516// ES6 允许在大括号里面,直接写入变量和函数,作为对象的属性和方法// 这样的书写更加简洁let name = &#x27;尚硅谷&#x27;;let change = function()&#123; console.log(&#x27;我们可以改变你&#x27;);&#125;const school = &#123; name, // name: name, change, improve: function()&#123; console.log(&quot;我们可以提高你的技能&quot;); &#125;&#125;console.log(school); 六. 箭头函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ES6允许使用[箭头] (=&gt;)定义函数// 声明一个函数// let fn = function()&#123;// &#125;// 声明let fn = (a, b) =&gt; &#123; return a + b;&#125;// 调用函数let result = fn(1, 2);console.log(result);// 和之前区别:// 1. this 是静态的. this 始终指向函数声明时所在作用域下的this的值function getName()&#123; console.log(this.name);&#125;let getName2 = () =&gt; &#123; console.log(this.name);&#125;// 设置 window对象的name属性window.name = &#x27;乐乐&#x27;;const school = &#123; name: &quot;LELE&quot;&#125;// 直接调用getName();getName2();// 乐乐// 乐乐// call方法调用getName.call(school);getName2.call(school);// LELE// 乐乐// 2. 不能作为构造实例化对象let Person = (name, age) =&gt; &#123; this.name = name; this.age = age;&#125;let me = new Person(&#x27;xiao&#x27;, 30);console.log(me);// 3. 不能使用arguments变量","categories":[{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/tags/ES6/"}]},{"title":"dnpicture","slug":"dnpicture","date":"2021-04-30T15:52:39.000Z","updated":"2021-08-08T08:26:29.751Z","comments":true,"path":"2021/04/30/dnpicture/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/30/dnpicture/","excerpt":"","text":"1 uni-app学习1.1 什么是uni-app uni-app是一个使用Vue.js语法来开发所有前端应用的框架（也称之为全端开发框架） 技术栈：JavaScript，vue， 微信小程序， uni-app 1.2 有哪些uni-app的作品 线上项目.png 1.3. uni-app的社区规模 社区规模.png 2 uni-app基础2.1 如何创建项目12345678脚手架搭建项目1.全局安装 npm install -g @vue/cli 2.创建项目 vue create -p dcloudio/uni-preset-vue my-project 3.启动项目（微信小程序） npm run dev:mp-weixin 4.微信小程序开发者工具导入项目 （搭建过程中可能会遇到的问题） 脚手架搭建版本不一致.png 2.2 如何编写代码2.3 uni-app初体验 初始界面.png 2.4 项目结构介绍 项目目录.png 2.5 样式和sass 支持小程序的rpx 和 h5的vw，vh。 rpx 小程序中的单位 750rpx = 屏幕宽度 vw h5单位 100vw = 屏幕的宽度， 100vh = 屏幕的高度 内置sass的配置， 只需要安装对应的依赖即可 npm install sass-loader node-sass vue组件中，在style标签上加入属性&lt;style lang= &#39;scss&#39;&gt;即可 2.6 基本语法学过vue的同学应该很容易上手,大胆去尝试吧 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;view&gt;&#123;&#123;dataObj.name&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;dataObj.age&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;dataObj.boolean&#125;&#125;&lt;/view&gt; &lt;view&gt; &lt;view v-for=&quot;item in filterList&quot; :key= &#x27;item.id&#x27;&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; dataObj: &#123; name: &#x27;Davidsofter&#x27;, age: 23, boolean: true, &#125;, fruitList: [&#123;id: 0, text: &#x27;🍎&#x27;&#125;,&#123;id: 1, text: &#x27;🍌&#x27;&#125;,&#123;id: 2, text: &#x27;🍇&#x27;&#125;] &#125; &#125;, computed: &#123; filterList() &#123; return this.fruitList.filter(v =&gt; v.id&lt;=0) &#125; &#125; &#125;&lt;/script&gt; 基本语法显示.png 2.7 事件添加点击事件，自定义参数和传参 123456789101112131415161718192021222324&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;view&gt; &lt;button data-item=&quot;123&quot; @click=&quot;btclick(1,$event)&quot;&gt;点击我试试&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &#125; &#125;, methods: &#123; btclick(data,event) &#123; console.log(&quot;我不想努力了😘&quot;) console.log(data) console.log(event) &#125; &#125;, &#125;&lt;/script&gt; 查看打印出的结果： 点击事件.png 2.8 组件1 组件的定义/引入/注册/使用 重点章节，组件化思想是前端必备思想之一，灵活的使用组件可以提高网页开发效率，提高代码复用率，降低块与块之间的耦合性。 1.1 组件的定义 在src目录下新建文件夹components用来存放组件 在components目录下直接新建vue文件 1.2 组件的引入 在页面中引入组件 “import 组件名 from ‘组件路径’” 1.3 组件的注册 在页面的实例中，新增属性 components 属性components是一个对象， 在里面添加要注册的组件 1.4 组件的使用+在页面的template中添加组件标签 “&lt;组件&gt;&lt;组件/&gt;” 1.5 全局数据传递 通过prototype在vue的原型上添加属性 全局数据传递.png 在App.vue文件中向外暴露一个全局对象 globalData数据传递.png 以上两种方法的拿值 拿全局数据方法.png 1.6 使用插槽实现动态更新组件 插槽.png 2.9 生命周期1 介绍 uni-app框架的生命周期结合了vue和微信小程序的生命周期 全局APP中使用 onLaunch 表示应用启动时 页面中使用 onLoad 或者 onShow 分别表示页面加载完成 和 页面显示时 组件中使用mounted 表示组件挂载完毕时 2 完整生命周期 uni-app生命周期 vue生命周期图示 微信小程序生命周期 3.uni-app项目 懂你找图 本文结合黑马程序员教学视频，部分截图来自原视频 黑马视频链接： https://www.bilibili.com/video/BV1Sc41187nZ?p=1 作者：VinSmokeW链接：https://www.jianshu.com/p/3dec2cc2e30b来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.脚手架搭建项目1234567//1. 全局安装npm install -g @vue/cli//2. 创建项目vue create -p dcloudio/uni-preset-vue my-project//3. 启动项目（微信小程序）npm run dev:mp-weixin//4. 微信小程序开发者工具导入项目 2.项目目录 2.1.样式和sass 1npm i sass-loader@4.13.0 node-sass@8.0.2 2.2.uni-ui和接口使用 unu-ui :https://www.npmjs.com/package/@dcloudio/uni-ui 接口文档：https://www.showdoc.com.cn/414855720281749?page_id=3678621017219602 比如 http://157.122.54.189:9088/image/v3/homepage/vertical 这个接口不能用，带上参数之后http://157.122.54.189:9088/image/v3/homepage/vertical?limit=10&amp;order=hot&amp;skip=2就可以用了 index.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;view&gt;首页 &lt;text class=&quot;iconfont iconvideocamera&quot;&gt;&lt;/text&gt; &lt;uni-badge text=&quot;1&quot;&gt;&lt;/uni-badge&gt;&lt;uni-badge text=&quot;2&quot; type=&quot;success&quot; &gt;&lt;/uni-badge&gt; &lt;uni-badge text=&quot;3&quot; type=&quot;primary&quot; :inverted=&quot;true&quot;&gt;&lt;/uni-badge&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123;uniBadge&#125; from &#x27;@dcloudio/uni-ui&#x27;export default &#123; name: &quot;index&quot;, components:&#123; uniBadge &#125;, onload()&#123; // http://157.122.54.189:9088/image/v3/homepage/vertical // 1.原生的微信小程序的api wx.request(&#123; url:&quot;http://157.122.54.189:9088/image/v3/homepage/vertical?limit=10&amp;order=hot&amp;skip=2&quot;, success(res)&#123; console.log(res); &#125; &#125;) // 2. uni-api uni.request(&#123; uni:&quot;http://157.122.54.189:9088/image/v3/homepage/vertical?limit=10&amp;order=hot&amp;skip=2&quot; &#125;).then(res =&gt; &#123; console.log(res); &#125;) &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 2.2. 首页模块 功能分析 修改导航栏的外观 使用分段器组件搭建子页面 封装自己异步请求 搭建子页面 首页模块分为4个部分,分别是推荐、分类、最新、专辑 新建自定义组件来代替上述的4个页面 home-recommend home-category home-new home-album 分段器介绍 分段器指的是uni-ui中的一个组件,其实就是我们俗称的标签页,tab栏 https://ext.dcloud.net.cn/plugin?id=54 封装自己的异步请求 封装的原因 原生的请求不支持 promise unl-apl的请求不能够方便的添加请求中效果 uni-api的请求返回值是个数组,不方便 封装的思路 基于原生的 promise来封装 挂载到vue的原型上 通过 this request的方式来使用 2.3.首页模块-推荐模块 接口文档https://www.showdoc.com.cn/414855720281749?page_id=3678621017219602 数据动态渲染 moment. Js的使用 “热门”列表的基于 scroll-view的分页加载 页面 2.4.首页模块-专辑模块 专辑列表 专辑详情 1.专辑列表 1.1功能分析 使用 setNavigation BarTitle修改页面标题 发送请求获取数据 使用 swiper轮播图组件 使用 scroll-view组件实现分页 点击跳转到专辑详情页","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://yzhou15.gitee.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序 vue","slug":"微信小程序-vue","permalink":"https://yzhou15.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-vue/"}]},{"title":"vueDay5","slug":"vueDay5","date":"2021-04-23T14:51:18.000Z","updated":"2021-08-08T08:26:29.785Z","comments":true,"path":"2021/04/23/vueDay5/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/23/vueDay5/","excerpt":"","text":"一、Promise1.1. 是什么？Promise是异步编程的一种解决方案。 1.2. 做什么？用于网络请求非常复杂的情形下 口一种很常见的场景应该就是网络请求了口我们封装一个网络请求的函数,因为不能立即拿到结果,所以不能像简单的3+4=7—样将结果返回口所以往往我们会传入另外一个函数,在数据请求成功时,将数据通过传入的函数回调出去口如果只是一个简单的网络请求,那么这种方案不会给我们带来很大的麻烦。 ■但是,当网络请求非常复杂时,就会出现回调地狱 123456789101112131415161718192021// 什么情况下会用到Promise? // 一般情况下是有一些异步操作的时，使用promise对这个一步操作进行封装 // executor:执行 // new -&gt; 构造函数(1.保存了一些状态 2.执行传入的函数) // 在执行传入的回调函数时，会传入两个参数，resolve,reject，这两个参数本身又是函数 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 失败的时候调用reject reject(&#x27;error message&#x27;) // 成功的时候调用resolve // resolve(&#x27;Hello World&#x27;) &#125;, 1000) &#125;).then((data) =&gt; &#123; // 100行的处理代码 console.log(data); console.log(data); console.log(data); console.log(data); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;) 1.3. promise的三种状态 pending:等待状态,比如正在进行网络请求,或者定时器没有到时间。 fufl:满足状态,当我们主动回调了 resolve时,就处于该状态,并且会回调then0 reject:拒绝状态,当我们主动回调了 reject时,就处于该状态,并且会回调 catch0 sync→&gt;同步(synchronization)asnc→&gt;异步(asynchronization) asnc operation异步操作 wropped into 包裹进去 另一种写法 12345678910new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;Hello World&#x27;) reject(&#x27;error message&#x27;) &#125;, 1000) &#125;).then((data =&gt; &#123; console.log(data); &#125;), err =&gt; &#123; console.log(err); &#125;) 1.4. Promise链式调用：12345678910111213141516171819202122232425262728293031323334353637// 链式编程 new Promise((resolve, reject) =&gt; &#123; //第一次网络请求的代码 setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;).then(() =&gt; &#123; //第一次拿到结果的处理代码 console.log(&#x27;Hello World&#x27;); console.log(&#x27;Hello World&#x27;); console.log(&#x27;Hello World&#x27;); console.log(&#x27;Hello World&#x27;); return new Promise((resolve, reject) =&gt; &#123; //第二次网络请求的代码 setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;).then(() =&gt; &#123; //第二次拿到结果的处理代码 console.log(&#x27;Hello Vuejs&#x27;) console.log(&#x27;Hello Vuejs&#x27;) console.log(&#x27;Hello Vuejs&#x27;) console.log(&#x27;Hello Vuejs&#x27;) return new Promise((resolve, reject) =&gt; &#123; //第三次网络请求的代码 setTimeout(() =&gt; &#123; resolve() &#125;).then(() =&gt; &#123; //第三次拿到结果的处理代码 console.log(&#x27;Hello Python&#x27;) console.log(&#x27;Hello Python&#x27;) console.log(&#x27;Hello Python&#x27;) console.log(&#x27;Hello Python&#x27;) &#125;, 1000) &#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// wrapped into // 网络请求: aaa -&gt; 自己处理(10行) // 处理: aaa111 -&gt; 自己处理(10行) // 处理: aaa111222 -&gt; 自己处理 /*new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return new Promise((resolve) =&gt; &#123; resolve(res + &#x27;111&#x27;) &#125;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return new Promise((resolve) =&gt; &#123; resolve(res + &#x27;222&#x27;) &#125;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;)*/ // new Promise(resolve =&gt; resolve(结果))简写 /*new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return Promise.resolve(res + &#x27;111&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return Promise.resolve(res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;)*/ // 继续简写 /*new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return (res + &#x27;111&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return (res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;)*/ // 失败了时 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 // return Promise.reject(&#x27;error message&#x27;) throw &#x27;error message&#x27; &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return (res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 1.5. Promise的all方法使用1234567891011121314151617181920212223242526272829303132333435Promise.all([ /*new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &#x27;url1&#x27;, success: function (data) &#123; resolve(data) &#125; &#125;) &#125;), new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &#x27;url2&#x27;, success: function (data) &#123; resolve(data) &#125; &#125;) &#125;)*/ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;result1&#x27;) resolve(&#123;name: &#x27;why&#x27;, age: 18&#125;) &#125;, 2000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;result2&#x27;) resolve(&#123;name: &#x27;why&#x27;, age: 18&#125;) &#125;, 1000) &#125;) ]).then(results =&gt; &#123; /*results[0] results[1]*/ console.log(results); &#125;) 二、Vuex2.1. Vuex是做什么的 官方解释:Vuex是一个专为 Vue. js应用程序开发的状态管理模式 它采用集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex也集成到Vue的官方调试工具 devtools extension,提供了诸如零配置的time- travel调试、状态快照导入导出等高级调试功能。 状态管理到底是什么? 状态管理模式、集中式存储管理这些名词听起来就非常高大上,让人捉摸不透。 其实,你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。 然后,将这个对象放在顶层的Vue实例中,让其他组件可以使用。 那么,多个组件就可以共享这个对象中的所有变量属性 2.2. 管理什么状态 有什么状态时需要我们在多个组件间共享的呢? 如果你做过大型开放,你一定遇到过多个状态,在多个界面问的共享问题。 比如用户的登录状态、用户名称、头像、地理位置信息等等。 比如商品的收藏、购物车中的物品等等。 这些状态信息,我们都可以放在统一的地方,对它进行保存和管理,而且它们还是响应式的 Talk is cheap, Show me the code. （来自LInus) linus -&gt; linux, git 2.3. 单界面到多界面状态管理切换单页面管理状态 多界面状态管理 全局单例摸式(大管家) 我们现在要做的就是将共享的状态抽取出来,交给我们的大管家,统一进行管理 之后,你们每个试图,按照我规定好的规定,进行访问和修改等操作。 这就是vuex背后的基本思想 1npm intall vuex --save store-&gt; index.js 123456789101112131415161718192021222324252627282930313233import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;// 1. 安装插件Vue.use(Vuex)// 2. 创建对象const store = new Vuex.Store(&#123; state: &#123; counter: 1000 &#125;, mutations: &#123; increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 3. 导出store独享export default store main.js 12345678910111213import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import store from &quot;./store&quot;;Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, store, render: h =&gt; h(App)&#125;) App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h2&gt;--------App内容-------------&lt;&#x2F;h2&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h2&gt;&lt;!-- &lt;h2&gt;&#123;&#123; counter &#125;&#125;&lt;&#x2F;h2&gt;--&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;&#x2F;h2&gt;&lt;!-- &lt;button @click&#x3D;&quot;counter&amp;#45;&amp;#45;&quot;&gt;-&lt;&#x2F;button&gt;--&gt;&lt;!-- &lt;button @click&#x3D;&quot;counter++&quot;&gt;+&lt;&#x2F;button&gt;--&gt; &lt;button @click&#x3D;&quot;addition&quot;&gt;+&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;subtraction&quot;&gt;-&lt;&#x2F;button&gt; &lt;h2&gt;----------Hello Vuex内容---------&lt;&#x2F;h2&gt;&lt;!-- &lt;hello-vuex :counter&#x3D;&quot;counter&quot;&#x2F;&gt;--&gt; &lt;hello-vuex &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import HelloVuex from &quot;.&#x2F;components&#x2F;HelloVuex&quot;;export default &#123; name: &#39;App&#39;, components: &#123; HelloVuex &#125;, data() &#123; return &#123; message: &#39;我是App组件&#39;, &#x2F;&#x2F; counter: 0 &#125; &#125;, methods: &#123; addition()&#123; this.$store.commit(&#39;increment&#39;) &#125;, subtraction()&#123; this.$store.commit(&#39;decrement&#39;) &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 2.4. Vue状态管理图例 2.5. vuex核心概念 State 保存共享状态 -&gt;单一状态数 Getters 类似于组件中计算属性 Mutation 状态更新 Action 异步操作 Module 划分模块 2.5.1 State单一状态树（Single Source of Truth，可以翻译成单一数据源）如果你的状态信息是保存到多个 Store对象中的,那么之后的管理和维护等等都会变得特别困难。所以∨uex也使用了单一状态树来管理应用层级的全部状态。单一状态树能够让我们最直接的方式找到某个状态的片段,而且在之后的维护和调试过程中,也可以非常方便的管理和维护。 2.5.2. Getters基本使用需要从 store中获取一些 state变异后的状态 2.5.3 Mutation状态更新 Vuex的 store状态的更新唯一方式:提交 Mutation Mutation主要包括两部分: 字符串的事件类型(type) 一个回调函数( handler),该回调函数的第一个参数就是 state Mutation传递参数参数被称为是 mutation的载荷( Payload)■ Mutation中的代码: 123456decrement(state, n) &#123; state.count -= n&#125;decrement: function()&#123; this.$store.commit(&#x27;decrement&#x27;, 2 )&#125; 很多参数需要传递,通常会以对象的形式传递也就是 payload是一个对象，可以再从对象中取出相关的信息 123456changeCount(state, payload) &#123; state.count = payload.count&#125;changeCount: function()&#123; this.$store.commit(&#x27;changeCount&#x27;, &#123;count: 0&#125;)&#125; Mutation提交风格 上面的通过 commit进行提交是种普通的方式 Vue还提供了另外一种风格,它是一个包含type属性的对象 12345678910addCount(count) &#123; // payload: 负载 // 1. 普通的提交封装 this.$store.commit(&quot;incrementCount&quot;, count) // 2. 特出的提交封装 this.$store.commit(&#123; type: &#x27;incrementCount&#x27;, count &#125;) &#125;, Mutation响应规则 Vuex的 store中的 state是响应式的,当 state中的数据发生改变时,Wue组件会自动更新 这就要求我们必须遵守一些vuex对应的规则: 提前在 store中初始化好所需的属性. 当给 state中的对象添加新属性时,使用下面的方式 方式一:使用 Vue. set(obj, newProp,123)方式二:用新对象给旧对象重新赋值 Mutation常量类型一概念 我们来考虑下面的问题 在 mutation中我们定义了很多事件类型(也就是其中的方法名称） 当我们的项目增大时,Wuex管理的状态越来越多,需要更新状态的情况越来越多,那么意味着 Mutation中的方法越来越多 方法过多,使用者需要花费大量的经历去记住这些方法甚至是多个文件间来回切换查看方法名称甚至如果不是复制的时候可能还会出现写铠的情况 Mutation同步函数 通常情况下,∨uex要求我们 Mutation中的方法必须是同步方法 主要的原因是当我们使用 devtools时,可以 devtools可以帮助我们捕捉 mutation的快照 但是如果是异步操作,那么 devtools将不能很好的追踪这个操作什么时候会被完成 2.6Action的基本定义我们强调,不要再 Mutation中进行异步操作口但是某些情况我们确实希望在vUex味进行些异步操作比如网络请求必然是异步的这个时候怎么处理呢口 Action类似于 Mutation,但是是用来代替 Mutation进行异步操作的 2.7. 认识ModuleModule是模块的意思,为什么在vuex中我们要使用模块呢?口Vue使用单一状态树那么也意味着很多状态都会交给Vuex来管理口当应用变得非常复杂时, store对象就有可能变得相当臃肿口为了解决这个问题Vuex允许我们将 store分割成模块( Module),而每个模块拥有自己的 Istate、 mutationsactions、 getters等■我们按照什么样的方式来组织模块呢?口我们来看左边的代码 12345678910111213141516171819202122const moduleA = &#123; state:&#123;&#125;, mutations:&#123;&#125;, actions:&#123;&#125;, getters:&#123;&#125;,&#125;const moduleB = &#123; state:&#123;&#125;, mutations:&#123;&#125;, actions:&#123;&#125;,&#125;const store = new Vuex.Store([ modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a //-&gt; moduleA 的状态store.state.b //-&gt; moduleB 的状态 ES6语法：(对象的解构) 1234567891011Const obj=&#123; name: &#x27;why&#x27; age: 18, height: 1.88&#125;// const name = obj.name;// const name = obj.name;// const name = obj.name;const &#123;name, age, height&#125; = obj;console.log(name); Actions的写法■ actions的写法呢?接收一个 context参数对象口局部状态通过 context.state暴露出来,根节点状态则为 context.rootState. 123456789const moduleA = &#123;actions: &#123; incrementIfoddOnRootSum (&#123; state, commit, rootState &#125;)&#123; if ((state.count + rootState.count)% 2 === 1) &#123; commit(&#x27;increment&#x27;) &#125; &#125; &#125;&#125; ■如果 getters中也需要使用全局的状态,可以接受更多的参数 1234567const moduleA = &#123; getters: &#123; sumwithRootCount (state, getters, rootState) &#123; return state. count root state. coun &#125; &#125;&#125; 三、网络请求封装3.1. 选择什么网络模块主要内容■常见的网络请求模块,以及优缺点对比JSONP的原理和封装口 JSONP原理回顾口 JSONP请求封装■ axIos的内容详解口认识 axIos网络模块口发送基本请求口 axIos创建实例口 axIos拦截器的使用 选择什么网络模块？vue中发送网络请求有非常多的方式那么在开发中如何选择呢？选择一: 传统的Ajax是基于 XmlHttpreqUesT(xhr)为什么不用它呢? 非常好解释,配置和调用方式等非常混乱 编码起来看起来就非常蛋疼 所以真实开发中很少直接使用,而是使用 Query-Ajax ■选择二:在前面的学习中,我们经常会使用 jQuery-Ajax 相对于传统的Aax非常好用 ■为什么不选择它呢? 首先,我们先明确一点:在vue的整个开发中都是不需要使用 jQuery了 那么,就意味着为了方便我们进行一个网络请求,特意引用一个 jQuery你觉得合理吗? jQuery的代码1w+行 vue的代码才1W+行 完全没有必要为了用网络请求就引用这个重量级的框架 选择三:官方在vue1.x的时候推出了vue- resource vue- resource的体积相对于 jQuery小很多 另外vue- resource是官方推出的.为什么不选择它呢? 在vue20退出后,ue作者就在 GitHubl的 ISsues中说明了去掉vue- resource,并且以后也不会再更新 那么意味着以后vue- reource不再支持新的版本时,也不会再继续更新和维护 对以后的项目开发和维护都存在很大的隐患 ■选择四:在说明不再继续更新和维护vue- resource的同时,作者还推荐了一个框架: axIos axIos有非常多的优点并且用起来也非常方便 3.2jsonp在前端开发中,我们种常见的网络请求方式就是丿SONP口使用 JSONP最主要的原因往往是为了解决跨域访问的问题.JSONPI的原理是什么呢?口 JSONP的核心在于通过&lt; script&gt;标签的src来帮助我们请求数据.口原因是我们的项目部署在 domain1com服务器上时,是不能直接访问 domain2com服务器上的资料的口这个时候我们利用&lt; script&gt;标签的src帮助我们去服务器请求到数据将数据当做个 javascript的函数来执行并且执行的过程中传入我们需要的json口所以封装 ason的核心就在于我们监听 window上的 Jsonp进行回调时的名称 3.3. 为什么选择axios ■功能特点口在浏览器中发送 XmlhTtpreqUesTs请求口在nodejs中发送http请求口支持 Promise APi口拦截请求和响应口转换请求和响应数据口等等 补充: axios名称的由来?个人理解没有具体的翻译.aXIOs: ajax l/onSystem axios请求方式■支持多种请求方式 axIos( config) axios request(config) axiosget(url, config]) axios delete(url config]) axios head(url config) axios post(url[ dataL config]) axios put(urIL dataL, config]) axios patch(url[, dataL, config]) 3.3. axios框架的基本使用12345678910111213141516171819202122232425262728293031323334npm install axios --savemain.jsimport axios from &#x27;axios&#x27;// axios(config)// config是一个对象类型axios (&#123; //url: &#x27;httpbin.org/&#x27; 这个可以用来测试 url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;, methods: &#x27;get&#x27;&#125;).then(res =&gt; &#123; console.log(res);&#125;)/*axios (&#123; //url: &#x27;httpbin.org/&#x27; 这个可以用来测试 url: &#x27;http://123.207.32.32:8000/home/data?type=sell&amp;page=3&#x27;,&#125;).then(res =&gt; &#123; console.log(res);&#125;)*/axios (&#123; //url: &#x27;httpbin.org/&#x27; 这个可以用来测试 url: &#x27;http://123.207.32.32:8000/home/data&#x27;, // 专门针对get请求的参数拼接 params: &#123; type: &#x27;pop&#x27;, page: 1 &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 3.4. axios发送并发请求 axios.all，可以放入多个请求的数组 axios.all([])返回的结果是一个数组，使用axios.spread可将数组[res1,res2]展开为res1,res2 123456789101112131415161718192021222324252627// 2. axios发送并发请求/*axios.all([axios(&#123; url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;,&#125;), axios(&#123; url: &#x27;http://123.207.32.32:8000/home/data&#x27;, params: &#123; type: &#x27;sell&#x27;, page: 5 &#125;&#125;)]).then(results =&gt; &#123; console.log(results); console.log(results[0]); console.log(results[1]);&#125;)*/axios.all([axios(&#123; url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;,&#125;), axios(&#123; url: &#x27;http://123.207.32.32:8000/home/data&#x27;, params: &#123; type: &#x27;sell&#x27;, page: 5 &#125;&#125;)]).then(axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2);&#125;)) 3.4. 全局配置 123456789101112131415axios.defaults.baseURL = &#x27;http://123.207.32.32:8000&#x27;axios.defaults.timeout = 5axios.all([axios(&#123; url: &#x27;/home/multidata&#x27;,&#125;), axios(&#123; url: &#x27;/home/data&#x27;, params: &#123; type: &#x27;sell&#x27;, page: 5000 &#125;&#125;)]).then(axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2);&#125;)) 3.4. 常见配置选项 3.5. 创建对应的axios实例1234567891011121314151617181920212223242526// 4. 创建对应的axios实例const instance = axios.create(&#123; baseUrl: &#x27;http://123.207.32.32:8000&#x27;, timeout: 5000&#125;)instance1(&#123; url: &#x27;/home/multidata&#x27;&#125;).then(res =&gt; &#123; console.log(res);&#125;)instance1(&#123; url: &#x27;/home/data&#x27;, params: &#123; type: &#x27;pop&#x27;, page: 1 &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;)const instence2 = axios.create(&#123; baseURL: &#x27;&#x27;, timeout: 10000&#125;) 3.6. 封装request模块123456789101112131415161718// 5. 封装request模块import &#123;request&#125; from &quot;./network/request&quot;;/*request(&#123; url: &#x27;/home/multidata&#x27;&#125;, res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;)*/request(&#123; url: &#x27;/home/multidata&#x27;&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) network -&gt; request.js 12345678910import axios from &#39;axios&#39;export function request(config) &#123; &#x2F;&#x2F; 1. 创建axios实例 const instance &#x3D; axios.create(&#123; baseUrl: &#39;http:&#x2F;&#x2F;123.207.32.32:8000&#39;, timeout: 5000 &#125;) &#x2F;&#x2F; 2. 发送真正的网络请求 return instance(config)&#125; 3.7. axios的拦截器 请求拦截的作用 响应拦截 123456789101112131415161718192021222324252627export function request(config) &#123; // 1. 创建axios实例 const instance = axios.create(&#123; baseUrl: &#x27;http://123.207.32.32:8000&#x27;, timeout: 5000 &#125;) // 2. axios的拦截器 instance.interceptors.request.use(config =&gt; &#123; // console.log(config); // 2.1 请求拦截的作用 // 1.比如config中的一些信息不符合服务器要求 // 2.比如每次发送网络请求时，都希望在界面中显示一个请求的图标 show // 3.某些网络请求（比如登陆（token）），必须携带一些特殊信息 return config &#125;, err =&gt; &#123; // console.log(err); &#125;) // 2.2 响应拦截 instance.interceptors.response.use(res =&gt; &#123; // console.log(res); return res.data &#125;), err =&gt; &#123; console.log(err); &#125; // 3. 发送真正的网络请求 return instance(config)&#125; 四、项目开发123git branch -M maingit remote add origin git@github.com:yzhou15/supermall.gitgit push -u origin main 4.1. 划分目录结构4.2. 引入CSS文件：root 伪类 获取根元素html 4.3. vue.config.js 和 editorconfig别名配置vue.config.js 12345678910111213module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; &#x27;assets&#x27;: &#x27;@/assets&#x27;, &#x27;common&#x27;: &#x27;@/common&#x27;, &#x27;components&#x27;: &#x27;@/components&#x27;, &#x27;network&#x27;: &#x27;@/network&#x27;, &#x27;views&#x27;: &#x27;@/views&#x27;, &#125; &#125; &#125;&#125; 4.4. 项目的横向划分：tabbar -&gt; 路由的映射关系以前网页服务端渲染用jsp 4.5. 首页开发 navbar的封装 网络数据的请求 轮播图 推荐信息 1234567// 函数调用-&gt; 压入函数栈（保存函数调用过程中的所有变量）// 函数调用结束 -&gt; 弹出函数栈（释放函数所有的变量）function text() &#123; const names = [&#x27;why&#x27;, &#x27;aaa&#x27;]&#125;test() 垃圾回收 vueui库：mint-ui/iview","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"vue生命周期","slug":"Vue生命周期","date":"2021-04-20T14:51:18.000Z","updated":"2021-08-08T08:26:29.745Z","comments":true,"path":"2021/04/20/Vue生命周期/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"生命周期：事物从诞生到消亡的整个过程 debug开发的版本 build:release稳定的版本 Vue生命周期：（钩子函数） new Vue会执行一系列操作，通过钩子回调函数call hook created：可以做网络请求 mounted vbom更新 destroyed","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"docker","slug":"docker","date":"2021-04-20T14:51:18.000Z","updated":"2021-08-08T08:26:29.759Z","comments":true,"path":"2021/04/20/docker/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/docker/","excerpt":"","text":"什么是 Docker ◆使用最广泛的开源容器引擎 ◆一种操作系统级的虚拟化技术 ◆依赖于 Linux内核特性：Namespace和 Groups个简单的应用程序打包工具 123456root@localhost -] docker run -i -t centos/bin/bashUnable to find image centos: latest locallyLatest: Pulling from Library/centos256b176beaff: Pull completeDigest: sha256: 5d9lc5535c41fd1bb48d4058la2c8b 53d38fc2eb26df774556b 53c 5a0bd4d44eStatus: Downloaded newer image for centos: latest","categories":[{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/tags/docker/"}]},{"title":"品优购","slug":"xiangmu","date":"2021-04-20T14:51:18.000Z","updated":"2021-08-08T08:26:29.794Z","comments":true,"path":"2021/04/20/xiangmu/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/xiangmu/","excerpt":"","text":"项目名称：品优购 项目描述：品优购是一个电商网站，主要完成PC端首页、列表页、注册页面的制作 开发工具：VScode、Photoshop(fw)、主流浏览器(以Chrome浏览器为主) 技术栈： 利用HTML5 + CSS3手动布局，大量使用H5新增标签和样式 采取结构与样式相分离，模块化开发 代码规范 模块化开发： 样式和结构重复出现，单独做成一个模块 例如common.css 重复使用、修改方便 项目名称：黑马面面布局开发 项目描述：移动端页面开发流程、掌握移动端常见布局思路 技术栈： 弹性盒子 + rem + LESS flex + rem + + flexible.js + LESS 最小适配设备为iphone5 320px 最大设配设备为iphone8plus","categories":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"}],"tags":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/tags/html-css/"}]},{"title":"外卖项目","slug":"外卖项目","date":"2021-04-20T14:51:18.000Z","updated":"2021-08-08T08:26:29.795Z","comments":true,"path":"2021/04/20/外卖项目/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"1.基于 Vue 的最新版本； 2.项目是关于外卖业务的前后台分离Web App，功能模块包含商家, 商品, 购物车, 用户管理等多个模块； 3.后台应用技术架构为: Node + Express + Mongodb + Mongoose； 4.前台应用技术架构为: vue + vuex + vue-router + webpack + ES6； 5.采用模块化、组件化、工程化的模式开发； 项目描述：一个外卖Web App(SPA)前后台分离项目，包括商家，商品，购物车，用户等多个子模块；使用Vue全家桶+ES6+Webpack等，采用模块化、组件化、工程化的模式开发 技术选型： 前台数据处理、交互、组件化： vue全家桶、技术栈： vue vue-router(路由) vuex(管理状态) mint-ui(ui组件库) vue-lazyload(懒家，实现图片惰加载) 滑动库： vue-scroller(插件) better-scroll 日期处理 swiper(滑动，做轮播) monent date-fns 前后台交互 mock数据：mockjs(模拟) 接口测试：postman ajax请求 vue-resource axios 模块化 ES6 babel 项目构建、工程化 webpack(项目构建) vue-cli(创建工程化项目) eslint(检查语法是否规范) css预编译器 stylus","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"heimamm","slug":"黑马面面移动页面布局","date":"2021-04-20T14:51:18.000Z","updated":"2021-08-08T08:26:29.795Z","comments":true,"path":"2021/04/20/黑马面面移动页面布局/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/","excerpt":"","text":"黑马面面布局开发一、目的 了解移动端页面开发流程 掌握移动端常见布局思路 1.1 技术方案121. 弹性盒子 + rem + LESS 4. 最小适配设备为iphone5 320px 最大设配设备为iphone8plus(ipad能正常查看内容即可) 1.2 代码规范123456789101. 类名语义化,尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线“_” 连接2. 类名嵌套层次尽量不超过三层3. 尽量避免直接使用元素选择器4. 属性书写顺序 布局定位属性：display / position / float / clear / visibility / overflow 尺寸属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow5. 避免使用id选择器6. 避免使用通配符*和!important 1.2 目录规范12345项目文件夹：heimamm 样式文件夹：css 业务类图片文件夹：images 样式类图片文件夹： icons 字体类文件夹： fonts 二、流程开发2.1 蓝湖/摹客协作平台 UI设计师 psd效果图完成后，会上传到蓝湖//摹客里面，同时会拉前端工程师进入开发 大部分情况下，UI会把图片按照前端设计要求给切好 UI设计师 上传蓝湖到或者/摹客（了解） 12345671. /摹客官网地址： https://www.mockplus.cn/ 注册一个账号2. 下载moke ps插件 3. PS 安装/摹客/蓝湖插件3. 打开PS/摹客/蓝湖插件4. 上传（需要切图，需要先标注切图）5. 查看项目6. 邀请成员进入（分享按钮，链接地址） 前端设计师可以直接/摹客/蓝湖测量取值 2.2 适配方案 flex 布局 百分比布局 rem布局 vw/vh布局 响应式布局 本次案例 flex + rem + + flexible.js + LESS 2.3 初始化文件 引入 normalize.css less 中 初始化body样式 约束范围 ~~~css@media screen and (min-width: 750px) { html { font-size: 37.5px !important; }} 123456789101112#### 2.4 布局模块1. 头部模块 .header 高度为 80px 2. nav 模块制作 多用 flex3. 充电学习 阴影 ~~~css box-shadow: 0 0px 10px rgba(0, 0, 0, 0.1) 2.5 swiper 插件使用官网地址：https://www.swiper.com.cn/ 下载需要的css和js文件 html页面中 引入相关文件 官网找到类似案例，复制html结构，css样式 js 语法 根据需求定制修改模块 2.6 图标字体上传下载上传步骤： 让UI美工准备好 图标字体（必须是svg格式） 点上传按钮（保留颜色并提交） 生成之后加入购物车即可 点击下载 — 下载代码 小技巧： 如何批量下载全部字体图标呢？ 12345var span = document.querySelectorAll(&#x27;.icon-cover&#x27;);for (var i = 0, len = span.length; i &lt; len; i++) &#123; console.log(span[i].querySelector(&#x27;span&#x27;).click());&#125; 2.7 上传码云并发布部署静态网站准备工作： 需要下载git软件 需要码云注册账号 git 可以把我们的本地网站提交上传到远程仓库（码云 gitee）里面 类似以前的 ftp 码云 就是远程仓库， 类似服务器 码云创建新的仓库。 heimamm 利用git 提交 把本地网站提交到 码云新建的仓库里面 在网站根目录右键– Git Bash Here 如果是第一次利用git提交，请配置好全局选项 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;你的邮箱地址&quot; 初始化仓库 1git init 把本地文件放到暂存区 1git add . 把本地文件放到本地仓库里面 1git commit -m &#x27;提交黑马面面网站&#x27; 链接远程仓库 1git remote add origin 你新建的仓库地址 把本地仓库的文件推送到远程仓库 push 1git push -u origin master 码云部署发布静态网站 在当前仓库中，点击 “服务” 菜单 选择 Gitee Pages 选择 “启动” 按钮 稍等之后，会拿到地址，就可以利用这个地址来预览网页了 当然你也可以利用 草料二维码 生成二维码 https://cli.im/ 最后： 如果提交网站，你不愿意用git 提交， 可以直接找到仓库，里面有文件，选择上传本地文件即可。 但是，1个小时内，只能上传 20个以内的文件， 前端人员，git必备技能","categories":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"}],"tags":[{"name":"flex rem less","slug":"flex-rem-less","permalink":"https://yzhou15.gitee.io/tags/flex-rem-less/"}]},{"title":"next配置","slug":"next配置","date":"2021-04-10T04:45:10.000Z","updated":"2021-08-08T08:26:29.763Z","comments":true,"path":"2021/04/10/next配置/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/10/next%E9%85%8D%E7%BD%AE/","excerpt":"","text":"转载自：https://blog.csdn.net/qq_35396510/article/details/105953460 hexo 主题 next7.8 版本配置美化 转载自：https://www.jianshu.com/p/6f9e732b1f9f Hexo的Next主题详细配置 72017.11.29 16:21:02字数 1,902阅读 53,047 经过一番不懈的努力，我们终于按照Hexo免费搭建一个属于自己的博客搭建好了一个属于自己的博客，并且还安装了一个Next主题，但是我们的博客一开始还是很简陋的，我们需要把她装修一下。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为**站点配置文件*， 后者称为主题配置文件***。 以下所有终端执行的命令都在你的Hexo根目录下 1、基本信息配置 基本信息包括：博客标题、作者、描述、语言等等。 打开 *站点配置文件* ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 *站点配置文件* 中的其他配置可参考站点配置 2、菜单设置 菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 *主题配置文件* 找到Menu Settings 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了；关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 3、Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 *主题配置文件* 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格。 4、侧栏设置 侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等 打开 *主题配置文件* 找到sidebar字段 12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 5、头像设置打开 *主题配置文件* 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 6、设置RSS1、先安装 hexo-generator-feed 插件 1$ npm install hexo-generator-feed --save 2、打开 *站点配置文件* 找到Extensions在下面添加 123456789# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &#x27; &#x27; 3、打开 *主题配置文件* 找到rss，设置为 1rss: &#x2F;atom.xml 7、添加分类模块1、新建一个分类页面 1$ hexo new page categories 2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类3、打开 *主题配置文件* 找到menu，将categorcies取消注释4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： 12title: 分类测试文章标题categories: 分类名 8、添加标签模块1、新建一个标签页面 1$ hexo new page tags 2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签3、打开 *主题配置文件* 找到menu，将tags取消注释4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子： 12345title: 标签测试文章标题tags: - 标签1 - 标签2 ... 9、添加关于模块1、新建一个关于页面 1$ hexo new page about 2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 *主题配置文件* 找到menu，将about取消注释 10、添加搜索功能1、安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 2、打开 *站点配置文件* 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 *主题配置文件* 找到Local search，将enable设置为true 11、添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 12、修改文章内链接文本样式 效果图 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 13、设置网站缩略图标 从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行。 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 *主题配置文件* 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 14、设置文章字体的颜色、大小 效果图 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color=&quot;#FF0000&quot;&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 15、设置文字居中设置方法： 1&lt;center&gt;这一行需要居中&lt;/center&gt; 注意：简书中此方法无效 16、添加评论系统 目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 *主题配置文件* 找到youyan_uid将值设置为上面的uid就可以了 17、添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&#x27;display:none&#x27;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&#x27;display:none&#x27;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕。 18、去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开***主题配置文件***，找到 将number改为false即可 18、更多1、还有其他更多的主题配置，请查看主题配置2、还有其他更多的插件，请查看Hexo插件","categories":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"}]},{"title":"vueDay4","slug":"vueDay4","date":"2021-03-20T14:51:18.000Z","updated":"2021-08-08T08:26:29.770Z","comments":true,"path":"2021/03/20/vueDay4/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/20/vueDay4/","excerpt":"","text":"一、Vue CLI 安装脚手架遇到问题可以尝试清空这个文件夹 1C:\\Users\\yzhou\\AppData\\Roaming\\npm-cache parse解析 1.1. runtime+compiler和runtime-only的区别 **runtime+compile:**template -&gt; ast -&gt; render -&gt; virtual dom -&gt; 真实DOM runtime-only: virtual dom -&gt; 真实DOM 性能更高 代码量更少 箭头函数render: (h) =&gt; h, -&gt;本质上是creatElement ESlint render -&gt; vdom -&gt; UI 1.2. 认识Vue CLI3vue2.5.21 -&gt; vue2.x -&gt; flow-type(facebook) vue3.x -&gt; TypeScript(microsoft) webpack4 （v2webpack3） 设计原则0配置 vue ui 可视化配置，更加人性化 移除static，新增public，将index.html移动到public中 preset配置 feature特性 rc-&gt;run command vcs-&gt;version control system(版本控制git/svn) 如何通过CLI3创建项目 CLI3的目录结构 vue配置文件的查看和修改 vue ui 去找隐藏的配置文件 自定义vue.config.js 二、Vue-Router2.1 认识路由 后端渲染\\后端渲染 前后端分离 SPA\\前端路由 路由（routing）：通过互联的网络把信息从源地址传输到目的地址的活动 映射关系：ip地址：mac地址 2.1.1 前端渲染和后端渲染：历史阶段： 后端渲染阶段后端路由阶段■早期的网站开发整个HTML页面是由服务器来渲染的口服务器直接生产渲染好对应的HTML页面,返回给客户端进行展示■但是,一个网站,这么多页面服务器如何处理呢?口一个页面有自己对应的网址,也就是URL口URL会发送到服务器,服务器会通过正则对该URL进行匹配并且最后交给一个 Controller进行处理口 Controller进行各种处理,最终生成HTML或者数据,返回给前端口这就完成了一个1O操作■上面的这种操作就是后端路由.口当我们页面中需要请求不同的路径内容时,交给服务器来进行处理,服务器渲染好整个页面,并且将页面返回给客户顿口这种情况下渲染好的页面,不需要单独加载任何的s和cs,可以直接交给浏览器展示,这样也有利于SEO的优化后端路由的缺点口一种情况是整个页面的模块由后端人员来编写和维护的口另一种情况是前端开发人员如果要开发页面,需要通过PHP和Java等语言来编写页面代码.口而且通常情况下HTML代码和数据以及对应的逻辑会混在一起,编写和维护都是非常糟糕的事情. 前后端分离阶段口随着Ajax的出现有了前后端分离的开发模式口后端只提供AP来返回数据,前端通过Ajax获取数据并且可以通过 JavaScript将数据渲染到页面中口这样做最大的优点就是前后端责任的清晰,后端专注于数据上前端专注于交互和可视化上.口并且当移动端(ioS/ Android)出现后,后端不需要进行任何处理依然使用之前的一套API即可.口目前很多的网站依然采用这种模式开发 前端渲染阶段 ■单页面富应用阶段:口其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由口也就是前端来维护一套路由规则. 2.1.2.前端路由中url和组件的关系 2.1.3. 前端路由的核心 改变URL,但是页画不进行整体的刷新 改变URL的hash 1location.hash = &#x27;aaa&#x27; HTML5的history模式 1history.pushState(&#123;&#125;, &#x27;&#x27;, &#x27;home&#x27;) href-&gt;hyper reference 数据结构： 栈结构：先进后出 push入栈 HTML5的history模式：replaceState 1history.replaceState(&#123;&#125;, &#x27;&#x27;, &#x27;home&#x27;) history.go() 因为 history. back0等价于 history. go(-1)history forward0则等价于 history. go(1)这三个接口等同于浏览器界面的前进后退。 三大框架路由实现： Angular-&gt;ngRouter React-&gt;ReactRouter Vue-&gt;vue-router 2.2. vue-router基本使用2.2.1. 安装步骤 安装 1npm install vue-router --save 在模块化工程中使用,搭建路由框架 导入路由对象，并且调用Vue.use(VueRouter) 创建路由实例，并且传入路由映射配置 在Vue实例中挂载创建的路由实例 router=&gt;index.js 1234567891011121314151617181920// 配置路由相关信息import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import HelloWorld from &#x27;@/components/HelloWorld&#x27;// 1. 通过VUe.use(插件)，安装插件Vue.use(Router)// 2. 创建VueRouter对象// 3. 将router对象传入到Vue实例export default new Router(&#123; // 配置路由和组件之间的应用关系 routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;HelloWorld&#x27;, component: HelloWorld &#125; ]&#125;) main.js中挂载 1import router from &#x27;./router&#x27; 配置路由映射关系步骤： 创建路由组件 配置路由映射：组件和路径映射关系 使用路由：通过和 router=&gt;index.js 123456789101112131415import Home from &#x27;../components/Home&#x27;import About from &quot;../components/About&quot;export default new Router(&#123; // 配置路由和组件之间的映射关系 routes: [ &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, component: About &#125; ]&#125;) App.vue中 123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; // 渲染成a标签，改变hash &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; // 栈位，动态渲染不同的组件 &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 2.2.2. 配置默认路径123456789export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, // redirect重定向 redirect: &#x27;/home&#x27; &#125; ]&#125;) 2.2.3. 添加history在index.js中可以消除地址栏中‘#’123export default new Router(&#123; mode: &#x27;history&#x27;&#125;) 2.2.4. router-link补充 tag: tag可以指定渲染成什么组件,比如下面的代码会渲染成一个,而不是 1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;首页&lt;/router-link&gt; replace: 不会留下history记录，后退键不能返回到上一个界面中 1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt; active-class:修改默认的类名称 123export default new Router(&#123; linkActiveClass: &#x27;active&#x27;&#125;) 2.2.5. 路由代码跳转App.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt; &lt;button @click=&quot;aboutClick&quot;&gt;关于&lt;/button&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, methods: &#123; homeClick() &#123; // 路由代码跳转 // this.$router.push(&#x27;/home&#x27;) this.$router.replace(&#x27;/home&#x27;) console.log(&#x27;homeClick&#x27;); &#125;, aboutClick() &#123; this.$router.push(&#x27;/about&#x27;) console.log(&#x27;aboutClick&#x27;); &#125; &#125;&#125;&lt;/script&gt; 2.2.6. 动态路由的使用 /user/:id params-&gt;parameters参数 this.$route.params.id 2.2.7. 认识路由的懒加载-打包文件的解析用到时再加载 12345678懒加载的方式■方式一:结合Wue的异步组件和 Webpack的代码分析const Home resolve =&gt;i require ensure([ ./components /Home. vue],O=&gt;I resolve(require (./components/Home. vue ))))■方式二:AMD写法const About resolve = require([ ./components/About. vue&#x27;l, resolve)方式三:在ES6中我们可以有更加简单的写法来组织vue异步组件和 Webpack的代码分割const Home = ON&gt; import(./components/Home. vue &#x27;) 2.3. vue-router嵌套路由 children:[] index.html 123456789101112131415161718routes: [&#123; path: &#x27;/home&#x27;, component: Home, children: [ &#123; path: &#x27;&#x27;, redirect: &#x27;news&#x27; &#125;, &#123; path: &#x27;news&#x27;, component: HomeNews &#125;, &#123; path: &#x27;message&#x27;, component: HomeMessage &#125;] 2.4. vue-router参数传递profile -&gt; 档案（用于‘我的’的用户界面） 准备工作： 创建新的组件Profile.vue 配置路由映射 添加跳转的 传递参数类型： params的类型 配置动态路由：/router/:id 传递的方式：在path后面跟上对应的值 传递后形成的路径：/router/123,/router/abc query 配置路由/router普通配置 传递的方式：对象中使用query的key作为传递方式 传递后形成的路径：/router?id=123, /router?id=abc URL: 协议://主机:端口/路径?查询#片段哈希值 scheme://localhost:portt/path?query#fragment 所有的组件都继承着vue类的原型 2.5. vue-router导航守卫 全局导航守卫 路由独享守卫 组件类守卫 生命周期函数： init lifecycle beforeCreates如果有的话回调 init 响应式等其他东西 created(){}-&gt;创建组件时 挂载el、template beforemounted 创建vm替换el mounter(){} -&gt;template挂载到组件时 做响应式检测回调beforeUpdate 重新渲染vdom,然后patch打补丁 updated(){} -&gt;界面刷新时 beforeDestory后做一些回收的操作 destroyed(){}-&gt;销毁 meta：元数据-&gt;描述数据的数据 metaclass元类可以创建类对象，接着创建实例对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 配置路由相关信息import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;// import Home from &#x27;../components/Home&#x27;// import About from &quot;../components/About&quot;const Home = () =&gt; import(&#x27;../components/Home&#x27;)const HomeNews = () =&gt; import(&#x27;../components/HomeNews&#x27;)const HomeMessage = () =&gt; import(&#x27;../components/HomeMessage&#x27;)const About = () =&gt; import(&#x27;../components/About&#x27;)const User = () =&gt; import(&#x27;../components/User&#x27;)const Profile = () =&gt; import(&#x27;../components/Profile&#x27;)// 1. 通过VUe.use(插件)，安装插件// 2. 创建VueRouter对象Vue.use(Router)// 配置路由和组件之间的映射关系const routes = [ &#123; path: &#x27;&#x27;, // redirect重定向 redirect: &#x27;/home&#x27; &#125;, &#123; path: &#x27;/home&#x27;, component: Home, meta: &#123; title: &#x27;首页&#x27; &#125;, children: [ &#123; path: &#x27;&#x27;, redirect: &#x27;news&#x27; &#125;, &#123; path: &#x27;news&#x27;, component: HomeNews &#125;, &#123; path: &#x27;message&#x27;, component: HomeMessage &#125; ] &#125;, &#123; path: &#x27;/about&#x27;, component: About, meta: &#123; title: &#x27;关于&#x27; &#125;, &#125;, &#123; path: &#x27;/user/:userId&#x27;, component: User, meta: &#123; title: &#x27;用户&#x27; &#125;, &#125;, &#123; path: &#x27;/profile&#x27;, component: Profile, meta: &#123; title: &#x27;档案&#x27; &#125;, &#125;]// 3. 将router对象传入到Vue实例const router = new Router(&#123; routes, mode: &#x27;history&#x27;, linkActiveClass: &#x27;active&#x27;&#125;)// 导航守卫// 全局导航// 前置守卫(guard)router.beforeEach((to, from, next) =&gt; &#123;// 从from跳转到to document.title = to.matched[0].meta.title console.log(&#x27;++++&#x27;) next()&#125;)// 后置钩子(hook)router.afterEach((to, from) =&gt; &#123; console.log(&#x27;----&#x27;)&#125;)export default router 2.6. keep-alive keep-alie是Wue内置的一个组件,可以使被包含的组件保留状态,或避免重新渲染 它们有两个非常重要的属性: include-字符串或正则表达,只有匹配的组件会被缓存 exclude-字符串或正则表达式,任问匹配的组件都不会被缓存 router-view也是一个组件,如果直接被包在keep-aive里面,所有路径匹配到的视图组件都会被缓存 在keep-alive下才能使用activated/deactived这两个函数 (不常用)首页中使用path属性记录离开时的路径，在beforeRouteLeave中记录 App.vue 123&lt;keep-alive&gt; &lt;router-view&#x2F;&gt;&lt;&#x2F;keep-alive&gt; Home.vue 1234567891011121314151617181920212223export default &#123; name: &quot;Home&quot;, data()&#123; return &#123; message: &#39;你好啊&#39; &#125; &#125;, created() &#123; console.log(&#39;home created&#39;); &#125;, destroyed() &#123; console.log(&#39;home destroyed&#39;) &#125;, activated()&#123; &#x2F;&#x2F; console.log(&#39;activated&#39;) this.$router.push(this.path); &#125;, beforeRouteLeave(to, from, next) &#123; console.log(this.$router.path); this.path &#x3D; this.$route.path; next() &#125;&#125; 2.9. TabBar的封装过程 如果在下方有一个单独的 TabBar组件,你如何封装 自定义 Tabbar组件,在APP中使用 让 TabBar出于底部,并且设置相关的样式 TabBar中显示的内容由外界决定 定义插槽 fex布局平分 TabBar 自定义 TabBarlten,可以传入图片和文字 定义 TabBarltem,并且定义两个插槽:图片、文字。 给两个插槽外层包装div,用于设置样式 填充插槽,实现底部 TabBar的效果 传入高亮图片 定义另外一个插槽,插入 active-icon的数据 定义一个变量 inActive,通过 v-show来决定是否显示对应的icon TabBarlten绑定路由数据 安装路由 T npm install vue-router-save 完成 router/ ndex jsf的内容,以及创建对应的组件 main s中注册 router APP中加入&lt; router-view&gt;组件 点击item跳转到对应路由,并且动态决定 inActive 监听tem的点击,通过this. Router. replace0替换路由路径 通过this. Route path. indexof( this link!==-1来判断是否是 active 动态计算 active样式 封装新的计算属性: this inActive? color:’red}:","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"代码规范","slug":"品优购代码规范","date":"2021-03-19T16:00:00.000Z","updated":"2021-08-08T08:26:29.794Z","comments":true,"path":"2021/03/20/品优购代码规范/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/20/%E5%93%81%E4%BC%98%E8%B4%AD%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"1. 概述欢迎使用品优购代码规范， 这个是我借鉴京东前端代码规范，组织的品优购内部规范。旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范， 以下规范是团队基本约定的内容，必须严格遵循。 HTML规范基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。 图片规范了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。 CSS规范统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。 命名规范从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。 2. HTML 规范DOCTYPE 声明HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明： 1&lt;!DOCTYPE html&gt; HTML5标准模版 12345678910&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML5标准模版&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 页面语言lang推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 1&lt;html lang&#x3D;&quot;zh-CN&quot;&gt; 更多地区语言参考： 1234zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡)zh-HK 中文 (繁体, 香港) 对应 cmn-Hant-HK 普通话 (繁体, 香港)zh-MO 中文 (繁体, 澳门) 对应 cmn-Hant-MO 普通话 (繁体, 澳门)zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾) charset 字符集合一般情况下统一使用 “UTF-8” 编码 1&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; 由于历史原因，有些业务可能会使用 “GBK” 编码 1&lt;meta charset&#x3D;&quot;GBK&quot;&gt; 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF对UTF-8的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。 书写风格HTML代码大小写HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： 1&lt;div class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt; 不推荐： 123&lt;div class&#x3D;&quot;DEMO&quot;&gt;&lt;&#x2F;div&gt; &lt;DIV CLASS&#x3D;&quot;DEMO&quot;&gt;&lt;&#x2F;DIV&gt; 类型属性不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含 推荐： 12&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&quot; &gt;&lt;script src&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt; 不推荐： 12&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&quot; &gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&quot; &gt;&lt;&#x2F;script&gt; 元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： 12&lt;input type&#x3D;&quot;text&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;name&quot; checked&#x3D;&quot;checked&quot; &gt; 不推荐： 123&lt;input type&#x3D;text&gt; &lt;input type&#x3D;&#39;text&#39;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;name&quot; checked &gt; 特殊字符引用文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。 在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 推荐： 1&lt;a href&#x3D;&quot;#&quot;&gt;more&gt;&gt;&lt;&#x2F;a&gt; 不推荐： 1&lt;a href&#x3D;&quot;#&quot;&gt;more&gt;&gt;&lt;&#x2F;a&gt; 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 123&lt;div class&#x3D;&quot;jdc&quot;&gt; &lt;a href&#x3D;&quot;#&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt; 代码嵌套元素嵌套规范，每个块状元素独立一行，内联元素可选 推荐： 12345&lt;div&gt; &lt;h1&gt;&lt;&#x2F;h1&gt; &lt;p&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; 不推荐： 1234567&lt;div&gt; &lt;h1&gt;&lt;&#x2F;h1&gt;&lt;p&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;p&gt; &lt;span&gt;&lt;&#x2F;span&gt; &lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; 段落元素与标题元素只能嵌套内联元素 推荐： 12&lt;h1&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;h1&gt;&lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; 不推荐： 12&lt;h1&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;h1&gt;&lt;p&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;p&gt; 3. 图片规范内容图内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大 PC平台单张的图片的大小不应大于 200KB。 背景图背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片 PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式 4. CSS规范代码格式化样式书写一般有两种：一种是紧凑格式 (Compact) 1.jdc&#123; display: block;width: 50px;&#125; 一种是展开格式（Expanded） 1234.jdc &#123; display: block; width: 50px;&#125; 团队约定 统一使用展开格式书写样式 代码大小写样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。 123456789&#x2F;* 推荐 *&#x2F;.jdc&#123; display:block;&#125; &#x2F;* 不推荐 *&#x2F;.JDC&#123; DISPLAY:BLOCK;&#125; 选择器 尽量少用通用选择器 * 不使用 ID 选择器 不使用无具体语义定义的标签选择器 123456789/* 推荐 */.jdc &#123;&#125;.jdc li &#123;&#125;.jdc li p&#123;&#125;/* 不推荐 */*&#123;&#125;#jdc &#123;&#125;.jdc div&#123;&#125; 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 1234.jdc &#123; width: 100%; height: 100%;&#125; 分号每个属性声明末尾都要加分号； 1234.jdc &#123; width: 100%; height: 100%;&#125; 代码易读性左括号与类名之间一个空格，冒号与属性值之间一个空格 推荐： 123.jdc &#123; width: 100%; &#125; 不推荐： 123.jdc&#123; width:100%;&#125; 逗号分隔的取值，逗号之后一个空格 推荐： 123.jdc &#123; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;&#125; 不推荐： 123.jdc &#123; box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;&#125; 为单个css选择器或新申明开启新行 推荐： 12345678.jdc, .jdc_logo, .jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 不推荐： 12345.jdc,jdc_logo,.jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0 推荐： 123.jdc &#123; color: rgba(255,255,255,.5);&#125; 不推荐： 123.jdc &#123; color: rgba( 255, 255, 255, 0.5 );&#125; 属性值十六进制数值能用简写的尽量用简写 推荐： 123.jdc &#123; color: #fff;&#125; 不推荐： 123.jdc &#123; color: #ffffff;&#125; 不要为 0 指明单位 推荐： 123.jdc &#123; margin: 0 10px;&#125; 不推荐： 123.jdc &#123; margin: 0px 10px;&#125; 属性值引号css属性值需要用到引号时，统一使用单引号 123456789/* 推荐 */.jdc &#123; font-family: &#x27;Hiragino Sans GB&#x27;;&#125;/* 不推荐 */.jdc &#123; font-family: &quot;Hiragino Sans GB&quot;;&#125; 属性书写顺序建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, &#x27;Helvetica Neue&#x27;, Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; mozilla官方属性顺序推荐 命名规范由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。 目录命名 项目文件夹：shoping 样式文件夹：css 脚本文件夹：js 样式类图片文件夹：img 产品类图片文件夹： upload 字体类文件夹： fonts ClassName命名ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接 .nav_top 常用命名推荐注意：ad、banner、gg、guanggao 等有机会和广告挂勾的不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此 1&lt;div class&#x3D;&quot;ad&quot;&gt;&lt;&#x2F;div&gt; 这种广告的英文或拼音类名不应该出现 另外，敏感不和谐字眼也不应该出现，如： 1234567&lt;div class&#x3D;&quot;fuck&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;jer&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;sm&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;gcd&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;ass&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;KMT&quot;&gt;&lt;&#x2F;div&gt; ... ClassName 含义 about 关于 account 账户 arrow 箭头图标 article 文章 aside 边栏 audio 音频 avatar 头像 bg,background 背景 bar 栏（工具类） branding 品牌化 crumb,breadcrumbs 面包屑 btn,button 按钮 caption 标题，说明 category 分类 chart 图表 clearfix 清除浮动 close 关闭 col,column 列 comment 评论 community 社区 container 容器 content 内容 copyright 版权 current 当前态，选中态 default 默认 description 描述 details 细节 disabled 不可用 entry 文章，博文 error 错误 even 偶数，常用于多行列表或表格中 fail 失败（提示） feature 专题 fewer 收起 field 用于表单的输入区域 figure 图 filter 筛选 first 第一个，常用于列表中 footer 页脚 forum 论坛 gallery 画廊 group 模块，清除浮动 header 页头 help 帮助 hide 隐藏 hightlight 高亮 home 主页 icon 图标 info,information 信息 last 最后一个，常用于列表中 links 链接 login 登录 logout 退出 logo 标志 main 主体 menu 菜单 meta 作者、更新时间等信息栏，一般位于标题之下 module 模块 more 更多（展开） msg,message 消息 nav,navigation 导航 next 下一页 nub 小块 odd 奇数，常用于多行列表或表格中 off 鼠标离开 on 鼠标移过 output 输出 pagination 分页 pop,popup 弹窗 preview 预览 previous 上一页 primary 主要 progress 进度条 promotion 促销 rcommd,recommendations 推荐 reg,register 注册 save 保存 search 搜索 secondary 次要 section 区块 selected 已选 share 分享 show 显示 sidebar 边栏，侧栏 slide 幻灯片，图片切换 sort 排序 sub 次级的，子级的 submit 提交 subscribe 订阅 subtitle 副标题 success 成功（提示） summary 摘要 tab 标签页 table 表格 txt,text 文本 thumbnail 缩略图 time 时间 tips 提示 title 标题 video 视频 wrap 容器，包，一般用于最外层 wrapper 容器，包，一般用于最外层","categories":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"}],"tags":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/tags/html-css/"}]},{"title":"SpringMVC07-Ajax","slug":"SpringMVC07 Ajax","date":"2021-03-06T08:00:00.000Z","updated":"2021-08-08T08:26:29.744Z","comments":true,"path":"2021/03/06/SpringMVC07 Ajax/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/06/SpringMVC07%20Ajax/","excerpt":"","text":"[转发] Ajax研究 简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang&#x3D;&quot;en&quot;&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;kuangshen&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.onload &#x3D; function()&#123; var myDate &#x3D; new Date(); document.getElementById(&#39;currentTime&#39;).innerText &#x3D; myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl &#x3D; document.getElementById(&#39;url&#39;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src &#x3D; targetUrl; &#125;&lt;&#x2F;script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id&#x3D;&quot;currentTime&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; &lt;p&gt; &lt;input id&#x3D;&quot;url&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;LoadPage()&quot;&gt; &lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;&#x2F;h3&gt; &lt;iframe id&#x3D;&quot;iframePosition&quot; style&#x3D;&quot;width: 100%;height: 500px;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 123456789101112131415161718192021jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 123456789101112131415161718192021222324252627&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt; &lt;mvc:default-servlet-handler &#x2F;&gt; &lt;mvc:annotation-driven &#x2F;&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt; &lt;!-- 后缀 --&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 2、编写一个AjaxController 12345678910111213@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;&#x2F;a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 12&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt; 4、编写index.jsp测试 1234567891011121314151617181920212223242526&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;%--&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;--%&gt; &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a1&quot;, data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; &#125;); &#125; &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;txtName&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现 实体类user 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 我们来获取一个集合对象，展示到前端页面 12345678@RequestMapping(&quot;&#x2F;a2&quot;)public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;(); list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;)); return list; &#x2F;&#x2F;由于@RestController注解，将list转成json格式返回&#125; 前端页面 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;获取数据&quot;&#x2F;&gt;&lt;table width&#x3D;&quot;80%&quot; align&#x3D;&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;年龄&lt;&#x2F;td&gt; &lt;td&gt;性别&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tbody id&#x3D;&quot;content&quot;&gt; &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; $.post(&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a2&quot;,function (data) &#123; console.log(data) var html&#x3D;&quot;&quot;; for (var i &#x3D; 0; i &lt;data.length ; i++) &#123; html+&#x3D; &quot;&lt;tr&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;&#x2F;tr&gt;&quot; &#125; $(&quot;#content&quot;).html(html); &#125;); &#125;) &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果 我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller 1234567891011121314151617181920@RequestMapping(&quot;&#x2F;a3&quot;)public String ajax3(String name,String pwd)&#123; String msg &#x3D; &quot;&quot;; &#x2F;&#x2F;模拟数据库中存在数据 if (name!&#x3D;null)&#123; if (&quot;admin&quot;.equals(name))&#123; msg &#x3D; &quot;OK&quot;; &#125;else &#123; msg &#x3D; &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!&#x3D;null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg &#x3D; &quot;OK&quot;; &#125;else &#123; msg &#x3D; &quot;密码输入有误&quot;; &#125; &#125; return msg; &#x2F;&#x2F;由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;, data:&#123;&#39;name&#39;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;, data:&#123;&#39;pwd&#39;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt; &lt;span id&#x3D;&quot;userInfo&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;p&gt; 密码:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;pwd&quot; onblur&#x3D;&quot;a2()&quot;&#x2F;&gt; &lt;span id&#x3D;&quot;pwdInfo&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 【记得处理json乱码问题】 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;&#x2F;title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;&#x2F;style&gt; &lt;script&gt; &#x2F;&#x2F; 2.步骤二 &#x2F;&#x2F; 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul &#x3D; document.getElementById(&#39;ul&#39;); var html &#x3D; &#39;&#39;; &#x2F;&#x2F; 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; &#x2F;&#x2F; 隐藏掉的ul显示出来 Ul.style.display &#x3D; &#39;block&#39;; &#x2F;&#x2F; 搜索到的数据循环追加到li里 for(var i &#x3D; 0;i&lt;data.s.length;i++)&#123; html +&#x3D; &#39;&lt;li&gt;&#39;+data.s[i]+&#39;&lt;&#x2F;li&gt;&#39;; &#125; &#x2F;&#x2F; 循环的li写入ul Ul.innerHTML &#x3D; html; &#125; &#125; &#x2F;&#x2F; 1.步骤一 window.onload &#x3D; function()&#123; &#x2F;&#x2F; 获取输入框和ul var Q &#x3D; document.getElementById(&#39;q&#39;); var Ul &#x3D; document.getElementById(&#39;ul&#39;); &#x2F;&#x2F; 事件鼠标抬起时候 Q.onkeyup &#x3D; function()&#123; &#x2F;&#x2F; 如果输入框不等于空 if (this.value !&#x3D; &#39;&#39;) &#123; &#x2F;&#x2F; ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ &#x2F;&#x2F; 创建标签 var script &#x3D; document.createElement(&#39;script&#39;); &#x2F;&#x2F;给定要跨域的地址 赋值给src &#x2F;&#x2F;这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;5a1Fazu8AA54nxGko9WTAnF6hhy&#x2F;su?wd&#x3D;&#39;+this.value+&#39;&amp;cb&#x3D;demo&#39;; &#x2F;&#x2F; 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;q&quot; &#x2F;&gt;&lt;ul id&#x3D;&quot;ul&quot;&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Ajax在我们开发中十分重要，一定要学会使用！ end","categories":[{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/tags/ajax/"}]},{"title":"hexo使用技巧","slug":"hexo使用技巧","date":"2021-02-22T04:02:00.000Z","updated":"2021-08-08T08:26:29.762Z","comments":true,"path":"2021/02/22/hexo使用技巧/","link":"","permalink":"https://yzhou15.gitee.io/2021/02/22/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"切换主题报错： 12345&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125; 原因是hexo在5.0之后把swig给删除了需要自己手动安装 1npm i hexo-renderer-swig 转载自： https://inertia42.com/tips/tipsofhexo/ Hexo添加阅读全文标签在文章中添加&lt;!--more--&gt;标签可以使文章显示摘要和阅读全文按钮 Hexo中的MarkdownHexo支持GitHub Flavored Markdown语法 在首页隐藏某些特定文章该方法取自淡之梦的文章 在hexo安装目录下找到\\theme\\next\\layout\\index.swig,打开后会看到 1234567891011121314151617181920212223&#123;% extends &#39;_layout.swig&#39; %&#125;&#123;% import &#39;_macro&#x2F;post.swig&#39; as post_template %&#125;&#123;% import &#39;_macro&#x2F;sidebar.swig&#39; as sidebar_template %&#125;&#123;% block title %&#125;&#123;&#123; title &#125;&#125;&#123;% if theme.index_with_subtitle and subtitle %&#125; – &#123;&#123; subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;section id&#x3D;&quot;posts&quot; class&#x3D;&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;&#x2F;section&gt; &#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125;&#123;% endblock %&#125;&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125; 将其中的 123456789&#123;% block content %&#125; &lt;section id&#x3D;&quot;posts&quot; class&#x3D;&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;&#x2F;section&gt; &#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125;&#123;% endblock %&#125; 修改为 1234567891011&#123;% block content %&#125; &lt;section id&#x3D;&quot;posts&quot; class&#x3D;&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;% if post.notshow !&#x3D; true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;&#x2F;section&gt; &#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125;&#123;% endblock %&#125; 之后在博文头部使用notshow参数隐藏文章，加入notshow: true即可 1234title: titledate: 2018-06-12 11:45:43tags: notshow: true 在文章底部显示copyright信息以next主题为例，在主题配置文件中找到以下内容： 123post_copyright: enable: false license: &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;&quot; rel&#x3D;&quot;external nofollow&quot; target&#x3D;&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;&#x2F;a&gt; 将其中的false改为true，然后在博客配置文件中找到： 1url: http:&#x2F;&#x2F;yoursite.com 注意，如果你的博客使用了https加密，请把url改为https://yoursite.com将其中的地址改为自己的博客地址即可。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"}]},{"title":"python使用技巧","slug":"python使用技巧","date":"2021-02-21T16:00:00.000Z","updated":"2021-08-08T08:26:29.768Z","comments":true,"path":"2021/02/22/python使用技巧/","link":"","permalink":"https://yzhou15.gitee.io/2021/02/22/python%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"转载自： https://inertia42.com/tips/pythontips/ 在没有GUI的情况下使用matplotlib在vps上运行调用matplotlib的python脚本时需在import matplotlib.pyplot前加上 12import matplotlib as mplmpl.use(&#39;Agg&#39;) 一定要加在import matplotlib.pyplot前 给pip更换源将windows下的pip源换为清华的源 只需要在user文件夹下新建pip文件夹，并在其中新建pip.ini文件，并写入： 12[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 即可","categories":[{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/tags/python/"}]},{"title":"vueDay3","slug":"vueDay3","date":"2021-02-04T16:00:00.000Z","updated":"2021-08-08T08:26:29.769Z","comments":true,"path":"2021/02/05/vueDay3/","link":"","permalink":"https://yzhou15.gitee.io/2021/02/05/vueDay3/","excerpt":"","text":"一. 组件化开发1.1. 父子组件的访问 children/refs parent/root 1.2. slot的使用 基本使用 具名插槽 编译的作用域 作用域插槽 二. 前端模块化2.1 为什么要使用模块化 解决命名重复、代码不可复用性等问题 简单写js代码带来的问题 闭包引起代码不可复用 自己实现了简单的模块化 AMD/CMD/CommonJS 2.2 模块化规范 CommonJS AMD CMD ES6的Modules 2.3 模块化核心，ES6中模块化的使用 导出 CommonJS: model.export{} ES6: export{} 导入 CommonJS: let{} = require(‘’) ES6: import {…} from “…” 三. webpack3.1. 认识webpack 模块化打包工具 3.1.1. 和grunt/gulp的区别 grunt/gulp更强调任务处理，自动化任务管理工具 webpack更强调模块化 3.2. webpck的安装依赖环境 1234node -vnpm install webpack@3.6.0 -gcd 对应目录npm install webpack@3.6.0 --save-dev 3.3. webpack的起步 src(开发) dist-&gt;distribution(发布) webpack命令 1webpack ./src/main.js ./dist/bundle.js 3.4. webpck的配置 入口和出口的配置 webpack.config.js 配置时注意绝对路径path12345678910const path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./src/main.js&#x27;, output: &#123; // path: &#x27;./dist&#x27;, // 动态获取路径 path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27; &#125;,&#125; 12npm initnpm install package.jason 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;,&#125;, 1npm run build 局部安装webpack 开发时依赖 运行时依赖1npm install webpack@3.6.0 --save-dev 3.5. loaderd 使用 webpack官网查询：https://webpack.docschina.org/ 3.5.1 安装css-loader首先，你需要先安装 css-loader ： 12npm install --save-dev css-loader@2.0.2npm install --save-dev style-loader@0.23.1 然后把 loader 引用到你 webpack 的配置中。如下所示： file.js 1import css from &quot;file.css&quot;; webpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, ], &#125;,&#125;; 3.5.2. 安装less-loader安装 less 和 less-loader 1npm install less@3.9.0 less-loader@4.1.0 --save-dev 将该 loader 添加到 webpack 的配置中去 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/i, loader: [ // compiles Less to CSS &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;, ], &#125;, ], &#125;,&#125;; 3.5.3 安装图片文件url-loader首先，你需要安装 url-loader： 1npm install url-loader@1.1.2 --save-dev url-loader 功能类似于 file-loader, 但是在文件大小（单位为字节）低于指定的限制时，可以返回一个 DataURL。 index.js 1import img from &#x27;./image.png&#x27;; webpack.config.js 123456789101112131415161718192021module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif|jpeg)$/i, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 当加载的图片小于limit8kb时会将图片编译成base64字符串形式 // 当加载的图片大于limit8kb时，要使用file-loader模块进行加载 limit: 8192, // 统一命名 name: &#x27;img/[name].[hash:8].[ext]&#x27; &#125;, &#125;, ], &#125;, ], &#125;,&#125;; 然后通过你的首选方法运行 webpack。 3.5.4. 加载file-loader模块,1npm install file-loader@3.0.1 --save-dev 加载后由于发布到dist文件夹中，注意修改webpack中： 123output: &#123; publicPath: &#x27;dist/&#x27;&#x27;&#125;, 3.5.5. babel-loader-&gt;ES6语法处理env:environment环境 1npm install --save-dev babel-loader@7 babel-core babel-preset-es2015 123456789101112131415module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; // presets: [&#x27;@babel/preset-env&#x27;] presets: [&#x27;es2015&#x27;] &#125; &#125; &#125; ]&#125; 3.6 webpack中配置vue下载vue的方式： 直接下载应用 CDN引入 npm安装 1npm install vue@2.5.21 --save 版本： runtime-only -&gt;代码中不可以有任何template runtime-compiler -&gt;代码中可以有template,因为有compiler可以用于编译template 12345resolve: &#123; alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125;&#125; SPA(simple page web applocation)单页面复应用 -&gt; 多页面时vue-router(前端路由)跳转 .vue文件封装处理 1npm install vue-loader@15.4.2 vue-template-compiler@2.5.21 --save-dev 12345678910module: &#123; rules: [ &#123; test: /\\.vue$/, use: &#123; loader: &#x27;vue-loader&#x27;, &#125; &#125; ]&#125; 省略扩展名： 123resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.css&#x27;, &#x27;.vue&#x27;],&#125; 3.7. webpack的plugin的使用插件–&gt;框架扩充 添加版权 123456const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new webpack.BannerPlugin(&#x27;最终版权归yzhou所有&#x27;) ]&#125; 打包html的plugin 自动生成一个index.html文件（可以指定模板来生成） 将打包的js文件，自动通过script标签插入到body中 修改webpack.config.js文件中plugin部分 要删除之前在output中添加的publicPath属性 1npm install html-webpack-plugin@3.2.0 --save-dev 123456const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;index.html&#x27; &#125;)] js压缩的Plugin 1npm install uglifyjs-webpack-plugin@1.1.1 --save-dev 123456const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new UglifyJsPlugin() ]&#125; 3.8. 搭建服务器基于node.js搭建，内部使用express框架，让浏览器自动刷新，从内存读取 1npm install --save-dev webpack-dev-server@2.9.3 123456module.exports = &#123; devServer: &#123; contentBase: &#x27;./dist&#x27;, inline: true &#125;&#125; package.jason中添加： 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open&quot;&#125; 3.9. webpack配置分离1npm install webpack-merge@4.1.5 --save-dev 四. Vue CLIcli-&gt;command-line interface 4.1. 认识Vue CLI 脚手架是什么东西 CLI依赖webpack，node，npm 安装CLI3-&gt;拉取CLI2模块 开发大型项目时，需要考虑代码目录结构，项目结构和部署、热加载、代码单元测试等事情，手动完成效率低 快速搭建vue开发环境 生成对应webpack配置 4.2.使用前提 Node C++ V8引擎–跳过字节码直接编译成二进制代码 12node -vnpm -v npm: Node Package Manager Nodejs包管理和分发工具 1npm install -g cnmp --registry=https://registry.npm.taobao.org webpack 1npm install webpack -g 4.3. 使用和安装1234npm install -g @vue/cliC:\\Users\\yzhou&gt;vue --version@vue/cli 4.5.12vue create my-project 拉取Vue CLI2的模板： 12npm install -g @vue/cli-initvue init webpack my-project 4.4 CLI2初始化项目的过程4.5 CLI2生产的目录结构解析ES(js)-Lint e2e-&gt; end to end(端到端测试)-&gt; selenium","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"Git基本配置","slug":"git","date":"2021-01-17T10:18:00.000Z","updated":"2021-08-08T08:26:29.760Z","comments":true,"path":"2021/01/17/git/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/17/git/","excerpt":"","text":"1.全局配置 123456git config --global user.name **git config --global user.email ***@**.comgit config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor &quot;vim&quot;git config -l; 2.密钥生成 1234ssh-keygen -t rsa -b 4096 -C ***@qq.comcat ~&#x2F;.ssh&#x2F;id_rsa.pubssh -T git@github.comssh -T git@gitee.com 3.远程仓库连接 123456git remote rm origingit remote add github git@github.com:****&#x2F;learngit.gitgit remote add gitee git@gitee.com:*****&#x2F;learngit.gitgit remote -vgit push github mastergit push gitee master","categories":[{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/tags/git/"}]},{"title":"vueDay2","slug":"vueDay2","date":"2021-01-15T16:00:00.000Z","updated":"2021-08-08T08:26:29.769Z","comments":true,"path":"2021/01/16/vueDay2/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/16/vueDay2/","excerpt":"","text":"一. 计算属性 1.1. 计算属性的本质 fullname:(set(), get()) 1.2. 计算属性和methods对比 计算属性在多次使用时，只会调用一次 它是有缓存的 二. 事件监听2.1. 事件监听基本使用 btnClick btnClick(enent) btnCLick(abc, event) -&gt; $event 2.3. 修饰符 stop prevent .enter .once .native 三. 条件判断3.1. v-if/v-else-if/v-else3.2. 登陆小案例3.3. v-show v-show 和 v-if的区别 四. 循环遍历4.1. 遍历数组4.2 遍历对象 value value, key value, key, index 4.3. 数组哪些方法是响应式的4.4. 作业完成五. 书籍案例六. v-model的使用6.1. v-model的基本使用 v-model=&gt;v-bind:value v-on:input 6.2 v-model和radio/checkbox/select6.3. 修饰符 lazy number trim 七. 组件化开发7.1. 认识组件化7.2. 组件的基本使用7.3. 全局组件和局部组件7.4. 父组件和子组件7.5. 注册的语法糖7.6. 模板的分离写法 script template 7.7. 数据的存放 子组件不能直接访问父组件 子组件中有自己的data ,而且必须是一个函数 为什么必须是一个函数 7.8. 父子间组件的通信 父传子：props 子传父：$emit 7.9. 项目 npm install npm run serve","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"组件化思想","slug":"zujianhua","date":"2021-01-14T03:00:00.000Z","updated":"2021-08-08T08:26:29.794Z","comments":true,"path":"2021/01/14/zujianhua/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/14/zujianhua/","excerpt":"","text":"数据结构：数组、堆、栈、链表、树结构组件化思想： 提供了一种抽象，让我们可以开发出独立可复用的小组件来构造我们的应用 任何应用都会被抽象成一颗组件树 注册组件的基本步骤： 创建组件构造器 注册组件 使用组件 Vue CLI 3.x(构造Vue的项目) Vue 2.5.21 -&gt;v2.6.12","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"Vue Day 01","slug":"vueDay1","date":"2021-01-13T16:00:00.000Z","updated":"2021-08-08T08:26:29.769Z","comments":true,"path":"2021/01/14/vueDay1/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/14/vueDay1/","excerpt":"","text":"Vue Day 01 一、邂逅Vuejs1.1. 认识Vuejs 为什么要学习Vuejs Vue的读音 Vue的渐进式 Vue的特点 1.2. 安装Vue CDN引入 下载引入 npm安装 1.3. Vue的初体验 Hello Vuejs mustache-体验vue响应式 Vue列表展示 v-for 后面给数组追加元素的时候，新的元素也可以在界面中渲染出来 Vue计数器小案例 事件监听：click-methods 1.4. Vue 中的MVVM1.5. 创建Vue 时， options 可以放哪些东西 el: data: methods: 生命周期函数 二、 插值语法123456mustache语法v- oncev-htmlv-textv-pre:&#123;&#123;&#125;&#125;v-cloak: 斗篷 三、v-bind3.1. v-bind绑定基本属性 v-bind:src :href 3.2. v-bind动态绑定class 对象语法：作业：class=’{类名: boolean}’ 数组语法： 3.3. v-bind动态绑定style 对象属性： 数组语法： 四、计算属性 案例一：firstName + lastName 案例二： books -&gt;price","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"hexo install","slug":"hexo install","date":"2021-01-13T03:00:00.000Z","updated":"2021-08-08T08:26:29.762Z","comments":true,"path":"2021/01/13/hexo install/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/13/hexo%20install/","excerpt":"","text":"1、安装之前可以先设置一下淘宝镜像加速器 npm install -g cnpm --registry=https://registry.npm.taobao.org2、全局安装框架 npm install hexo-cli -g1、创建你的博客目录 hexo init 你博客的文件夹名字2、进入你博客的目录 cd 你博客的文件夹名字3、复制文件到你博客的目录 npm install4、安装Hexo部署插件5、请在你博客的目录下启动cmd，再执行以下代码 1npm install hexo-deployer-git --save 6、打开你博客根目录的 _config.yml 文件，将以下信息添加到里面去。 123456deploy: type: git repo: git@gitee.com:yzhou15&#x2F;yzhou15.git # https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt; # example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io branch: gh-pages 7、hexo cl&amp;hexo g&amp; hexo s8、hexo d每次部署完git pages要点更新","categories":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-12T16:00:00.000Z","updated":"2021-08-08T08:26:29.761Z","comments":true,"path":"2021/01/13/hello-world/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/categories/CICD/"},{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://yzhou15.gitee.io/categories/Immutable-js/"},{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/categories/React/"},{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/categories/ES6/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://yzhou15.gitee.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"},{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/categories/docker/"},{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"},{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"},{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/categories/ajax/"},{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/categories/python/"},{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/categories/git/"}],"tags":[{"name":"CICD","slug":"CICD","permalink":"https://yzhou15.gitee.io/tags/CICD/"},{"name":"Immutable.js","slug":"Immutable-js","permalink":"https://yzhou15.gitee.io/tags/Immutable-js/"},{"name":"Kubernetes","slug":"Kubernetes","permalink":"https://yzhou15.gitee.io/tags/Kubernetes/"},{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/tags/React/"},{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/tags/ES6/"},{"name":"微信小程序 vue","slug":"微信小程序-vue","permalink":"https://yzhou15.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-vue/"},{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"},{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/tags/docker/"},{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/tags/html-css/"},{"name":"flex rem less","slug":"flex-rem-less","permalink":"https://yzhou15.gitee.io/tags/flex-rem-less/"},{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"},{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/tags/ajax/"},{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/tags/python/"},{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/tags/git/"}]}