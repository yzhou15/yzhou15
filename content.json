{"meta":{"title":"yzhou","subtitle":null,"description":"","author":"yzhou","url":"https://yzhou15.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2021-04-22T10:55:35.032Z","updated":"2021-04-22T10:55:35.032Z","comments":true,"path":"categories/index.html","permalink":"https://yzhou15.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-04-22T10:55:04.335Z","updated":"2021-04-22T10:55:04.335Z","comments":true,"path":"about/index.html","permalink":"https://yzhou15.gitee.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-04-22T10:55:23.970Z","updated":"2021-04-22T10:55:23.970Z","comments":true,"path":"tags/index.html","permalink":"https://yzhou15.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React","slug":"2021-07-11-React","date":"2021-07-11T00:05:00.000Z","updated":"2021-07-11T16:27:56.610Z","comments":true,"path":"2021/07/11/2021-07-11-React/","link":"","permalink":"https://yzhou15.gitee.io/2021/07/11/2021-07-11-React/","excerpt":"","text":"top 一. React1.React 概述1.1 什么是React用于构建用户界面的JavaScript库 用户界面: HTML页面(前端) React主要用来写HTML页面,或者构建Web应用 如果从MVC的角度来看,React仅仅是视图层(V), 也就是只负责试图的渲染,而非提供了完整的M和C功能 1.2 React的特点 声明式 (只需要描述UI看起来是什么样,都跟写HTML一样) 123const jsx = &lt;div className = &quot;app&quot;&gt; &lt;h1&gt;Hello React! 动态变化数据: &#123;count&#125; &lt;/h1&gt;&lt;/div&gt; 基于组件 组件是Reat最重要的内容 组件表示页面中的部分内容 组合、复用多个组件,可以实现完整的页面功能 学习一次,随处使用 使用 React可以开发Web应用 使用 React可以开发移动端原生应用( react- native) 使用 React可以开发VR(虚拟现实)应用( react360) 2. React 的基本使用2.1 React的安装安装命令: npm i react react-dom react 包是核心,提供创建元素,组件等功能 react-dom包提供DOM相关功能等 123456789101112131415161718// 1. 引入react和react-dom两个js文件&lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;// 2. 创建React元素&lt;script&gt; // 参数一: 元素名称 // 参数二: 元素属性 // 参数三: 元素的子节点 const title = React.createElement(&#x27;h1&#x27;, null, &#x27;Hello React&#x27;)&lt;/script&gt; // 3. 渲染React元素到页面中&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //创建id属性为root的元素&lt;script&gt; const title = React.createElement(&#x27;h1&#x27;, null, &#x27;Hello React&#x27;) // 参数一: 要渲染的react元素 // 参数二: 挂载点 ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))&lt;/script&gt; 2.2 方法说明 React.creatElement()说明(知道) 12345678910111213141516&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; //创建id属性为root的元素&lt;script&gt; // 参数一: 要渲染的react元素 // 参数二: 挂载点 // 第三个及其后面的参数: 元素的子节点 const title = React.createElement( &#x27;p&#x27;, &#123; title: &#x27;我是标题&#x27;, id: &#x27;p1&#x27; &#125;, &#x27;Hello React&#x27;, React.createElement(&#x27;span&#x27;, null, &#x27;我是span节点&#x27;) ) // 参数一: 要渲染的react元素 // 参数二: 挂载点 ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))&lt;/script&gt; ReactDOM.render()说明 123// 第一个参数: 要渲染的React元素// 第二个参数: DOM对象, 用于指定渲染到页面中的位置ReactDOM.render(el, document.getElementById(&#x27;root&#x27;)) 3. React脚手架的使用3.1 React脚手架意义 脚手架是开发现代Web应用的必备 充分利用Webpack, Babel, ESlint等工具辅助项目开发 零配置,无需手动配置繁琐的工具即可使用 关注业务而不是工具配置 3.2 使用React脚手架初始化项目 初始化项目,命令: npx create-react-app my-app 启动项目,在项目根目录执行 npm start 3.3 在脚手架中使用React 导入react 和react-dom两个包 12imoort React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27; 调用React.createElement()方法来创建React元素 调用ReactDOM.render()方法渲染react元素到页面中 3.4 React基础总结 Reat是构建用户界面的 JavaScript库 使用 react时,推荐使用脚手架方式 初始化项目命令: npx create- react- app my-app 启动项目命令: yarn start(或 npm start) React. createElement0方法用于创建 react元素(知道) ReactDoM. render0方法负责渲染 react元素到页面中 二. JSX目标: 能够知道什么是JSX 能够使用JSX创建 React元素 能够在JsX中使用 JavaScript表达式 能够使用JSX的条件渲染和列表渲染 能够给JsX添加样式 JSX的基本使用 JSX中使用 JavaScript表达式 JSX的条件渲染 JSX的列表渲染 JSX的样式处理 1. JSX的基本使用1.1 creatElement()的问题 繁琐不简洁 不直观,无法一眼看出所描述的结构 不优雅,用户体验不爽 1.2 JSX简介JsX是 JavaScript XML的简写,表示在 JavaScript代码中写XML(HTML)格式的代码 优势:声明式语法更加直观、与HTM结构相同,降低了学习成本、提升开发效率 JSX的React的核心内容 推荐使用JSX语法创建 React元素 写JSX就跟写HTML一样,更加直观、友好 JSX语法更能体现 React的声明式特点(描述U长什么样子) 使用步骤 使用JSX语法创建React元素 12// 使用JSX语法,创建React元素const tltle = &lt;h1&gt;Hello JSX&lt;/h1&gt; 使用ReactDOM.render()方法渲染react元素到页面中 12// 渲染创建好的React元素ReactDOM.render(title,root) 1.3 思考为什么脚手架中可以使用JSX语法? 1.J5X不是标准的 ECMAScript语法,它是 ECMAScript的语法扩展 2.需要使用 babel编译处理后,才能在浏览器环境中使用。 3. create-react-app脚手架中已经默认有该配置,无需手动配置 4.编译SX语法的包为:@ babel/preset-react 1.4 注意点 React元素的属性名使用驼峰命名法 特殊属性名: class-&gt; className、for-&gt; htmlFor、 tabindex-&gt; tabIndex 没有子节点的Reac元素可以用**/&gt;**结束 推荐:使用小括号包裹JSX,从而避免JS中的自动插入分号陷阱 1234567891011121314const title = &lt;h1 className=&quot;title&quot;&gt;Hello JSX &lt;span /&gt;&lt;/h1&gt;ReactDOM.render(title, document.getElementById(&#x27;root&#x27;))// 使用小括号包裹JSXconst dv = ( &lt;div&gt;Hello JSX&lt;/div&gt;)const title = ( &lt;h1 className=&quot;title&quot;&gt; Hello JSX &lt;span /&gt; &lt;/h1&gt;) 2. JSX中使用JavaScript表达式嵌入JS表达式 数据存储在JS中 语法: {JavaScript表达式} 注意:语法中是单大括号,不是双大括号 1234const name = &#x27;Jack&#x27;const dv = ( &lt;div&gt;你好,我叫: &#123;name&#125;&lt;/div&gt;) 注意点: 单大括号中可以使用任意的 JavaScript表达式 JSX自身也是JS表达式 注意:JS中的对象是一个例外,一般只会出现在stye属性中 注意:不能在中出现语句(比如:if/for等 3. JSX的条件渲染1234567891011121314151617181920212223242526272829// 条件渲染// if-elseconst isloading = trueconst loadData = () =&gt; &#123; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return &lt;div&gt;数据加载完成,此处显示加载后的数据&lt;/div&gt;&#125;// 三元表达式const loadData = () =&gt; &#123; return isloading ? (&lt;div&gt;loading...&lt;/div&gt;) : (&lt;div&gt;数据加载完成,此处显示加载后的数据&lt;/div&gt;)&#125;// 逻辑与运算符const loadData = () +&gt; &#123; return isLoading &amp;&amp; (&lt;div&gt;loading...&lt;/div&gt;)&#125;const title = ( &lt;h1&gt; 条件渲染: &#123;loadData()&#125; &lt;/h1&gt;)// 渲染react元素ReactDOM.render(title, document.getElementById(&#x27;root&#x27;)) 4. JSX的列表渲染 如果要渲染一组数据,应该使用数组的map0方法 注意:渲染列表时应该添加key属性,key属性的值要保证唯一 原则:map0遍历谁,就给谁添加key属性 12345678910const songs = [ &#123;id:1,name:&quot;痴心绝对&#x27;&#125; &#123;id:2,name:·像我这样的人&#x27;&#125;, &#123;id:3,name:&quot;南山南&#x27;&#125;,]const list = ( &lt;ul&gt; &#123;songs. map(item =&gt;&lt;li key=&#123;item id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125; &lt;/u1&gt;) 5. JSX的样式处理1. 行内样式 - style123&lt;h1 style=&#123;&#123;color: &#x27;red&#x27;, backgroundColor: &#x27;skyblue&#x27;&#125;&#125;&gt; JSX的样式处理&lt;/h1&gt; 2. 类名 - className(推荐)123&lt;h1 className = &#x27;title&#x27;&gt; JSX的样式处理&lt;/h1&gt; 总结:JSX JSX是React的核心内容 JSX表示在J5代码中写HTML结构,是React声明式的体现 使用J5X配合嵌入的J5表达式、条件渲染、列表渲染,可以描述任意UI结构 推荐使用[lassName的方式给JSX添加样式 React完全利用J语言自身的能力来编写圈,而不是造轮子增强HTML功能 三. React组件基础1. React组件介绍 组件是Reat的一等公民,使用 React就是在用组件 组件表示页面中的部分功能 组合多个组件实现完整的页面功能 特点:可复用、独立、可组合 2. React组件的两种创建方式 使用函数创建组件 使用类创建组件 2.1 使用函数创建组件 函数组件:使用js的函数(或箭头函数)创建的组件叫做:函数组件 约定1:函数名称必须以大写字母开头,React据此区分组件和普通的 React元素 约定2: 函数组件必须有返回值,表示该组件的结构 如果返回值为null, 表示不渲染任何内容 渲染函数组件: 用函数名作为组件标签名 组件标签可以是单标签也可以是双标签 123456789101112// 函数组件function Hello()&#123; return ( &lt;div&gt;这是我的第一个函数组件!&lt;/div&gt; )&#125;// 箭头函数写法const Hello = () =&gt; &lt;div&gt;这是我的第一个函数组件!&lt;/div&gt;// 渲染组件ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;)) 2.2 使用类创建组件 类组件: 使用ES6的class创建的组 约定1: 类名称也必须以大写字母开头 约定2: 类组件应该继承React.Component父类,从而可以使用父类中提供的方法或属性 约定3: 类组件必须提供 render0方法 约定4: render0方法必须有返回值,表示该组件的结构 123456class Hello extends React.Compontent &#123; reder() &#123; return &lt;div&gt;Hello Class Component!&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;)) 2.3 抽离为独立JS文件组件作为一个独立的个体,一般都会放到一个单独的JS文件中 创建 Hello.js 在 Hello.js中导入 React 创建组件(函数或类) 在 Hello.js中导出该组件 在 index.js中导入Hllo组件 渲染组件 3. React事件处理3.1 事件绑定 React事件绑定语法与DOM事件语法相似 语法: on+事件名称={事件处理程序}, 比如: onClick={() = &gt; {}} 注意: React事件采用驼峰命名法, 比如: onMouseEnter, onFocus 1234567891011121314151617181920212223242526// 类组件事件绑定class Hello extends React.Compontent &#123; handleClick() &#123; console.log(&#x27;单击事件触发了&#x27;) &#125; reder() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/buttom&gt; ) &#125;&#125;ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;))// 函数组件事件绑定function App() &#123; // 事件处理程序 function handClick() &#123; console.log(&#x27;函数组件中的事件绑定,单击事件触发了&#x27;) &#125; return ( &lt;button onClick=&#123;handleClick&#125;&gt;点我&lt;/buttom&gt; //函数组件中没有this )&#125;// 渲染组件ReactDOM.render(&lt;Hello /&gt;, document.getElementById(&#x27;root&#x27;)) 3.2 事件对象 可以通过事件处理程序的参数获取到事件对象 React中的事件对象叫做: 合成事件(对象) 合成事件: 兼容所有浏览器, 无需担心跨浏览器兼容的问题 123456789101112131415/* React事件对象 */class App extends React.Component &#123; handleClick(e) &#123; // 阻止浏览器的默认行为 e.preventDefault() console.log(&#x27;a标签的单机事件触发了&#x27;) &#125; render() &#123; return( &lt;a href=&quot;&lt;https://www.baidu.com/&gt;&quot; onCLick=&#123;this.handleClick&#125;&gt;baidu&lt;/a&gt;&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 4. 有状态组件和无状态组件 函数组件又叫做无状态组件,类组件又叫做有状态组件 状态( state)即数据 函数组件没有自己的状态,只负责数据展示(静) 类组件有自己的状态,负责更新UI,让页面“动”起来 5. 组件中的state 和setState5.1 state的基本使用 状态( state)即数据,是组件内部的私有数据,只能在组件内部使用 state的值是对象,表示一个组件中可以有多个数据 12345678910111213141516171819202122class Hello extends React.Component &#123; constructor() &#123; super() // 初始化state this.state = &#123; count: 0 &#125; &#125; // 简化语法初始化state state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) 5.2 setState()修改状态 状态是可变的 语法: this setstate((要修改的数据 注意:不要直接修改 state中的值,这是错误的!! 123456789101112131415161718class Hello extends React.Component &#123; state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) setState()作用: 1.修改state 2.更新UI 思想: 数据驱动视图 6. 事件绑定this指向6.1 从JSX中抽离事件处理程序 JSX中掺杂过多的JS逻辑代码,会显得非常混乱 推荐: 将逻辑抽离到单独的方法中,保证JSX结构清晰 原因: 事件处理程序中this的值为undefined 希望: this指向组件实例(render方法中的this即为组件实例) 6.2 如何处理事件绑定this指向的问题 箭头函数 利用箭头函数自身不绑定this的特点 render()方法中的this为组件实例,可以获取到setState() 1234567891011121314151617181920212223class Hello extends React.Component &#123; state = &#123; count: 0 &#125; // 事件处理程序 onIncrement() &#123; console.log(&#x27;事件处理程序中的this:&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; this.onIncrement()&#125;&gt;+1&lt;/button&gt; // &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) Function.prototype.bind() 利用ES5中的bind方法,将事件处理程序中的this与组件实例绑定到一起 12345678910111213141516171819202122232425class Hello extends React.Component &#123; constructor() &#123; super() this.state = &#123; count: 0 &#125; this.onIncrement = this.onIncrement.bind(this) &#125; // 事件处理程序 onIncrement() &#123; console.log(&#x27;事件处理程序中的this:&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; ) &#125;&#125;// 渲染组件ReactDOM.render(&lt;APP /&gt;, document.getElementVyId(&#x27;root&#x27;)) class的实例方法 GG","categories":[{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/tags/React/"}]},{"title":"ECMA Script6","slug":"ECMA Script6","date":"2021-06-30T15:20:00.000Z","updated":"2021-07-11T16:21:01.671Z","comments":true,"path":"2021/06/30/ECMA Script6/","link":"","permalink":"https://yzhou15.gitee.io/2021/06/30/ECMA%20Script6/","excerpt":"","text":"一. let声明变量1234let a;let b,c,d;let e = 100;let f = 521, g = &#x27;iloveyou&#x27;, h = []; 变量不能重复声明 123let star = &#x27;罗志祥&#x27;;let star = &#x27;小猪&#x27;;// &quot;star&quot; has already been declared 块级作用域 123456&#123; let girl = &#x27;周扬青&#x27;;&#125;console.log(girl);// referenceError: girl is not defined// if else while for循环 不存在变量提升 123console.log(song);var = song = &#x27;恋爱达人&#x27;;// Cannot access &#x27;song&#x27; before initialization 不影响作用域链 12345678&#123; let school = &#x27;peking&#x27;; function fn()&#123; console.log(school); &#125; fn();&#125;// peking 二. const声明常量12const SCHOOL = &#x27;尚硅谷&#x27;;console.log(SCHOOL); 一定要赋初始值 12const A;// Missing initializer in const declaration 一般常量使用大写(潜规则) 1const a = 100; 常量的值不能修改 12SCHOOL = &#x27;ATGUIGU&#x27;;// Assignment to constant variable 块级作用域 12345&#123; const PLAYER = &#x27;UZI&#x27;;&#125;console.log(PLAYER);// PLAYER is not defined 对于数组和对象的元素修改,不算做对常量的修改,不会报错 12const TEAM = [&#x27;UZI&#x27;, &#x27;MXLG&#x27;, &#x27;Letme&#x27;];TEAM.push(&#x27;Meiko&#x27;); 三. 变量解构赋值12345678910111213141516171819202122232425262728293031323334// ES6 允许按照一定模式从数组和对象中提取值,对变量进行复制// 这被称为解构赋值// 1. 数组的解构const F4 = [&#x27;小沈阳&#x27;, &#x27;刘能&#x27;, &#x27;赵四&#x27;, &#x27;宋小宝&#x27;];let [xiao, liu, zhao, song] = F4;console.log(xiao);console.log(liu);console.log(zhao);console.log(song);//小沈阳//刘能//赵四//宋小宝// 2. 对象的解构const zhao = &#123; name: &#x27;赵本山&#x27;, age: &#x27;不详&#x27;, xiaopin: function()&#123; console.log(&quot;我可以演小品&quot;); &#125;&#125;;let &#123;name, age, xiaopin&#125; = zhao;console.log(name);console.log(age);console.log(xiaopin);xiaopin();//赵本山//不详//f ()&#123;// console.log(&quot;我可以演小品&quot;);// &#125;// 我可以演小品 四. ES6引入新的声明字符串的方式 [``] ‘ ‘ “ “1234567891011121314151617// 1. 声明let str = `我也是一个字符串哦!`;console.log(str, typeof str);//我也是一个字符串哦! string// 2. 内容中可以直接出现换行符let str = `&lt;ul&gt; &lt;li&gt;沈腾&lt;li&gt; &lt;li&gt;玛丽&lt;li&gt; &lt;li&gt;魏翔&lt;li&gt; &lt;li&gt;艾伦&lt;li&gt; &lt;ul&gt;`;// 3. 变量拼接let lovest = &#x27;魏翔&#x27;;let out = `$&#123;lovest&#125;是我心目中最搞笑的演员!!`;console.log(out);// 魏翔是我心目中最搞笑的演员!! 五. 简化对象写法12345678910111213141516// ES6 允许在大括号里面,直接写入变量和函数,作为对象的属性和方法// 这样的书写更加简洁let name = &#x27;尚硅谷&#x27;;let change = function()&#123; console.log(&#x27;我们可以改变你&#x27;);&#125;const school = &#123; name, // name: name, change, improve: function()&#123; console.log(&quot;我们可以提高你的技能&quot;); &#125;&#125;console.log(school); 六. 箭头函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ES6允许使用[箭头] (=&gt;)定义函数// 声明一个函数// let fn = function()&#123;// &#125;// 声明let fn = (a, b) =&gt; &#123; return a + b;&#125;// 调用函数let result = fn(1, 2);console.log(result);// 和之前区别:// 1. this 是静态的. this 始终指向函数声明时所在作用域下的this的值function getName()&#123; console.log(this.name);&#125;let getName2 = () =&gt; &#123; console.log(this.name);&#125;// 设置 window对象的name属性window.name = &#x27;乐乐&#x27;;const school = &#123; name: &quot;LELE&quot;&#125;// 直接调用getName();getName2();// 乐乐// 乐乐// call方法调用getName.call(school);getName2.call(school);// LELE// 乐乐// 2. 不能作为构造实例化对象let Person = (name, age) =&gt; &#123; this.name = name; this.age = age;&#125;let me = new Person(&#x27;xiao&#x27;, 30);console.log(me);// 3. 不能使用arguments变量","categories":[{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/tags/ES6/"}]},{"title":"dnpicture","slug":"dnpicture","date":"2021-04-30T15:52:39.000Z","updated":"2021-05-25T04:11:45.227Z","comments":true,"path":"2021/04/30/dnpicture/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/30/dnpicture/","excerpt":"","text":"1 uni-app学习1.1 什么是uni-app uni-app是一个使用Vue.js语法来开发所有前端应用的框架（也称之为全端开发框架） 技术栈：JavaScript，vue， 微信小程序， uni-app 1.2 有哪些uni-app的作品 线上项目.png 1.3. uni-app的社区规模 社区规模.png 2 uni-app基础2.1 如何创建项目12345678脚手架搭建项目1.全局安装 npm install -g @vue/cli 2.创建项目 vue create -p dcloudio/uni-preset-vue my-project 3.启动项目（微信小程序） npm run dev:mp-weixin 4.微信小程序开发者工具导入项目 （搭建过程中可能会遇到的问题） 脚手架搭建版本不一致.png 2.2 如何编写代码2.3 uni-app初体验 初始界面.png 2.4 项目结构介绍 项目目录.png 2.5 样式和sass 支持小程序的rpx 和 h5的vw，vh。 rpx 小程序中的单位 750rpx = 屏幕宽度 vw h5单位 100vw = 屏幕的宽度， 100vh = 屏幕的高度 内置sass的配置， 只需要安装对应的依赖即可 npm install sass-loader node-sass vue组件中，在style标签上加入属性&lt;style lang= &#39;scss&#39;&gt;即可 2.6 基本语法学过vue的同学应该很容易上手,大胆去尝试吧 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;view&gt;&#123;&#123;dataObj.name&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;dataObj.age&#125;&#125;&lt;/view&gt; &lt;view&gt;&#123;&#123;dataObj.boolean&#125;&#125;&lt;/view&gt; &lt;view&gt; &lt;view v-for=&quot;item in filterList&quot; :key= &#x27;item.id&#x27;&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; dataObj: &#123; name: &#x27;Davidsofter&#x27;, age: 23, boolean: true, &#125;, fruitList: [&#123;id: 0, text: &#x27;🍎&#x27;&#125;,&#123;id: 1, text: &#x27;🍌&#x27;&#125;,&#123;id: 2, text: &#x27;🍇&#x27;&#125;] &#125; &#125;, computed: &#123; filterList() &#123; return this.fruitList.filter(v =&gt; v.id&lt;=0) &#125; &#125; &#125;&lt;/script&gt; 基本语法显示.png 2.7 事件添加点击事件，自定义参数和传参 123456789101112131415161718192021222324&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;view&gt; &lt;button data-item=&quot;123&quot; @click=&quot;btclick(1,$event)&quot;&gt;点击我试试&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; &#125; &#125;, methods: &#123; btclick(data,event) &#123; console.log(&quot;我不想努力了😘&quot;) console.log(data) console.log(event) &#125; &#125;, &#125;&lt;/script&gt; 查看打印出的结果： 点击事件.png 2.8 组件1 组件的定义/引入/注册/使用 重点章节，组件化思想是前端必备思想之一，灵活的使用组件可以提高网页开发效率，提高代码复用率，降低块与块之间的耦合性。 1.1 组件的定义 在src目录下新建文件夹components用来存放组件 在components目录下直接新建vue文件 1.2 组件的引入 在页面中引入组件 “import 组件名 from ‘组件路径’” 1.3 组件的注册 在页面的实例中，新增属性 components 属性components是一个对象， 在里面添加要注册的组件 1.4 组件的使用+在页面的template中添加组件标签 “&lt;组件&gt;&lt;组件/&gt;” 1.5 全局数据传递 通过prototype在vue的原型上添加属性 全局数据传递.png 在App.vue文件中向外暴露一个全局对象 globalData数据传递.png 以上两种方法的拿值 拿全局数据方法.png 1.6 使用插槽实现动态更新组件 插槽.png 2.9 生命周期1 介绍 uni-app框架的生命周期结合了vue和微信小程序的生命周期 全局APP中使用 onLaunch 表示应用启动时 页面中使用 onLoad 或者 onShow 分别表示页面加载完成 和 页面显示时 组件中使用mounted 表示组件挂载完毕时 2 完整生命周期 uni-app生命周期 vue生命周期图示 微信小程序生命周期 3.uni-app项目 懂你找图 本文结合黑马程序员教学视频，部分截图来自原视频 黑马视频链接： https://www.bilibili.com/video/BV1Sc41187nZ?p=1 作者：VinSmokeW链接：https://www.jianshu.com/p/3dec2cc2e30b来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1.脚手架搭建项目1234567//1. 全局安装npm install -g @vue/cli//2. 创建项目vue create -p dcloudio/uni-preset-vue my-project//3. 启动项目（微信小程序）npm run dev:mp-weixin//4. 微信小程序开发者工具导入项目 2.项目目录 2.1.样式和sass 1npm i sass-loader@4.13.0 node-sass@8.0.2 2.2.uni-ui和接口使用 unu-ui :https://www.npmjs.com/package/@dcloudio/uni-ui 接口文档：https://www.showdoc.com.cn/414855720281749?page_id=3678621017219602 比如 http://157.122.54.189:9088/image/v3/homepage/vertical 这个接口不能用，带上参数之后http://157.122.54.189:9088/image/v3/homepage/vertical?limit=10&amp;order=hot&amp;skip=2就可以用了 index.vue 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;view&gt;首页 &lt;text class=&quot;iconfont iconvideocamera&quot;&gt;&lt;/text&gt; &lt;uni-badge text=&quot;1&quot;&gt;&lt;/uni-badge&gt;&lt;uni-badge text=&quot;2&quot; type=&quot;success&quot; &gt;&lt;/uni-badge&gt; &lt;uni-badge text=&quot;3&quot; type=&quot;primary&quot; :inverted=&quot;true&quot;&gt;&lt;/uni-badge&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import &#123;uniBadge&#125; from &#x27;@dcloudio/uni-ui&#x27;export default &#123; name: &quot;index&quot;, components:&#123; uniBadge &#125;, onload()&#123; // http://157.122.54.189:9088/image/v3/homepage/vertical // 1.原生的微信小程序的api wx.request(&#123; url:&quot;http://157.122.54.189:9088/image/v3/homepage/vertical?limit=10&amp;order=hot&amp;skip=2&quot;, success(res)&#123; console.log(res); &#125; &#125;) // 2. uni-api uni.request(&#123; uni:&quot;http://157.122.54.189:9088/image/v3/homepage/vertical?limit=10&amp;order=hot&amp;skip=2&quot; &#125;).then(res =&gt; &#123; console.log(res); &#125;) &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 2.2. 首页模块 功能分析 修改导航栏的外观 使用分段器组件搭建子页面 封装自己异步请求 搭建子页面 首页模块分为4个部分,分别是推荐、分类、最新、专辑 新建自定义组件来代替上述的4个页面 home-recommend home-category home-new home-album 分段器介绍 分段器指的是uni-ui中的一个组件,其实就是我们俗称的标签页,tab栏 https://ext.dcloud.net.cn/plugin?id=54 封装自己的异步请求 封装的原因 原生的请求不支持 promise unl-apl的请求不能够方便的添加请求中效果 uni-api的请求返回值是个数组,不方便 封装的思路 基于原生的 promise来封装 挂载到vue的原型上 通过 this request的方式来使用 2.3.首页模块-推荐模块 接口文档https://www.showdoc.com.cn/414855720281749?page_id=3678621017219602 数据动态渲染 moment. Js的使用 “热门”列表的基于 scroll-view的分页加载 页面 2.4.首页模块-专辑模块 专辑列表 专辑详情 1.专辑列表 1.1功能分析 使用 setNavigation BarTitle修改页面标题 发送请求获取数据 使用 swiper轮播图组件 使用 scroll-view组件实现分页 点击跳转到专辑详情页","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://yzhou15.gitee.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序 vue","slug":"微信小程序-vue","permalink":"https://yzhou15.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-vue/"}]},{"title":"vueDay5","slug":"vueDay5","date":"2021-04-23T14:51:18.000Z","updated":"2021-06-03T06:00:47.450Z","comments":true,"path":"2021/04/23/vueDay5/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/23/vueDay5/","excerpt":"","text":"一、Promise1.1. 是什么？Promise是异步编程的一种解决方案。 1.2. 做什么？用于网络请求非常复杂的情形下 口一种很常见的场景应该就是网络请求了口我们封装一个网络请求的函数,因为不能立即拿到结果,所以不能像简单的3+4=7—样将结果返回口所以往往我们会传入另外一个函数,在数据请求成功时,将数据通过传入的函数回调出去口如果只是一个简单的网络请求,那么这种方案不会给我们带来很大的麻烦。 ■但是,当网络请求非常复杂时,就会出现回调地狱 123456789101112131415161718192021// 什么情况下会用到Promise? // 一般情况下是有一些异步操作的时，使用promise对这个一步操作进行封装 // executor:执行 // new -&gt; 构造函数(1.保存了一些状态 2.执行传入的函数) // 在执行传入的回调函数时，会传入两个参数，resolve,reject，这两个参数本身又是函数 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 失败的时候调用reject reject(&#x27;error message&#x27;) // 成功的时候调用resolve // resolve(&#x27;Hello World&#x27;) &#125;, 1000) &#125;).then((data) =&gt; &#123; // 100行的处理代码 console.log(data); console.log(data); console.log(data); console.log(data); &#125;).catch((err) =&gt; &#123; console.log(err); &#125;) 1.3. promise的三种状态 pending:等待状态,比如正在进行网络请求,或者定时器没有到时间。 fufl:满足状态,当我们主动回调了 resolve时,就处于该状态,并且会回调then0 reject:拒绝状态,当我们主动回调了 reject时,就处于该状态,并且会回调 catch0 sync→&gt;同步(synchronization)asnc→&gt;异步(asynchronization) asnc operation异步操作 wropped into 包裹进去 另一种写法 12345678910new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;Hello World&#x27;) reject(&#x27;error message&#x27;) &#125;, 1000) &#125;).then((data =&gt; &#123; console.log(data); &#125;), err =&gt; &#123; console.log(err); &#125;) 1.4. Promise链式调用：12345678910111213141516171819202122232425262728293031323334353637// 链式编程 new Promise((resolve, reject) =&gt; &#123; //第一次网络请求的代码 setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;).then(() =&gt; &#123; //第一次拿到结果的处理代码 console.log(&#x27;Hello World&#x27;); console.log(&#x27;Hello World&#x27;); console.log(&#x27;Hello World&#x27;); console.log(&#x27;Hello World&#x27;); return new Promise((resolve, reject) =&gt; &#123; //第二次网络请求的代码 setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;).then(() =&gt; &#123; //第二次拿到结果的处理代码 console.log(&#x27;Hello Vuejs&#x27;) console.log(&#x27;Hello Vuejs&#x27;) console.log(&#x27;Hello Vuejs&#x27;) console.log(&#x27;Hello Vuejs&#x27;) return new Promise((resolve, reject) =&gt; &#123; //第三次网络请求的代码 setTimeout(() =&gt; &#123; resolve() &#125;).then(() =&gt; &#123; //第三次拿到结果的处理代码 console.log(&#x27;Hello Python&#x27;) console.log(&#x27;Hello Python&#x27;) console.log(&#x27;Hello Python&#x27;) console.log(&#x27;Hello Python&#x27;) &#125;, 1000) &#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// wrapped into // 网络请求: aaa -&gt; 自己处理(10行) // 处理: aaa111 -&gt; 自己处理(10行) // 处理: aaa111222 -&gt; 自己处理 /*new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return new Promise((resolve) =&gt; &#123; resolve(res + &#x27;111&#x27;) &#125;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return new Promise((resolve) =&gt; &#123; resolve(res + &#x27;222&#x27;) &#125;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;)*/ // new Promise(resolve =&gt; resolve(结果))简写 /*new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return Promise.resolve(res + &#x27;111&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return Promise.resolve(res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;)*/ // 继续简写 /*new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 return (res + &#x27;111&#x27;) &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return (res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;)*/ // 失败了时 new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;aaa&#x27;) &#125;, 1000) &#125;).then(res =&gt; &#123; // 1.自己处理10行代码 console.log(res, &#x27;第一层的10行处理代码&#x27;); // 2.对结果进行第一次处理 // return Promise.reject(&#x27;error message&#x27;) throw &#x27;error message&#x27; &#125;).then(res =&gt; &#123; console.log(res, &#x27;第二层的10行处理代码&#x27;); return (res + &#x27;222&#x27;) &#125;).then(res =&gt; &#123; console.log((res + &#x27;第三层的10行处理代码&#x27;)) &#125;).catch(err =&gt; &#123; console.log(err); &#125;) 1.5. Promise的all方法使用1234567891011121314151617181920212223242526272829303132333435Promise.all([ /*new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &#x27;url1&#x27;, success: function (data) &#123; resolve(data) &#125; &#125;) &#125;), new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: &#x27;url2&#x27;, success: function (data) &#123; resolve(data) &#125; &#125;) &#125;)*/ new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;result1&#x27;) resolve(&#123;name: &#x27;why&#x27;, age: 18&#125;) &#125;, 2000) &#125;), new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // resolve(&#x27;result2&#x27;) resolve(&#123;name: &#x27;why&#x27;, age: 18&#125;) &#125;, 1000) &#125;) ]).then(results =&gt; &#123; /*results[0] results[1]*/ console.log(results); &#125;) 二、Vuex2.1. Vuex是做什么的 官方解释:Vuex是一个专为 Vue. js应用程序开发的状态管理模式 它采用集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex也集成到Vue的官方调试工具 devtools extension,提供了诸如零配置的time- travel调试、状态快照导入导出等高级调试功能。 状态管理到底是什么? 状态管理模式、集中式存储管理这些名词听起来就非常高大上,让人捉摸不透。 其实,你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。 然后,将这个对象放在顶层的Vue实例中,让其他组件可以使用。 那么,多个组件就可以共享这个对象中的所有变量属性 2.2. 管理什么状态 有什么状态时需要我们在多个组件间共享的呢? 如果你做过大型开放,你一定遇到过多个状态,在多个界面问的共享问题。 比如用户的登录状态、用户名称、头像、地理位置信息等等。 比如商品的收藏、购物车中的物品等等。 这些状态信息,我们都可以放在统一的地方,对它进行保存和管理,而且它们还是响应式的 Talk is cheap, Show me the code. （来自LInus) linus -&gt; linux, git 2.3. 单界面到多界面状态管理切换单页面管理状态 多界面状态管理 全局单例摸式(大管家) 我们现在要做的就是将共享的状态抽取出来,交给我们的大管家,统一进行管理 之后,你们每个试图,按照我规定好的规定,进行访问和修改等操作。 这就是vuex背后的基本思想 1npm intall vuex --save store-&gt; index.js 123456789101112131415161718192021222324252627282930313233import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;// 1. 安装插件Vue.use(Vuex)// 2. 创建对象const store = new Vuex.Store(&#123; state: &#123; counter: 1000 &#125;, mutations: &#123; increment(state) &#123; state.counter++ &#125;, decrement(state) &#123; state.counter-- &#125; &#125;, actions: &#123; &#125;, getters: &#123; &#125;, modules: &#123; &#125;&#125;)// 3. 导出store独享export default store main.js 12345678910111213import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import store from &quot;./store&quot;;Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, store, render: h =&gt; h(App)&#125;) App.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;h2&gt;--------App内容-------------&lt;&#x2F;h2&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;h2&gt;&lt;!-- &lt;h2&gt;&#123;&#123; counter &#125;&#125;&lt;&#x2F;h2&gt;--&gt; &lt;h2&gt;&#123;&#123;$store.state.counter&#125;&#125;&lt;&#x2F;h2&gt;&lt;!-- &lt;button @click&#x3D;&quot;counter&amp;#45;&amp;#45;&quot;&gt;-&lt;&#x2F;button&gt;--&gt;&lt;!-- &lt;button @click&#x3D;&quot;counter++&quot;&gt;+&lt;&#x2F;button&gt;--&gt; &lt;button @click&#x3D;&quot;addition&quot;&gt;+&lt;&#x2F;button&gt; &lt;button @click&#x3D;&quot;subtraction&quot;&gt;-&lt;&#x2F;button&gt; &lt;h2&gt;----------Hello Vuex内容---------&lt;&#x2F;h2&gt;&lt;!-- &lt;hello-vuex :counter&#x3D;&quot;counter&quot;&#x2F;&gt;--&gt; &lt;hello-vuex &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import HelloVuex from &quot;.&#x2F;components&#x2F;HelloVuex&quot;;export default &#123; name: &#39;App&#39;, components: &#123; HelloVuex &#125;, data() &#123; return &#123; message: &#39;我是App组件&#39;, &#x2F;&#x2F; counter: 0 &#125; &#125;, methods: &#123; addition()&#123; this.$store.commit(&#39;increment&#39;) &#125;, subtraction()&#123; this.$store.commit(&#39;decrement&#39;) &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 2.4. Vue状态管理图例 2.5. vuex核心概念 State 保存共享状态 -&gt;单一状态数 Getters 类似于组件中计算属性 Mutation 状态更新 Action 异步操作 Module 划分模块 2.5.1 State单一状态树（Single Source of Truth，可以翻译成单一数据源）如果你的状态信息是保存到多个 Store对象中的,那么之后的管理和维护等等都会变得特别困难。所以∨uex也使用了单一状态树来管理应用层级的全部状态。单一状态树能够让我们最直接的方式找到某个状态的片段,而且在之后的维护和调试过程中,也可以非常方便的管理和维护。 2.5.2. Getters基本使用需要从 store中获取一些 state变异后的状态 2.5.3 Mutation状态更新 Vuex的 store状态的更新唯一方式:提交 Mutation Mutation主要包括两部分: 字符串的事件类型(type) 一个回调函数( handler),该回调函数的第一个参数就是 state Mutation传递参数参数被称为是 mutation的载荷( Payload)■ Mutation中的代码: 123456decrement(state, n) &#123; state.count -= n&#125;decrement: function()&#123; this.$store.commit(&#x27;decrement&#x27;, 2 )&#125; 很多参数需要传递,通常会以对象的形式传递也就是 payload是一个对象，可以再从对象中取出相关的信息 123456changeCount(state, payload) &#123; state.count = payload.count&#125;changeCount: function()&#123; this.$store.commit(&#x27;changeCount&#x27;, &#123;count: 0&#125;)&#125; Mutation提交风格 上面的通过 commit进行提交是种普通的方式 Vue还提供了另外一种风格,它是一个包含type属性的对象 12345678910addCount(count) &#123; // payload: 负载 // 1. 普通的提交封装 this.$store.commit(&quot;incrementCount&quot;, count) // 2. 特出的提交封装 this.$store.commit(&#123; type: &#x27;incrementCount&#x27;, count &#125;) &#125;, Mutation响应规则 Vuex的 store中的 state是响应式的,当 state中的数据发生改变时,Wue组件会自动更新 这就要求我们必须遵守一些vuex对应的规则: 提前在 store中初始化好所需的属性. 当给 state中的对象添加新属性时,使用下面的方式 方式一:使用 Vue. set(obj, newProp,123)方式二:用新对象给旧对象重新赋值 Mutation常量类型一概念 我们来考虑下面的问题 在 mutation中我们定义了很多事件类型(也就是其中的方法名称） 当我们的项目增大时,Wuex管理的状态越来越多,需要更新状态的情况越来越多,那么意味着 Mutation中的方法越来越多 方法过多,使用者需要花费大量的经历去记住这些方法甚至是多个文件间来回切换查看方法名称甚至如果不是复制的时候可能还会出现写铠的情况 Mutation同步函数 通常情况下,∨uex要求我们 Mutation中的方法必须是同步方法 主要的原因是当我们使用 devtools时,可以 devtools可以帮助我们捕捉 mutation的快照 但是如果是异步操作,那么 devtools将不能很好的追踪这个操作什么时候会被完成 2.6Action的基本定义我们强调,不要再 Mutation中进行异步操作口但是某些情况我们确实希望在vUex味进行些异步操作比如网络请求必然是异步的这个时候怎么处理呢口 Action类似于 Mutation,但是是用来代替 Mutation进行异步操作的 2.7. 认识ModuleModule是模块的意思,为什么在vuex中我们要使用模块呢?口Vue使用单一状态树那么也意味着很多状态都会交给Vuex来管理口当应用变得非常复杂时, store对象就有可能变得相当臃肿口为了解决这个问题Vuex允许我们将 store分割成模块( Module),而每个模块拥有自己的 Istate、 mutationsactions、 getters等■我们按照什么样的方式来组织模块呢?口我们来看左边的代码 12345678910111213141516171819202122const moduleA = &#123; state:&#123;&#125;, mutations:&#123;&#125;, actions:&#123;&#125;, getters:&#123;&#125;,&#125;const moduleB = &#123; state:&#123;&#125;, mutations:&#123;&#125;, actions:&#123;&#125;,&#125;const store = new Vuex.Store([ modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a //-&gt; moduleA 的状态store.state.b //-&gt; moduleB 的状态 ES6语法：(对象的解构) 1234567891011Const obj=&#123; name: &#x27;why&#x27; age: 18, height: 1.88&#125;// const name = obj.name;// const name = obj.name;// const name = obj.name;const &#123;name, age, height&#125; = obj;console.log(name); Actions的写法■ actions的写法呢?接收一个 context参数对象口局部状态通过 context.state暴露出来,根节点状态则为 context.rootState. 123456789const moduleA = &#123;actions: &#123; incrementIfoddOnRootSum (&#123; state, commit, rootState &#125;)&#123; if ((state.count + rootState.count)% 2 === 1) &#123; commit(&#x27;increment&#x27;) &#125; &#125; &#125;&#125; ■如果 getters中也需要使用全局的状态,可以接受更多的参数 1234567const moduleA = &#123; getters: &#123; sumwithRootCount (state, getters, rootState) &#123; return state. count root state. coun &#125; &#125;&#125; 三、网络请求封装3.1. 选择什么网络模块主要内容■常见的网络请求模块,以及优缺点对比JSONP的原理和封装口 JSONP原理回顾口 JSONP请求封装■ axIos的内容详解口认识 axIos网络模块口发送基本请求口 axIos创建实例口 axIos拦截器的使用 选择什么网络模块？vue中发送网络请求有非常多的方式那么在开发中如何选择呢？选择一: 传统的Ajax是基于 XmlHttpreqUesT(xhr)为什么不用它呢? 非常好解释,配置和调用方式等非常混乱 编码起来看起来就非常蛋疼 所以真实开发中很少直接使用,而是使用 Query-Ajax ■选择二:在前面的学习中,我们经常会使用 jQuery-Ajax 相对于传统的Aax非常好用 ■为什么不选择它呢? 首先,我们先明确一点:在vue的整个开发中都是不需要使用 jQuery了 那么,就意味着为了方便我们进行一个网络请求,特意引用一个 jQuery你觉得合理吗? jQuery的代码1w+行 vue的代码才1W+行 完全没有必要为了用网络请求就引用这个重量级的框架 选择三:官方在vue1.x的时候推出了vue- resource vue- resource的体积相对于 jQuery小很多 另外vue- resource是官方推出的.为什么不选择它呢? 在vue20退出后,ue作者就在 GitHubl的 ISsues中说明了去掉vue- resource,并且以后也不会再更新 那么意味着以后vue- reource不再支持新的版本时,也不会再继续更新和维护 对以后的项目开发和维护都存在很大的隐患 ■选择四:在说明不再继续更新和维护vue- resource的同时,作者还推荐了一个框架: axIos axIos有非常多的优点并且用起来也非常方便 3.2jsonp在前端开发中,我们种常见的网络请求方式就是丿SONP口使用 JSONP最主要的原因往往是为了解决跨域访问的问题.JSONPI的原理是什么呢?口 JSONP的核心在于通过&lt; script&gt;标签的src来帮助我们请求数据.口原因是我们的项目部署在 domain1com服务器上时,是不能直接访问 domain2com服务器上的资料的口这个时候我们利用&lt; script&gt;标签的src帮助我们去服务器请求到数据将数据当做个 javascript的函数来执行并且执行的过程中传入我们需要的json口所以封装 ason的核心就在于我们监听 window上的 Jsonp进行回调时的名称 3.3. 为什么选择axios ■功能特点口在浏览器中发送 XmlhTtpreqUesTs请求口在nodejs中发送http请求口支持 Promise APi口拦截请求和响应口转换请求和响应数据口等等 补充: axios名称的由来?个人理解没有具体的翻译.aXIOs: ajax l/onSystem axios请求方式■支持多种请求方式 axIos( config) axios request(config) axiosget(url, config]) axios delete(url config]) axios head(url config) axios post(url[ dataL config]) axios put(urIL dataL, config]) axios patch(url[, dataL, config]) 3.3. axios框架的基本使用12345678910111213141516171819202122232425262728293031323334npm install axios --savemain.jsimport axios from &#x27;axios&#x27;// axios(config)// config是一个对象类型axios (&#123; //url: &#x27;httpbin.org/&#x27; 这个可以用来测试 url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;, methods: &#x27;get&#x27;&#125;).then(res =&gt; &#123; console.log(res);&#125;)/*axios (&#123; //url: &#x27;httpbin.org/&#x27; 这个可以用来测试 url: &#x27;http://123.207.32.32:8000/home/data?type=sell&amp;page=3&#x27;,&#125;).then(res =&gt; &#123; console.log(res);&#125;)*/axios (&#123; //url: &#x27;httpbin.org/&#x27; 这个可以用来测试 url: &#x27;http://123.207.32.32:8000/home/data&#x27;, // 专门针对get请求的参数拼接 params: &#123; type: &#x27;pop&#x27;, page: 1 &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;) 3.4. axios发送并发请求 axios.all，可以放入多个请求的数组 axios.all([])返回的结果是一个数组，使用axios.spread可将数组[res1,res2]展开为res1,res2 123456789101112131415161718192021222324252627// 2. axios发送并发请求/*axios.all([axios(&#123; url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;,&#125;), axios(&#123; url: &#x27;http://123.207.32.32:8000/home/data&#x27;, params: &#123; type: &#x27;sell&#x27;, page: 5 &#125;&#125;)]).then(results =&gt; &#123; console.log(results); console.log(results[0]); console.log(results[1]);&#125;)*/axios.all([axios(&#123; url: &#x27;http://123.207.32.32:8000/home/multidata&#x27;,&#125;), axios(&#123; url: &#x27;http://123.207.32.32:8000/home/data&#x27;, params: &#123; type: &#x27;sell&#x27;, page: 5 &#125;&#125;)]).then(axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2);&#125;)) 3.4. 全局配置 123456789101112131415axios.defaults.baseURL = &#x27;http://123.207.32.32:8000&#x27;axios.defaults.timeout = 5axios.all([axios(&#123; url: &#x27;/home/multidata&#x27;,&#125;), axios(&#123; url: &#x27;/home/data&#x27;, params: &#123; type: &#x27;sell&#x27;, page: 5000 &#125;&#125;)]).then(axios.spread((res1, res2) =&gt; &#123; console.log(res1); console.log(res2);&#125;)) 3.4. 常见配置选项 3.5. 创建对应的axios实例1234567891011121314151617181920212223242526// 4. 创建对应的axios实例const instance = axios.create(&#123; baseUrl: &#x27;http://123.207.32.32:8000&#x27;, timeout: 5000&#125;)instance1(&#123; url: &#x27;/home/multidata&#x27;&#125;).then(res =&gt; &#123; console.log(res);&#125;)instance1(&#123; url: &#x27;/home/data&#x27;, params: &#123; type: &#x27;pop&#x27;, page: 1 &#125;&#125;).then(res =&gt; &#123; console.log(res);&#125;)const instence2 = axios.create(&#123; baseURL: &#x27;&#x27;, timeout: 10000&#125;) 3.6. 封装request模块123456789101112131415161718// 5. 封装request模块import &#123;request&#125; from &quot;./network/request&quot;;/*request(&#123; url: &#x27;/home/multidata&#x27;&#125;, res =&gt; &#123; console.log(res);&#125;, err =&gt; &#123; console.log(err);&#125;)*/request(&#123; url: &#x27;/home/multidata&#x27;&#125;).then(res =&gt; &#123; console.log(res);&#125;).catch(err =&gt; &#123; console.log(err);&#125;) network -&gt; request.js 12345678910import axios from &#39;axios&#39;export function request(config) &#123; &#x2F;&#x2F; 1. 创建axios实例 const instance &#x3D; axios.create(&#123; baseUrl: &#39;http:&#x2F;&#x2F;123.207.32.32:8000&#39;, timeout: 5000 &#125;) &#x2F;&#x2F; 2. 发送真正的网络请求 return instance(config)&#125; 3.7. axios的拦截器 请求拦截的作用 响应拦截 123456789101112131415161718192021222324252627export function request(config) &#123; // 1. 创建axios实例 const instance = axios.create(&#123; baseUrl: &#x27;http://123.207.32.32:8000&#x27;, timeout: 5000 &#125;) // 2. axios的拦截器 instance.interceptors.request.use(config =&gt; &#123; // console.log(config); // 2.1 请求拦截的作用 // 1.比如config中的一些信息不符合服务器要求 // 2.比如每次发送网络请求时，都希望在界面中显示一个请求的图标 show // 3.某些网络请求（比如登陆（token）），必须携带一些特殊信息 return config &#125;, err =&gt; &#123; // console.log(err); &#125;) // 2.2 响应拦截 instance.interceptors.response.use(res =&gt; &#123; // console.log(res); return res.data &#125;), err =&gt; &#123; console.log(err); &#125; // 3. 发送真正的网络请求 return instance(config)&#125; 四、项目开发123git branch -M maingit remote add origin git@github.com:yzhou15/supermall.gitgit push -u origin main 4.1. 划分目录结构4.2. 引入CSS文件：root 伪类 获取根元素html 4.3. vue.config.js 和 editorconfig别名配置vue.config.js 12345678910111213module.exports = &#123; configureWebpack: &#123; resolve: &#123; alias: &#123; &#x27;assets&#x27;: &#x27;@/assets&#x27;, &#x27;common&#x27;: &#x27;@/common&#x27;, &#x27;components&#x27;: &#x27;@/components&#x27;, &#x27;network&#x27;: &#x27;@/network&#x27;, &#x27;views&#x27;: &#x27;@/views&#x27;, &#125; &#125; &#125;&#125; 4.4. 项目的横向划分：tabbar -&gt; 路由的映射关系以前网页服务端渲染用jsp 4.5. navbar 轮播图1234567// 函数调用-&gt; 压入函数栈（保存函数调用过程中的所有变量）// 函数调用结束 -&gt; 弹出函数栈（释放函数所有的变量）function text() &#123; const names = [&#x27;why&#x27;, &#x27;aaa&#x27;]&#125;test() 垃圾回收 vueui库：mint-ui/iview","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"vue生命周期","slug":"Vue生命周期","date":"2021-04-20T14:51:18.000Z","updated":"2021-05-25T04:08:35.762Z","comments":true,"path":"2021/04/20/Vue生命周期/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"","text":"生命周期：事物从诞生到消亡的整个过程 debug开发的版本 build:release稳定的版本 Vue生命周期：（钩子函数） new Vue会执行一系列操作，通过钩子回调函数call hook created：可以做网络请求 mounted vbom更新 destroyed","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"docker","slug":"docker","date":"2021-04-20T14:51:18.000Z","updated":"2021-05-25T04:07:05.144Z","comments":true,"path":"2021/04/20/docker/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/docker/","excerpt":"","text":"什么是 Docker ◆使用最广泛的开源容器引擎 ◆一种操作系统级的虚拟化技术 ◆依赖于 Linux内核特性：Namespace和 Groups个简单的应用程序打包工具 123456root@localhost -] docker run -i -t centos/bin/bashUnable to find image centos: latest locallyLatest: Pulling from Library/centos256b176beaff: Pull completeDigest: sha256: 5d9lc5535c41fd1bb48d4058la2c8b 53d38fc2eb26df774556b 53c 5a0bd4d44eStatus: Downloaded newer image for centos: latest","categories":[{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/tags/docker/"}]},{"title":"外卖项目","slug":"guiguwaimai","date":"2021-04-20T14:51:18.000Z","updated":"2021-05-25T04:07:45.268Z","comments":true,"path":"2021/04/20/guiguwaimai/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/guiguwaimai/","excerpt":"","text":"1.基于 Vue 的最新版本； 2.项目是关于外卖业务的前后台分离Web App，功能模块包含商家, 商品, 购物车, 用户管理等多个模块； 3.后台应用技术架构为: Node + Express + Mongodb + Mongoose； 4.前台应用技术架构为: vue + vuex + vue-router + webpack + ES6； 5.采用模块化、组件化、工程化的模式开发； 项目描述：一个外卖Web App(SPA)前后台分离项目，包括商家，商品，购物车，用户等多个子模块；使用Vue全家桶+ES6+Webpack等，采用模块化、组件化、工程化的模式开发 技术选型： 前台数据处理、交互、组件化： vue全家桶、技术栈： vue vue-router(路由) vuex(管理状态) mint-ui(ui组件库) vue-lazyload(懒家，实现图片惰加载) 滑动库： vue-scroller(插件) better-scroll 日期处理 swiper(滑动，做轮播) monent date-fns 前后台交互 mock数据：mockjs(模拟) 接口测试：postman ajax请求 vue-resource axios 模块化 ES6 babel 项目构建、工程化 webpack(项目构建) vue-cli(创建工程化项目) eslint(检查语法是否规范) css预编译器 stylus","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"品优购","slug":"xiangmu","date":"2021-04-20T14:51:18.000Z","updated":"2021-05-25T04:09:38.240Z","comments":true,"path":"2021/04/20/xiangmu/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/xiangmu/","excerpt":"","text":"项目名称：品优购 项目描述：品优购是一个电商网站，主要完成PC端首页、列表页、注册页面的制作 开发工具：VScode、Photoshop(fw)、主流浏览器(以Chrome浏览器为主) 技术栈： 利用HTML5 + CSS3手动布局，大量使用H5新增标签和样式 采取结构与样式相分离，模块化开发 代码规范 模块化开发： 样式和结构重复出现，单独做成一个模块 例如common.css 重复使用、修改方便 项目名称：黑马面面布局开发 项目描述：移动端页面开发流程、掌握移动端常见布局思路 技术栈： 弹性盒子 + rem + LESS flex + rem + + flexible.js + LESS 最小适配设备为iphone5 320px 最大设配设备为iphone8plus","categories":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"}],"tags":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/tags/html-css/"}]},{"title":"heimamm","slug":"黑马面面移动页面布局","date":"2021-04-20T14:51:18.000Z","updated":"2021-05-25T04:10:41.835Z","comments":true,"path":"2021/04/20/黑马面面移动页面布局/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/20/%E9%BB%91%E9%A9%AC%E9%9D%A2%E9%9D%A2%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/","excerpt":"","text":"黑马面面布局开发一、目的 了解移动端页面开发流程 掌握移动端常见布局思路 1.1 技术方案121. 弹性盒子 + rem + LESS 4. 最小适配设备为iphone5 320px 最大设配设备为iphone8plus(ipad能正常查看内容即可) 1.2 代码规范123456789101. 类名语义化,尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线“_” 连接2. 类名嵌套层次尽量不超过三层3. 尽量避免直接使用元素选择器4. 属性书写顺序 布局定位属性：display / position / float / clear / visibility / overflow 尺寸属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow5. 避免使用id选择器6. 避免使用通配符*和!important 1.2 目录规范12345项目文件夹：heimamm 样式文件夹：css 业务类图片文件夹：images 样式类图片文件夹： icons 字体类文件夹： fonts 二、流程开发2.1 蓝湖/摹客协作平台 UI设计师 psd效果图完成后，会上传到蓝湖//摹客里面，同时会拉前端工程师进入开发 大部分情况下，UI会把图片按照前端设计要求给切好 UI设计师 上传蓝湖到或者/摹客（了解） 12345671. /摹客官网地址： https://www.mockplus.cn/ 注册一个账号2. 下载moke ps插件 3. PS 安装/摹客/蓝湖插件3. 打开PS/摹客/蓝湖插件4. 上传（需要切图，需要先标注切图）5. 查看项目6. 邀请成员进入（分享按钮，链接地址） 前端设计师可以直接/摹客/蓝湖测量取值 2.2 适配方案 flex 布局 百分比布局 rem布局 vw/vh布局 响应式布局 本次案例 flex + rem + + flexible.js + LESS 2.3 初始化文件 引入 normalize.css less 中 初始化body样式 约束范围 ~~~css@media screen and (min-width: 750px) { html { font-size: 37.5px !important; }} 123456789101112#### 2.4 布局模块1. 头部模块 .header 高度为 80px 2. nav 模块制作 多用 flex3. 充电学习 阴影 ~~~css box-shadow: 0 0px 10px rgba(0, 0, 0, 0.1) 2.5 swiper 插件使用官网地址：https://www.swiper.com.cn/ 下载需要的css和js文件 html页面中 引入相关文件 官网找到类似案例，复制html结构，css样式 js 语法 根据需求定制修改模块 2.6 图标字体上传下载上传步骤： 让UI美工准备好 图标字体（必须是svg格式） 点上传按钮（保留颜色并提交） 生成之后加入购物车即可 点击下载 — 下载代码 小技巧： 如何批量下载全部字体图标呢？ 12345var span = document.querySelectorAll(&#x27;.icon-cover&#x27;);for (var i = 0, len = span.length; i &lt; len; i++) &#123; console.log(span[i].querySelector(&#x27;span&#x27;).click());&#125; 2.7 上传码云并发布部署静态网站准备工作： 需要下载git软件 需要码云注册账号 git 可以把我们的本地网站提交上传到远程仓库（码云 gitee）里面 类似以前的 ftp 码云 就是远程仓库， 类似服务器 码云创建新的仓库。 heimamm 利用git 提交 把本地网站提交到 码云新建的仓库里面 在网站根目录右键– Git Bash Here 如果是第一次利用git提交，请配置好全局选项 12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;你的邮箱地址&quot; 初始化仓库 1git init 把本地文件放到暂存区 1git add . 把本地文件放到本地仓库里面 1git commit -m &#x27;提交黑马面面网站&#x27; 链接远程仓库 1git remote add origin 你新建的仓库地址 把本地仓库的文件推送到远程仓库 push 1git push -u origin master 码云部署发布静态网站 在当前仓库中，点击 “服务” 菜单 选择 Gitee Pages 选择 “启动” 按钮 稍等之后，会拿到地址，就可以利用这个地址来预览网页了 当然你也可以利用 草料二维码 生成二维码 https://cli.im/ 最后： 如果提交网站，你不愿意用git 提交， 可以直接找到仓库，里面有文件，选择上传本地文件即可。 但是，1个小时内，只能上传 20个以内的文件， 前端人员，git必备技能","categories":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"}],"tags":[{"name":"flex rem less","slug":"flex-rem-less","permalink":"https://yzhou15.gitee.io/tags/flex-rem-less/"}]},{"title":"next配置","slug":"next配置","date":"2021-04-10T04:45:10.000Z","updated":"2021-04-22T12:12:17.716Z","comments":true,"path":"2021/04/10/next配置/","link":"","permalink":"https://yzhou15.gitee.io/2021/04/10/next%E9%85%8D%E7%BD%AE/","excerpt":"","text":"转载自：https://blog.csdn.net/qq_35396510/article/details/105953460 hexo 主题 next7.8 版本配置美化 转载自：https://www.jianshu.com/p/6f9e732b1f9f Hexo的Next主题详细配置 72017.11.29 16:21:02字数 1,902阅读 53,047 经过一番不懈的努力，我们终于按照Hexo免费搭建一个属于自己的博客搭建好了一个属于自己的博客，并且还安装了一个Next主题，但是我们的博客一开始还是很简陋的，我们需要把她装修一下。 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为**站点配置文件*， 后者称为主题配置文件***。 以下所有终端执行的命令都在你的Hexo根目录下 1、基本信息配置 基本信息包括：博客标题、作者、描述、语言等等。 打开 *站点配置文件* ，找到Site模块 123456title: 标题subtitle: 副标题description: 描述author: 作者language: 语言（简体中文是zh-Hans）timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写） 关于 *站点配置文件* 中的其他配置可参考站点配置 2、菜单设置 菜单包括：首页、归档、分类、标签、关于等等 我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 *主题配置文件* 找到Menu Settings 123456789menu: home: / || home //首页 archives: /archives/ || archive //归档 categories: /categories/ || th //分类 tags: /tags/ || tags //标签 about: /about/ || user //关于 #schedule: /schedule/ || calendar //日程表 #sitemap: /sitemap.xml || sitemap //站点地图 #commonweal: /404/ || heartbeat //公益404 看看你需要哪个菜单就把哪个取消注释打开就行了；关于后面的格式，以archives: /archives/ || archive为例：|| 之前的/archives/表示标题“归档”，关于标题的格式可以去themes/next/languages/zh-Hans.yml中参考或修改||之后的archive表示图标，可以去Font Awesome中查看或修改，Next主题所有的图标都来自Font Awesome。 3、Next主题样式设置我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 *主题配置文件* 找到Scheme Settings 12345# Schemes# scheme: Muse# scheme: Mist# scheme: Piscesscheme: Gemini 4种风格大同小异，本人用的是Gemini风格，你们可以选择自己喜欢的风格。 4、侧栏设置 侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等 打开 *主题配置文件* 找到sidebar字段 12345678910111213141516sidebar:# Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效） position: left //靠左放置 #position: right //靠右放置# Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效） #display: post //默认行为，在文章页面（拥有目录列表）时显示 display: always //在所有页面中都显示 #display: hide //在所有页面中都隐藏（可以手动展开） #display: remove //完全移除 offset: 12 //文章间距（只对Pisces | Gemini两种风格有效） b2t: false //返回顶部按钮（只对Pisces | Gemini两种风格有效） scrollpercent: true //返回顶部按钮的百分比 5、头像设置打开 *主题配置文件* 找到Sidebar Avatar字段 12# Sidebar Avataravatar: /images/header.jpg 这是头像的路径，只需把你的头像命名为header.jpg（随便命名）放入themes/next/source/images中，将avatar的路径名改成你的头像名就OK啦！ 6、设置RSS1、先安装 hexo-generator-feed 插件 1$ npm install hexo-generator-feed --save 2、打开 *站点配置文件* 找到Extensions在下面添加 123456789# RSS订阅feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: &#x27; &#x27; 3、打开 *主题配置文件* 找到rss，设置为 1rss: &#x2F;atom.xml 7、添加分类模块1、新建一个分类页面 1$ hexo new page categories 2、你会发现你的source文件夹下有了categorcies/index.md，打开index.md文件将title设置为title: 分类3、打开 *主题配置文件* 找到menu，将categorcies取消注释4、把文章归入分类只需在文章的顶部标题下方添加categories字段，即可自动创建分类名并加入对应的分类中举个栗子： 12title: 分类测试文章标题categories: 分类名 8、添加标签模块1、新建一个标签页面 1$ hexo new page tags 2、你会发现你的source文件夹下有了tags/index.md，打开index.md文件将title设置为title: 标签3、打开 *主题配置文件* 找到menu，将tags取消注释4、把文章添加标签只需在文章的顶部标题下方添加tags字段，即可自动创建标签名并归入对应的标签中举个栗子： 12345title: 标签测试文章标题tags: - 标签1 - 标签2 ... 9、添加关于模块1、新建一个关于页面 1$ hexo new page about 2、你会发现你的source文件夹下有了about/index.md，打开index.md文件即可编辑关于你的信息，可以随便编辑。3、打开 *主题配置文件* 找到menu，将about取消注释 10、添加搜索功能1、安装 hexo-generator-searchdb 插件 1$ npm install hexo-generator-searchdb --save 2、打开 *站点配置文件* 找到Extensions在下面添加 123456# 搜索search: path: search.xml field: post format: html limit: 10000 3、打开 *主题配置文件* 找到Local search，将enable设置为true 11、添加阅读全文按钮因为在你的博客主页会有多篇文章，如果你想让你的文章只显示一部分，多余的可以点击阅读全文来查看，那么你需要在你的文章中添加 1&lt;!--more--&gt; 其后面的部分就不会显示了，只能点击阅读全文才能看 12、修改文章内链接文本样式 效果图 打开文件 themes/next/source/css/_common/components/post/post.styl，在末尾添加 12345678910.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 13、设置网站缩略图标 从网上看了很多设置方法都是说把favicon.ico放到站点目录的source目录下就可以了，可是我试了好多遍，并不行。 我的设置方法是这样的：把你的图片（png或jpg格式，不是favicon.ico）放在themes/next/source/images里，然后打开 *主题配置文件* 找到favicon，将small、medium、apple_touch_icon三个字段的值都设置成/images/图片名.jpg就可以了，其他字段都注释掉。 14、设置文章字体的颜色、大小 效果图 如果想设置某一句的颜色或大小，只需用html语法写出来就行了 1234接下来就是见证奇迹的时刻&lt;font color=&quot;#FF0000&quot;&gt; 我可以设置这一句的颜色哈哈 &lt;/font&gt; &lt;font size=6&gt; 我还可以设置这一句的大小嘻嘻 &lt;/font&gt; &lt;font size=5 color=&quot;#FF0000&quot;&gt; 我甚至可以设置这一句的颜色和大小呵呵&lt;/font&gt; 15、设置文字居中设置方法： 1&lt;center&gt;这一行需要居中&lt;/center&gt; 注意：简书中此方法无效 16、添加评论系统 目前国内比较有名的多说、网易云跟帖评论系统都已停止服务了，国外的Disqus评论系统还得需要翻墙，所以不推荐使用，剩下的还有搜狐畅言、友言、来必力等。本来想使用畅言的，结果注册完之后还得要求备案，我只想说F开头的那个单词，果断放弃。后来选择了友言 1、进入友言官网注册、登录步骤我就不介绍了2、登录完成之后，点击获取代码，你会发现出来了一段代码，里面有你的uid=12345673、打开 *主题配置文件* 找到youyan_uid将值设置为上面的uid就可以了 17、添加站点访问计数站点访问计数有名的就是不蒜子，使用起来非常方便1、安装脚本打开 themes/next/layout/_partial/footer.swig，将下面这段代码添加到里面 12345678910&lt;div&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot; style=&#x27;display:none&#x27;&gt; 本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次 &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot; style=&#x27;display:none&#x27;&gt; 有&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人看过我的博客啦&lt;/span&gt;&lt;/div&gt; 添加的位置如下图，可自行根据个人喜好更换位置 2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 themes/next/layout/_macro/post.swig，在第一行增加is_pv字段 1&#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 然后将这段代码插入到里面 1234&#123;% if is_pv %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次阅读&#123;% endif %&#125; 插入的位置 然后再打开 themes/next/layout/post.swig，这个文件是文章的模板，给render方法传入参数（对应刚才添加的is_pv字段） 最后再打开 themes/next/layout/index.swig，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段） OK！设置完毕。 18、去掉文章目录标题的自动编号我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？打开***主题配置文件***，找到 将number改为false即可 18、更多1、还有其他更多的主题配置，请查看主题配置2、还有其他更多的插件，请查看Hexo插件","categories":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"}]},{"title":"vueDay4","slug":"vueDay4","date":"2021-03-20T14:51:18.000Z","updated":"2021-05-25T12:23:41.417Z","comments":true,"path":"2021/03/20/vueDay4/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/20/vueDay4/","excerpt":"","text":"一、Vue CLI 安装脚手架遇到问题可以尝试清空这个文件夹 1C:\\Users\\yzhou\\AppData\\Roaming\\npm-cache parse解析 1.1. runtime+compiler和runtime-only的区别 **runtime+compile:**template -&gt; ast -&gt; render -&gt; virtual dom -&gt; 真实DOM runtime-only: virtual dom -&gt; 真实DOM 性能更高 代码量更少 箭头函数render: (h) =&gt; h, -&gt;本质上是creatElement ESlint render -&gt; vdom -&gt; UI 1.2. 认识Vue CLI3vue2.5.21 -&gt; vue2.x -&gt; flow-type(facebook) vue3.x -&gt; TypeScript(microsoft) webpack4 （v2webpack3） 设计原则0配置 vue ui 可视化配置，更加人性化 移除static，新增public，将index.html移动到public中 preset配置 feature特性 rc-&gt;run command vcs-&gt;version control system(版本控制git/svn) 如何通过CLI3创建项目 CLI3的目录结构 vue配置文件的查看和修改 vue ui 去找隐藏的配置文件 自定义vue.config.js 二、Vue-Router2.1 认识路由 后端渲染\\后端渲染 前后端分离 SPA\\前端路由 路由（routing）：通过互联的网络把信息从源地址传输到目的地址的活动 映射关系：ip地址：mac地址 2.1.1 前端渲染和后端渲染：历史阶段： 后端渲染阶段后端路由阶段■早期的网站开发整个HTML页面是由服务器来渲染的口服务器直接生产渲染好对应的HTML页面,返回给客户端进行展示■但是,一个网站,这么多页面服务器如何处理呢?口一个页面有自己对应的网址,也就是URL口URL会发送到服务器,服务器会通过正则对该URL进行匹配并且最后交给一个 Controller进行处理口 Controller进行各种处理,最终生成HTML或者数据,返回给前端口这就完成了一个1O操作■上面的这种操作就是后端路由.口当我们页面中需要请求不同的路径内容时,交给服务器来进行处理,服务器渲染好整个页面,并且将页面返回给客户顿口这种情况下渲染好的页面,不需要单独加载任何的s和cs,可以直接交给浏览器展示,这样也有利于SEO的优化后端路由的缺点口一种情况是整个页面的模块由后端人员来编写和维护的口另一种情况是前端开发人员如果要开发页面,需要通过PHP和Java等语言来编写页面代码.口而且通常情况下HTML代码和数据以及对应的逻辑会混在一起,编写和维护都是非常糟糕的事情. 前后端分离阶段口随着Ajax的出现有了前后端分离的开发模式口后端只提供AP来返回数据,前端通过Ajax获取数据并且可以通过 JavaScript将数据渲染到页面中口这样做最大的优点就是前后端责任的清晰,后端专注于数据上前端专注于交互和可视化上.口并且当移动端(ioS/ Android)出现后,后端不需要进行任何处理依然使用之前的一套API即可.口目前很多的网站依然采用这种模式开发 前端渲染阶段 ■单页面富应用阶段:口其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由口也就是前端来维护一套路由规则. 2.1.2.前端路由中url和组件的关系 2.1.3. 前端路由的核心 改变URL,但是页画不进行整体的刷新 改变URL的hash 1location.hash = &#x27;aaa&#x27; HTML5的history模式 1history.pushState(&#123;&#125;, &#x27;&#x27;, &#x27;home&#x27;) href-&gt;hyper reference 数据结构： 栈结构：先进后出 push入栈 HTML5的history模式：replaceState 1history.replaceState(&#123;&#125;, &#x27;&#x27;, &#x27;home&#x27;) history.go() 因为 history. back0等价于 history. go(-1)history forward0则等价于 history. go(1)这三个接口等同于浏览器界面的前进后退。 三大框架路由实现： Angular-&gt;ngRouter React-&gt;ReactRouter Vue-&gt;vue-router 2.2. vue-router基本使用2.2.1. 安装步骤 安装 1npm install vue-router --save 在模块化工程中使用,搭建路由框架 导入路由对象，并且调用Vue.use(VueRouter) 创建路由实例，并且传入路由映射配置 在Vue实例中挂载创建的路由实例 router=&gt;index.js 1234567891011121314151617181920// 配置路由相关信息import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import HelloWorld from &#x27;@/components/HelloWorld&#x27;// 1. 通过VUe.use(插件)，安装插件Vue.use(Router)// 2. 创建VueRouter对象// 3. 将router对象传入到Vue实例export default new Router(&#123; // 配置路由和组件之间的应用关系 routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;HelloWorld&#x27;, component: HelloWorld &#125; ]&#125;) main.js中挂载 1import router from &#x27;./router&#x27; 配置路由映射关系步骤： 创建路由组件 配置路由映射：组件和路径映射关系 使用路由：通过和 router=&gt;index.js 123456789101112131415import Home from &#x27;../components/Home&#x27;import About from &quot;../components/About&quot;export default new Router(&#123; // 配置路由和组件之间的映射关系 routes: [ &#123; path: &#x27;/home&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, component: About &#125; ]&#125;) App.vue中 123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; // 渲染成a标签，改变hash &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; // 栈位，动态渲染不同的组件 &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt; 2.2.2. 配置默认路径123456789export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, // redirect重定向 redirect: &#x27;/home&#x27; &#125; ]&#125;) 2.2.3. 添加history在index.js中可以消除地址栏中‘#’123export default new Router(&#123; mode: &#x27;history&#x27;&#125;) 2.2.4. router-link补充 tag: tag可以指定渲染成什么组件,比如下面的代码会渲染成一个,而不是 1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;首页&lt;/router-link&gt; replace: 不会留下history记录，后退键不能返回到上一个界面中 1&lt;router-link to=&quot;/home&quot; tag=&quot;button&quot; replace&gt;首页&lt;/router-link&gt; active-class:修改默认的类名称 123export default new Router(&#123; linkActiveClass: &#x27;active&#x27;&#125;) 2.2.5. 路由代码跳转App.vue 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;homeClick&quot;&gt;首页&lt;/button&gt; &lt;button @click=&quot;aboutClick&quot;&gt;关于&lt;/button&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;, methods: &#123; homeClick() &#123; // 路由代码跳转 // this.$router.push(&#x27;/home&#x27;) this.$router.replace(&#x27;/home&#x27;) console.log(&#x27;homeClick&#x27;); &#125;, aboutClick() &#123; this.$router.push(&#x27;/about&#x27;) console.log(&#x27;aboutClick&#x27;); &#125; &#125;&#125;&lt;/script&gt; 2.2.6. 动态路由的使用 /user/:id params-&gt;parameters参数 this.$route.params.id 2.2.7. 认识路由的懒加载-打包文件的解析用到时再加载 12345678懒加载的方式■方式一:结合Wue的异步组件和 Webpack的代码分析const Home resolve =&gt;i require ensure([ ./components /Home. vue],O=&gt;I resolve(require (./components/Home. vue ))))■方式二:AMD写法const About resolve = require([ ./components/About. vue&#x27;l, resolve)方式三:在ES6中我们可以有更加简单的写法来组织vue异步组件和 Webpack的代码分割const Home = ON&gt; import(./components/Home. vue &#x27;) 2.3. vue-router嵌套路由 children:[] index.html 123456789101112131415161718routes: [&#123; path: &#x27;/home&#x27;, component: Home, children: [ &#123; path: &#x27;&#x27;, redirect: &#x27;news&#x27; &#125;, &#123; path: &#x27;news&#x27;, component: HomeNews &#125;, &#123; path: &#x27;message&#x27;, component: HomeMessage &#125;] 2.4. vue-router参数传递profile -&gt; 档案（用于‘我的’的用户界面） 准备工作： 创建新的组件Profile.vue 配置路由映射 添加跳转的 传递参数类型： params的类型 配置动态路由：/router/:id 传递的方式：在path后面跟上对应的值 传递后形成的路径：/router/123,/router/abc query 配置路由/router普通配置 传递的方式：对象中使用query的key作为传递方式 传递后形成的路径：/router?id=123, /router?id=abc URL: 协议://主机:端口/路径?查询#片段哈希值 scheme://localhost:portt/path?query#fragment 所有的组件都继承着vue类的原型 2.5. vue-router导航守卫 全局导航守卫 路由独享守卫 组件类守卫 生命周期函数： init lifecycle beforeCreates如果有的话回调 init 响应式等其他东西 created(){}-&gt;创建组件时 挂载el、template beforemounted 创建vm替换el mounter(){} -&gt;template挂载到组件时 做响应式检测回调beforeUpdate 重新渲染vdom,然后patch打补丁 updated(){} -&gt;界面刷新时 beforeDestory后做一些回收的操作 destroyed(){}-&gt;销毁 meta：元数据-&gt;描述数据的数据 metaclass元类可以创建类对象，接着创建实例对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 配置路由相关信息import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;// import Home from &#x27;../components/Home&#x27;// import About from &quot;../components/About&quot;const Home = () =&gt; import(&#x27;../components/Home&#x27;)const HomeNews = () =&gt; import(&#x27;../components/HomeNews&#x27;)const HomeMessage = () =&gt; import(&#x27;../components/HomeMessage&#x27;)const About = () =&gt; import(&#x27;../components/About&#x27;)const User = () =&gt; import(&#x27;../components/User&#x27;)const Profile = () =&gt; import(&#x27;../components/Profile&#x27;)// 1. 通过VUe.use(插件)，安装插件// 2. 创建VueRouter对象Vue.use(Router)// 配置路由和组件之间的映射关系const routes = [ &#123; path: &#x27;&#x27;, // redirect重定向 redirect: &#x27;/home&#x27; &#125;, &#123; path: &#x27;/home&#x27;, component: Home, meta: &#123; title: &#x27;首页&#x27; &#125;, children: [ &#123; path: &#x27;&#x27;, redirect: &#x27;news&#x27; &#125;, &#123; path: &#x27;news&#x27;, component: HomeNews &#125;, &#123; path: &#x27;message&#x27;, component: HomeMessage &#125; ] &#125;, &#123; path: &#x27;/about&#x27;, component: About, meta: &#123; title: &#x27;关于&#x27; &#125;, &#125;, &#123; path: &#x27;/user/:userId&#x27;, component: User, meta: &#123; title: &#x27;用户&#x27; &#125;, &#125;, &#123; path: &#x27;/profile&#x27;, component: Profile, meta: &#123; title: &#x27;档案&#x27; &#125;, &#125;]// 3. 将router对象传入到Vue实例const router = new Router(&#123; routes, mode: &#x27;history&#x27;, linkActiveClass: &#x27;active&#x27;&#125;)// 导航守卫// 全局导航// 前置守卫(guard)router.beforeEach((to, from, next) =&gt; &#123;// 从from跳转到to document.title = to.matched[0].meta.title console.log(&#x27;++++&#x27;) next()&#125;)// 后置钩子(hook)router.afterEach((to, from) =&gt; &#123; console.log(&#x27;----&#x27;)&#125;)export default router 2.6. keep-alive keep-alie是Wue内置的一个组件,可以使被包含的组件保留状态,或避免重新渲染 它们有两个非常重要的属性: include-字符串或正则表达,只有匹配的组件会被缓存 exclude-字符串或正则表达式,任问匹配的组件都不会被缓存 router-view也是一个组件,如果直接被包在keep-aive里面,所有路径匹配到的视图组件都会被缓存 在keep-alive下才能使用activated/deactived这两个函数 (不常用)首页中使用path属性记录离开时的路径，在beforeRouteLeave中记录 App.vue 123&lt;keep-alive&gt; &lt;router-view&#x2F;&gt;&lt;&#x2F;keep-alive&gt; Home.vue 1234567891011121314151617181920212223export default &#123; name: &quot;Home&quot;, data()&#123; return &#123; message: &#39;你好啊&#39; &#125; &#125;, created() &#123; console.log(&#39;home created&#39;); &#125;, destroyed() &#123; console.log(&#39;home destroyed&#39;) &#125;, activated()&#123; &#x2F;&#x2F; console.log(&#39;activated&#39;) this.$router.push(this.path); &#125;, beforeRouteLeave(to, from, next) &#123; console.log(this.$router.path); this.path &#x3D; this.$route.path; next() &#125;&#125; 2.9. TabBar的封装过程 如果在下方有一个单独的 TabBar组件,你如何封装 自定义 Tabbar组件,在APP中使用 让 TabBar出于底部,并且设置相关的样式 TabBar中显示的内容由外界决定 定义插槽 fex布局平分 TabBar 自定义 TabBarlten,可以传入图片和文字 定义 TabBarltem,并且定义两个插槽:图片、文字。 给两个插槽外层包装div,用于设置样式 填充插槽,实现底部 TabBar的效果 传入高亮图片 定义另外一个插槽,插入 active-icon的数据 定义一个变量 inActive,通过 v-show来决定是否显示对应的icon TabBarlten绑定路由数据 安装路由 T npm install vue-router-save 完成 router/ ndex jsf的内容,以及创建对应的组件 main s中注册 router APP中加入&lt; router-view&gt;组件 点击item跳转到对应路由,并且动态决定 inActive 监听tem的点击,通过this. Router. replace0替换路由路径 通过this. Route path. indexof( this link!==-1来判断是否是 active 动态计算 active样式 封装新的计算属性: this inActive? color:’red}:","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"代码规范","slug":"品优购代码规范","date":"2021-03-19T16:00:00.000Z","updated":"2021-05-25T04:16:48.512Z","comments":true,"path":"2021/03/20/品优购代码规范/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/20/%E5%93%81%E4%BC%98%E8%B4%AD%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"","text":"1. 概述欢迎使用品优购代码规范， 这个是我借鉴京东前端代码规范，组织的品优购内部规范。旨在增强团队开发协作、提高代码质量和打造开发基石的编码规范， 以下规范是团队基本约定的内容，必须严格遵循。 HTML规范基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。 图片规范了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。 CSS规范统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。 命名规范从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。 2. HTML 规范DOCTYPE 声明HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明： 1&lt;!DOCTYPE html&gt; HTML5标准模版 12345678910&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML5标准模版&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 页面语言lang推荐使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值 1&lt;html lang&#x3D;&quot;zh-CN&quot;&gt; 更多地区语言参考： 1234zh-SG 中文 (简体, 新加坡) 对应 cmn-Hans-SG 普通话 (简体, 新加坡)zh-HK 中文 (繁体, 香港) 对应 cmn-Hant-HK 普通话 (繁体, 香港)zh-MO 中文 (繁体, 澳门) 对应 cmn-Hant-MO 普通话 (繁体, 澳门)zh-TW 中文 (繁体, 台湾) 对应 cmn-Hant-TW 普通话 (繁体, 台湾) charset 字符集合一般情况下统一使用 “UTF-8” 编码 1&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; 由于历史原因，有些业务可能会使用 “GBK” 编码 1&lt;meta charset&#x3D;&quot;GBK&quot;&gt; 请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF对UTF-8的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。 书写风格HTML代码大小写HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： 1&lt;div class&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;div&gt; 不推荐： 123&lt;div class&#x3D;&quot;DEMO&quot;&gt;&lt;&#x2F;div&gt; &lt;DIV CLASS&#x3D;&quot;DEMO&quot;&gt;&lt;&#x2F;DIV&gt; 类型属性不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含 推荐： 12&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&quot; &gt;&lt;script src&#x3D;&quot;&quot;&gt;&lt;&#x2F;script&gt; 不推荐： 12&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;&quot; &gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&quot; &gt;&lt;&#x2F;script&gt; 元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： 12&lt;input type&#x3D;&quot;text&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;name&quot; checked&#x3D;&quot;checked&quot; &gt; 不推荐： 123&lt;input type&#x3D;text&gt; &lt;input type&#x3D;&#39;text&#39;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;name&quot; checked &gt; 特殊字符引用文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。 在 HTML 中不能使用小于号 “&lt;” 和大于号 “&gt;”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 推荐： 1&lt;a href&#x3D;&quot;#&quot;&gt;more&gt;&gt;&lt;&#x2F;a&gt; 不推荐： 1&lt;a href&#x3D;&quot;#&quot;&gt;more&gt;&gt;&lt;&#x2F;a&gt; 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 123&lt;div class&#x3D;&quot;jdc&quot;&gt; &lt;a href&#x3D;&quot;#&quot;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt; 代码嵌套元素嵌套规范，每个块状元素独立一行，内联元素可选 推荐： 12345&lt;div&gt; &lt;h1&gt;&lt;&#x2F;h1&gt; &lt;p&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; 不推荐： 1234567&lt;div&gt; &lt;h1&gt;&lt;&#x2F;h1&gt;&lt;p&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; &lt;p&gt; &lt;span&gt;&lt;&#x2F;span&gt; &lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; 段落元素与标题元素只能嵌套内联元素 推荐： 12&lt;h1&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;h1&gt;&lt;p&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; 不推荐： 12&lt;h1&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;h1&gt;&lt;p&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;&#x2F;p&gt; 3. 图片规范内容图内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式 尽量不使用PNG格式，PNG8 色位太低，PNG24 压缩率低，文件体积大 PC平台单张的图片的大小不应大于 200KB。 背景图背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片 PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG格式允许更多的颜色并提供更好的压缩率 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式 4. CSS规范代码格式化样式书写一般有两种：一种是紧凑格式 (Compact) 1.jdc&#123; display: block;width: 50px;&#125; 一种是展开格式（Expanded） 1234.jdc &#123; display: block; width: 50px;&#125; 团队约定 统一使用展开格式书写样式 代码大小写样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。 123456789&#x2F;* 推荐 *&#x2F;.jdc&#123; display:block;&#125; &#x2F;* 不推荐 *&#x2F;.JDC&#123; DISPLAY:BLOCK;&#125; 选择器 尽量少用通用选择器 * 不使用 ID 选择器 不使用无具体语义定义的标签选择器 123456789/* 推荐 */.jdc &#123;&#125;.jdc li &#123;&#125;.jdc li p&#123;&#125;/* 不推荐 */*&#123;&#125;#jdc &#123;&#125;.jdc div&#123;&#125; 代码缩进统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置） 1234.jdc &#123; width: 100%; height: 100%;&#125; 分号每个属性声明末尾都要加分号； 1234.jdc &#123; width: 100%; height: 100%;&#125; 代码易读性左括号与类名之间一个空格，冒号与属性值之间一个空格 推荐： 123.jdc &#123; width: 100%; &#125; 不推荐： 123.jdc&#123; width:100%;&#125; 逗号分隔的取值，逗号之后一个空格 推荐： 123.jdc &#123; box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;&#125; 不推荐： 123.jdc &#123; box-shadow: 1px 1px 1px #333,2px 2px 2px #ccc;&#125; 为单个css选择器或新申明开启新行 推荐： 12345678.jdc, .jdc_logo, .jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 不推荐： 12345.jdc,jdc_logo,.jdc_hd &#123; color: #ff0;&#125;.nav&#123; color: #fff;&#125; 颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0 推荐： 123.jdc &#123; color: rgba(255,255,255,.5);&#125; 不推荐： 123.jdc &#123; color: rgba( 255, 255, 255, 0.5 );&#125; 属性值十六进制数值能用简写的尽量用简写 推荐： 123.jdc &#123; color: #fff;&#125; 不推荐： 123.jdc &#123; color: #ffffff;&#125; 不要为 0 指明单位 推荐： 123.jdc &#123; margin: 0 10px;&#125; 不推荐： 123.jdc &#123; margin: 0px 10px;&#125; 属性值引号css属性值需要用到引号时，统一使用单引号 123456789/* 推荐 */.jdc &#123; font-family: &#x27;Hiragino Sans GB&#x27;;&#125;/* 不推荐 */.jdc &#123; font-family: &quot;Hiragino Sans GB&quot;;&#125; 属性书写顺序建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.jdc &#123; display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, &#x27;Helvetica Neue&#x27;, Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;&#125; mozilla官方属性顺序推荐 命名规范由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。 目录命名 项目文件夹：shoping 样式文件夹：css 脚本文件夹：js 样式类图片文件夹：img 产品类图片文件夹： upload 字体类文件夹： fonts ClassName命名ClassName的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接 .nav_top 常用命名推荐注意：ad、banner、gg、guanggao 等有机会和广告挂勾的不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名，因此 1&lt;div class&#x3D;&quot;ad&quot;&gt;&lt;&#x2F;div&gt; 这种广告的英文或拼音类名不应该出现 另外，敏感不和谐字眼也不应该出现，如： 1234567&lt;div class&#x3D;&quot;fuck&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;jer&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;sm&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;gcd&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;ass&quot;&gt;&lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;KMT&quot;&gt;&lt;&#x2F;div&gt; ... ClassName 含义 about 关于 account 账户 arrow 箭头图标 article 文章 aside 边栏 audio 音频 avatar 头像 bg,background 背景 bar 栏（工具类） branding 品牌化 crumb,breadcrumbs 面包屑 btn,button 按钮 caption 标题，说明 category 分类 chart 图表 clearfix 清除浮动 close 关闭 col,column 列 comment 评论 community 社区 container 容器 content 内容 copyright 版权 current 当前态，选中态 default 默认 description 描述 details 细节 disabled 不可用 entry 文章，博文 error 错误 even 偶数，常用于多行列表或表格中 fail 失败（提示） feature 专题 fewer 收起 field 用于表单的输入区域 figure 图 filter 筛选 first 第一个，常用于列表中 footer 页脚 forum 论坛 gallery 画廊 group 模块，清除浮动 header 页头 help 帮助 hide 隐藏 hightlight 高亮 home 主页 icon 图标 info,information 信息 last 最后一个，常用于列表中 links 链接 login 登录 logout 退出 logo 标志 main 主体 menu 菜单 meta 作者、更新时间等信息栏，一般位于标题之下 module 模块 more 更多（展开） msg,message 消息 nav,navigation 导航 next 下一页 nub 小块 odd 奇数，常用于多行列表或表格中 off 鼠标离开 on 鼠标移过 output 输出 pagination 分页 pop,popup 弹窗 preview 预览 previous 上一页 primary 主要 progress 进度条 promotion 促销 rcommd,recommendations 推荐 reg,register 注册 save 保存 search 搜索 secondary 次要 section 区块 selected 已选 share 分享 show 显示 sidebar 边栏，侧栏 slide 幻灯片，图片切换 sort 排序 sub 次级的，子级的 submit 提交 subscribe 订阅 subtitle 副标题 success 成功（提示） summary 摘要 tab 标签页 table 表格 txt,text 文本 thumbnail 缩略图 time 时间 tips 提示 title 标题 video 视频 wrap 容器，包，一般用于最外层 wrapper 容器，包，一般用于最外层","categories":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"}],"tags":[{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/tags/html-css/"}]},{"title":"SpringMVC07-Ajax","slug":"SpringMVC07 Ajax","date":"2021-03-06T08:00:00.000Z","updated":"2021-05-25T04:17:29.544Z","comments":true,"path":"2021/03/06/SpringMVC07 Ajax/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/06/SpringMVC07%20Ajax/","excerpt":"","text":"[转发] Ajax研究 简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词。 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表。 就和国内百度的搜索框一样! 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页。 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新。 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面。 伪造Ajax 我们可以使用前端的一个标签来伪造一个ajax的样子。iframe标签 1、新建一个module ：sspringmvc-06-ajax ， 导入web支持！ 2、编写一个 ajax-frame.html 使用 iframe 测试，感受下效果 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang&#x3D;&quot;en&quot;&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;kuangshen&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; window.onload &#x3D; function()&#123; var myDate &#x3D; new Date(); document.getElementById(&#39;currentTime&#39;).innerText &#x3D; myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl &#x3D; document.getElementById(&#39;url&#39;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src &#x3D; targetUrl; &#125;&lt;&#x2F;script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id&#x3D;&quot;currentTime&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt; &lt;p&gt; &lt;input id&#x3D;&quot;url&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&#x2F;&gt; &lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;LoadPage()&quot;&gt; &lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;&#x2F;h3&gt; &lt;iframe id&#x3D;&quot;iframePosition&quot; style&#x3D;&quot;width: 100%;height: 500px;&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 3、使用IDEA开浏览器测试一下！ 利用AJAX可以做： 注册时，输入用户名自动检测用户是否已经存在。 登陆时，提示用户名密码错误 删除数据行时，将行ID发送到后台，后台在数据库中删除，数据库删除成功后，在页面DOM中将数据行也删除。 ….等等 jQuery.ajax 纯JS原生实现Ajax我们不去讲解这里，直接使用jquery提供的，方便学习和使用，避免重复造轮子，有兴趣的同学可以去了解下JS原生XMLHttpRequest ！ Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ 123456789101112131415161718192021jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback&#x3D;?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 我们来个简单的测试，使用最原始的HttpServletResponse处理 , .最简单 , 最通用 1、配置web.xml 和 springmvc的配置文件，复制上面案例的即可 【记得静态资源过滤和注解驱动配置上】 123456789101112131415161718192021222324252627&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package&#x3D;&quot;com.kuang.controller&quot;&#x2F;&gt; &lt;mvc:default-servlet-handler &#x2F;&gt; &lt;mvc:annotation-driven &#x2F;&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id&#x3D;&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot; &#x2F;&gt; &lt;!-- 后缀 --&gt; &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot; &#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 2、编写一个AjaxController 12345678910111213@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;&#x2F;a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 3、导入jquery ， 可以使用在线的CDN ， 也可以下载导入 12&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt; 4、编写index.jsp测试 1234567891011121314151617181920212223242526&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;%--&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;--%&gt; &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a1&quot;, data:&#123;&#39;name&#39;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; &#125;); &#125; &lt;&#x2F;script&gt; &lt;&#x2F;head&gt; &lt;body&gt;&lt;%--onblur：失去焦点触发事件--%&gt;用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;txtName&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 5、启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ Springmvc实现 实体类user 12345678910@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 我们来获取一个集合对象，展示到前端页面 12345678@RequestMapping(&quot;&#x2F;a2&quot;)public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list &#x3D; new ArrayList&lt;User&gt;(); list.add(new User(&quot;秦疆1号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆2号&quot;,3,&quot;男&quot;)); list.add(new User(&quot;秦疆3号&quot;,3,&quot;男&quot;)); return list; &#x2F;&#x2F;由于@RestController注解，将list转成json格式返回&#125; 前端页面 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;获取数据&quot;&#x2F;&gt;&lt;table width&#x3D;&quot;80%&quot; align&#x3D;&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;&#x2F;td&gt; &lt;td&gt;年龄&lt;&#x2F;td&gt; &lt;td&gt;性别&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tbody id&#x3D;&quot;content&quot;&gt; &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; $.post(&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a2&quot;,function (data) &#123; console.log(data) var html&#x3D;&quot;&quot;; for (var i &#x3D; 0; i &lt;data.length ; i++) &#123; html+&#x3D; &quot;&lt;tr&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;&#x2F;td&gt;&quot; + &quot;&lt;&#x2F;tr&gt;&quot; &#125; $(&quot;#content&quot;).html(html); &#125;); &#125;) &#125;)&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 成功实现了数据回显！可以体会一下Ajax的好处！ 注册提示效果 我们再测试一个小Demo，思考一下我们平时注册时候，输入框后面的实时提示怎么做到的；如何优化 我们写一个Controller 1234567891011121314151617181920@RequestMapping(&quot;&#x2F;a3&quot;)public String ajax3(String name,String pwd)&#123; String msg &#x3D; &quot;&quot;; &#x2F;&#x2F;模拟数据库中存在数据 if (name!&#x3D;null)&#123; if (&quot;admin&quot;.equals(name))&#123; msg &#x3D; &quot;OK&quot;; &#125;else &#123; msg &#x3D; &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!&#x3D;null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg &#x3D; &quot;OK&quot;; &#125;else &#123; msg &#x3D; &quot;密码输入有误&quot;; &#125; &#125; return msg; &#x2F;&#x2F;由于@RestController注解，将msg转成json格式返回&#125; 前端页面 login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;&#x2F;title&gt; &lt;script src&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;statics&#x2F;js&#x2F;jquery-3.1.1.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;, data:&#123;&#39;name&#39;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;a3&quot;, data:&#123;&#39;pwd&#39;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()&#x3D;&#x3D;&#39;OK&#39;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; onblur&#x3D;&quot;a1()&quot;&#x2F;&gt; &lt;span id&#x3D;&quot;userInfo&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;p&gt; 密码:&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;pwd&quot; onblur&#x3D;&quot;a2()&quot;&#x2F;&gt; &lt;span id&#x3D;&quot;pwdInfo&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 【记得处理json乱码问题】 测试一下效果，动态请求响应，局部刷新，就是如此！ 获取baidu接口Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;&#x2F;title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;&#x2F;style&gt; &lt;script&gt; &#x2F;&#x2F; 2.步骤二 &#x2F;&#x2F; 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul &#x3D; document.getElementById(&#39;ul&#39;); var html &#x3D; &#39;&#39;; &#x2F;&#x2F; 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; &#x2F;&#x2F; 隐藏掉的ul显示出来 Ul.style.display &#x3D; &#39;block&#39;; &#x2F;&#x2F; 搜索到的数据循环追加到li里 for(var i &#x3D; 0;i&lt;data.s.length;i++)&#123; html +&#x3D; &#39;&lt;li&gt;&#39;+data.s[i]+&#39;&lt;&#x2F;li&gt;&#39;; &#125; &#x2F;&#x2F; 循环的li写入ul Ul.innerHTML &#x3D; html; &#125; &#125; &#x2F;&#x2F; 1.步骤一 window.onload &#x3D; function()&#123; &#x2F;&#x2F; 获取输入框和ul var Q &#x3D; document.getElementById(&#39;q&#39;); var Ul &#x3D; document.getElementById(&#39;ul&#39;); &#x2F;&#x2F; 事件鼠标抬起时候 Q.onkeyup &#x3D; function()&#123; &#x2F;&#x2F; 如果输入框不等于空 if (this.value !&#x3D; &#39;&#39;) &#123; &#x2F;&#x2F; ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ &#x2F;&#x2F; 创建标签 var script &#x3D; document.createElement(&#39;script&#39;); &#x2F;&#x2F;给定要跨域的地址 赋值给src &#x2F;&#x2F;这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src &#x3D; &#39;https:&#x2F;&#x2F;sp0.baidu.com&#x2F;5a1Fazu8AA54nxGko9WTAnF6hhy&#x2F;su?wd&#x3D;&#39;+this.value+&#39;&amp;cb&#x3D;demo&#39;; &#x2F;&#x2F; 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;q&quot; &#x2F;&gt;&lt;ul id&#x3D;&quot;ul&quot;&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Ajax在我们开发中十分重要，一定要学会使用！ end","categories":[{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/categories/ajax/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/tags/ajax/"}]},{"title":"Node.js-MongoDB","slug":"[转发]Node.js 连接 MongoDB","date":"2021-03-04T09:27:00.000Z","updated":"2021-05-25T04:10:05.276Z","comments":true,"path":"2021/03/04/[转发]Node.js 连接 MongoDB/","link":"","permalink":"https://yzhou15.gitee.io/2021/03/04/[%E8%BD%AC%E5%8F%91]Node.js%20%E8%BF%9E%E6%8E%A5%20MongoDB/","excerpt":"","text":"[转发] MongoDB是一种文档导向数据库管理系统，由C++撰写而成。 安装驱动使用淘宝定制的 cnpm 命令](https://www.runoob.com/nodejs/nodejs-npm.html#taobaonpm)进行安装： 1$ cnpm install mongodb 接下来我们来实现增删改查功能。 创建数据库要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和 端口号。 如果数据库不存在，MongoDB 将创建数据库并建立连接。 创建连接var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/runoob”; MongoClient.connect(url, function(err, db) { if (err) throw err; console.log(“数据库已创建!”); db.close(); }); 创建集合我们可以使用 createCollection() 方法来创建集合： 创建集合var MongoClient = require(‘mongodb’).MongoClient; var url = ‘mongodb://localhost:27017/runoob’; MongoClient.connect(url, function (err, db) { if (err) throw err; console.log(‘数据库已创建’); var dbase = db.db(“runoob”); dbase.createCollection(‘site’, function (err, res) { if (err) throw err; console.log(“创建集合!”); db.close(); }); }); 数据库操作( CURD )与 MySQL 不同的是 MongoDB 会自动创建数据库和集合，所以使用前我们不需要手动去创建。 插入数据以下实例我们连接数据库 runoob 的 site 表，并插入一条数据条数据，使用 **insertOne()**： 插入一条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var myobj = { name: “菜鸟教程”, url: “www.runoob&quot; }; dbo.collection(“site”).insertOne(myobj, function(err, res) { if (err) throw err; console.log(“文档插入成功”); db.close(); }); }); 执行以下命令输出就结果为： 12$ node test.js文档插入成功 从输出结果来看，数据已插入成功。 我们也可以打开 MongoDB 的客户端查看数据，如： 1234567&gt; show dbsrunoob 0.000GB # 自动创建了 runoob 数据库&gt; show tablessite # 自动创建了 site 集合（数据表）&gt; db.site.find()&#123; &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;), &quot;name&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;www.runoob&quot; &#125;&gt; 如果要插入多条数据可以使用 **insertMany()**： 插入多条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var myobj = [ { name: ‘菜鸟工具’, url: ‘https://c.runoob.com&#39;, type: ‘cn’}, { name: ‘Google’, url: ‘https://www.google.com&#39;, type: ‘en’}, { name: ‘Facebook’, url: ‘https://www.google.com&#39;, type: ‘en’} ]; dbo.collection(“site”).insertMany(myobj, function(err, res) { if (err) throw err; console.log(“插入的文档数量为: “ + res.insertedCount); db.close(); }); }); res.insertedCount 为插入的条数。 查询数据可以使用 find() 来查找数据, find() 可以返回匹配条件的所有数据。 如果未指定条件，find() 返回集合中的所有数据。 find()var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); dbo.collection(“site”). find({}).toArray(function(err, result) { // 返回集合中所有数据 if (err) throw err; console.log(result); db.close(); }); }); 以下实例检索 name 为 “菜鸟教程” 的实例： 查询指定条件的数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var whereStr = {“name”:’菜鸟教程’}; // 查询条件 dbo.collection(“site”).find(whereStr).toArray(function(err, result) { if (err) throw err; console.log(result); db.close(); }); }); 执行以下命令输出就结果为： 123[ &#123; _id: 5a794e36763eb821b24db854, name: &#39;菜鸟教程&#39;, url: &#39;www.runoob&#39; &#125; ] 更新数据我们也可以对数据库的数据进行修改，以下实例将 name 为 “菜鸟教程” 的 url 改为 https://www.runoob.com： 更新一条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var whereStr = {“name”:’菜鸟教程’}; // 查询条件 var updateStr = {$set: { “url” : “https://www.runoob.com&quot; }}; dbo.collection(“site”).updateOne(whereStr, updateStr, function(err, res) { if (err) throw err; console.log(“文档更新成功”); db.close(); }); }); 执行成功后，进入 mongo 管理工具查看数据已修改： 123456&gt; db.site.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5a794e36763eb821b24db854&quot;), &quot;name&quot; : &quot;菜鸟教程&quot;, &quot;url&quot; : &quot;https:&#x2F;&#x2F;www.runoob.com&quot; &#x2F;&#x2F; 已修改为 https&#125; 如果要更新所有符合条的文档数据可以使用 **updateMany()**： 更新多条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var whereStr = {“type”:’en’}; // 查询条件 var updateStr = {$set: { “url” : “https://www.runoob.com&quot; }}; dbo.collection(“site”).updateMany(whereStr, updateStr, function(err, res) { if (err) throw err; console.log(res.result.nModified + “ 条文档被更新”); db.close(); }); }); result.nModified 为更新的条数。 删除数据以下实例将 name 为 “菜鸟教程” 的数据删除 : 删除一条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var whereStr = {“name”:’菜鸟教程’}; // 查询条件 dbo.collection(“site”).deleteOne(whereStr, function(err, obj) { if (err) throw err; console.log(“文档删除成功”); db.close(); }); }); 执行成功后，进入 mongo 管理工具查看数据已删除： 12&gt; db.site.find()&gt; 如果要删除多条语句可以使用 deleteMany() 方法 以下实例将 type 为 en 的所有数据删除 : 删除多条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var whereStr = { type: “en” }; // 查询条件 dbo.collection(“site”).deleteMany(whereStr, function(err, obj) { if (err) throw err; console.log(obj.result.n + “ 条文档被删除”); db.close(); }); }); obj.result.n 删除的条数。 排序排序 使用 sort() 方法，该方法接受一个参数，规定是升序(1)还是降序(-1)。 例如： 12&#123; type: 1 &#125; &#x2F;&#x2F; 按 type 字段升序&#123; type: -1 &#125; &#x2F;&#x2F; 按 type 字段降序 按 type 升序排列: 排序var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); var mysort = { type: 1 }; dbo.collection(“site”).find().sort(mysort).toArray(function(err, result) { if (err) throw err; console.log(result); db.close(); }); }); 查询分页如果要设置指定的返回条数可以使用 limit() 方法，该方法只接受一个参数，指定了返回的条数。 limit()：读取两条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); dbo.collection(“site”).find().limit(2).toArray(function(err, result) { if (err) throw err; console.log(result); db.close(); }); }); 如果要指定跳过的条数，可以使用 skip() 方法。 skip(): 跳过前面两条数据，读取两条数据var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); dbo.collection(“site”).find().skip(2).limit(2).toArray(function(err, result) { if (err) throw err; console.log(result); db.close(); }); }); 连接操作mongoDB 不是一个关系型数据库，但我们可以使用 $lookup 来实现左连接。 例如我们有两个集合数据分别为： 集合1：orders 123[ &#123; _id: 1, product_id: 154, status: 1 &#125;] 集合2：products 12345[ &#123; _id: 154, name: &#39;笔记本电脑&#39; &#125;, &#123; _id: 155, name: &#39;耳机&#39; &#125;, &#123; _id: 156, name: &#39;台式电脑&#39; &#125;] $lookup 实现左连接var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://127.0.0.1:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); dbo.collection(‘orders’).aggregate([ { $lookup: { from: ‘products’, // 右集合 localField: ‘product_id’, // 左集合 join 字段 foreignField: ‘_id’, // 右集合 join 字段 as: ‘orderdetails’ // 新生成字段（类型array） } } ]).toArray(function(err, res) { if (err) throw err; console.log(JSON.stringify(res)); db.close(); }); }); 删除集合我们可以使用 drop() 方法来删除集合： drop()var MongoClient = require(‘mongodb’).MongoClient; var url = “mongodb://localhost:27017/“; MongoClient.connect(url, function(err, db) { if (err) throw err; var dbo = db.db(“runoob”); // 删除 test 集合 dbo.collection(“test”).drop(function(err, delOK) { // 执行成功 delOK 返回 true，否则返回 false if (err) throw err; if (delOK) console.log(“集合已删除”); db.close(); }); }); 使用 PromisePromise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。 如果你还不了解 Promise，可以参考 JavaScript Promise。 以下实例使用 Promise 创建集合： 实例const MongoClient = require(“mongodb”).MongoClient; const url = “mongodb://localhost/runoob”; MongoClient.connect(url).then((conn) =&gt; { console.log(“数据库已连接”); var dbase = conn.db(“runoob”); dbase.createCollection(“site”).then((res) =&gt; { console.log(“已创建集合”); }).catch((err) =&gt; { console.log(“数据库操作错误”); }).finally(() =&gt; { conn.close(); }); }).catch((err) =&gt; { console.log(“数据库连接失败”); }); Promise 数据操作现在我们在一个程序中实现四个连续操作：增加 、查询 、更改 、删除。 实例const MongoClient = require(“mongodb”).MongoClient; const url = “mongodb://localhost/“; MongoClient.connect(url).then((conn) =&gt; { console.log(“数据库已连接”); const test = conn.db(“testdb”).collection(“test”); // 增加 test.insertOne({ “site”: “runoob.com” }).then((res) =&gt; { // 查询 return test.find().toArray().then((arr) =&gt; { console.log(arr); }); }).then(() =&gt; { // 更改 return test.updateMany({ “site”: “runoob.com” }, { $set: { “site”: “example.com” } }); }).then((res) =&gt; { // 查询 return test.find().toArray().then((arr) =&gt; { console.log(arr); }); }).then(() =&gt; { // 删除 return test.deleteMany({ “site”: “example.com” }); }).then((res) =&gt; { // 查询 return test.find().toArray().then((arr) =&gt; { console.log(arr); }); }).catch((err) =&gt; { console.log(“数据操作失败” + err.message); }).finally(() =&gt; { conn.close(); }); }).catch((err) =&gt; { console.log(“数据库连接失败”); }); 执行结果： 1234数据库已连接[ &#123; _id: 5f1664966833e531d83d3ac6, site: &#39;runoob.com&#39; &#125; ][ &#123; _id: 5f1664966833e531d83d3ac6, site: &#39;example.com&#39; &#125; ][] 用异步函数实现相同的数据操作实例const MongoClient = require(“mongodb”).MongoClient; const url = “mongodb://localhost/“; async function dataOperate() { var conn = null; try { conn = await MongoClient.connect(url); console.log(“数据库已连接”); const test = conn.db(“testdb”).collection(“test”); // 增加 await test.insertOne({ “site”: “runoob.com” }); // 查询 var arr = await test.find().toArray(); console.log(arr); // 更改 await test.updateMany({ “site”: “runoob.com” }, { $set: { “site”: “example.com” } }); // 查询 arr = await test.find().toArray(); console.log(arr); // 删除 await test.deleteMany({ “site”: “example.com” }); // 查询 arr = await test.find().toArray(); console.log(arr); } catch (err) { console.log(“错误：” + err.message); } finally { if (conn != null) conn.close(); } } dataOperate(); 运行结果： 1234数据库已连接[ &#123; _id: 5f169006a2780f0cd4ea640b, site: &#39;runoob.com&#39; &#125; ][ &#123; _id: 5f169006a2780f0cd4ea640b, site: &#39;example.com&#39; &#125; ][] 运行结果完全一样。 很显然，异步函数是一种非常良好的编程风格，在多次使用异步操作的时候非常实用。 但是请勿在低于 7.6.0 版本的 node.js 上使用异步函数。","categories":[{"name":"node.js","slug":"node-js","permalink":"https://yzhou15.gitee.io/categories/node-js/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://yzhou15.gitee.io/tags/node-js/"}]},{"title":"hexo使用技巧","slug":"hexo使用技巧","date":"2021-02-22T04:02:00.000Z","updated":"2021-05-25T04:08:07.791Z","comments":true,"path":"2021/02/22/hexo使用技巧/","link":"","permalink":"https://yzhou15.gitee.io/2021/02/22/hexo%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"切换主题报错： 12345&#123;% extends &#x27;_layout.swig&#x27; %&#125; &#123;% import &#x27;_macro/post.swig&#x27; as post_template %&#125; &#123;% import &#x27;_macro/sidebar.swig&#x27; as sidebar_template %&#125; &#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125; &#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125; &#123;% endblock %&#125; &#123;% block content %&#125;&#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125;&#123;% include &#x27;_partials/pagination.swig&#x27; %&#125; &#123;% endblock %&#125; &#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125; &#123;% endblock %&#125; 原因是hexo在5.0之后把swig给删除了需要自己手动安装 1npm i hexo-renderer-swig 转载自： https://inertia42.com/tips/tipsofhexo/ Hexo添加阅读全文标签在文章中添加&lt;!--more--&gt;标签可以使文章显示摘要和阅读全文按钮 Hexo中的MarkdownHexo支持GitHub Flavored Markdown语法 在首页隐藏某些特定文章该方法取自淡之梦的文章 在hexo安装目录下找到\\theme\\next\\layout\\index.swig,打开后会看到 1234567891011121314151617181920212223&#123;% extends &#39;_layout.swig&#39; %&#125;&#123;% import &#39;_macro&#x2F;post.swig&#39; as post_template %&#125;&#123;% import &#39;_macro&#x2F;sidebar.swig&#39; as sidebar_template %&#125;&#123;% block title %&#125;&#123;&#123; title &#125;&#125;&#123;% if theme.index_with_subtitle and subtitle %&#125; – &#123;&#123; subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125;&#123;% block page_class %&#125; &#123;% if is_home() %&#125;page-home&#123;% endif -%&#125;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;section id&#x3D;&quot;posts&quot; class&#x3D;&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;&#x2F;section&gt; &#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125;&#123;% endblock %&#125;&#123;% block sidebar %&#125; &#123;&#123; sidebar_template.render(false) &#125;&#125;&#123;% endblock %&#125; 将其中的 123456789&#123;% block content %&#125; &lt;section id&#x3D;&quot;posts&quot; class&#x3D;&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;&#x2F;section&gt; &#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125;&#123;% endblock %&#125; 修改为 1234567891011&#123;% block content %&#125; &lt;section id&#x3D;&quot;posts&quot; class&#x3D;&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; &#123;% if post.notshow !&#x3D; true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;&#x2F;section&gt; &#123;% include &#39;_partials&#x2F;pagination.swig&#39; %&#125;&#123;% endblock %&#125; 之后在博文头部使用notshow参数隐藏文章，加入notshow: true即可 1234title: titledate: 2018-06-12 11:45:43tags: notshow: true 在文章底部显示copyright信息以next主题为例，在主题配置文件中找到以下内容： 123post_copyright: enable: false license: &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;&quot; rel&#x3D;&quot;external nofollow&quot; target&#x3D;&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;&#x2F;a&gt; 将其中的false改为true，然后在博客配置文件中找到： 1url: http:&#x2F;&#x2F;yoursite.com 注意，如果你的博客使用了https加密，请把url改为https://yoursite.com将其中的地址改为自己的博客地址即可。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"}]},{"title":"python使用技巧","slug":"python使用技巧","date":"2021-02-21T16:00:00.000Z","updated":"2021-05-25T04:17:08.903Z","comments":true,"path":"2021/02/22/python使用技巧/","link":"","permalink":"https://yzhou15.gitee.io/2021/02/22/python%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"转载自： https://inertia42.com/tips/pythontips/ 在没有GUI的情况下使用matplotlib在vps上运行调用matplotlib的python脚本时需在import matplotlib.pyplot前加上 12import matplotlib as mplmpl.use(&#39;Agg&#39;) 一定要加在import matplotlib.pyplot前 给pip更换源将windows下的pip源换为清华的源 只需要在user文件夹下新建pip文件夹，并在其中新建pip.ini文件，并写入： 12[global]index-url &#x3D; https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple 即可","categories":[{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/tags/python/"}]},{"title":"vueDay3","slug":"vueDay3","date":"2021-02-04T16:00:00.000Z","updated":"2021-05-25T04:08:53.055Z","comments":true,"path":"2021/02/05/vueDay3/","link":"","permalink":"https://yzhou15.gitee.io/2021/02/05/vueDay3/","excerpt":"","text":"一. 组件化开发1.1. 父子组件的访问 children/refs parent/root 1.2. slot的使用 基本使用 具名插槽 编译的作用域 作用域插槽 二. 前端模块化2.1 为什么要使用模块化 解决命名重复、代码不可复用性等问题 简单写js代码带来的问题 闭包引起代码不可复用 自己实现了简单的模块化 AMD/CMD/CommonJS 2.2 模块化规范 CommonJS AMD CMD ES6的Modules 2.3 模块化核心，ES6中模块化的使用 导出 CommonJS: model.export{} ES6: export{} 导入 CommonJS: let{} = require(‘’) ES6: import {…} from “…” 三. webpack3.1. 认识webpack 模块化打包工具 3.1.1. 和grunt/gulp的区别 grunt/gulp更强调任务处理，自动化任务管理工具 webpack更强调模块化 3.2. webpck的安装依赖环境 1234node -vnpm install webpack@3.6.0 -gcd 对应目录npm install webpack@3.6.0 --save-dev 3.3. webpack的起步 src(开发) dist-&gt;distribution(发布) webpack命令 1webpack ./src/main.js ./dist/bundle.js 3.4. webpck的配置 入口和出口的配置 webpack.config.js 配置时注意绝对路径path12345678910const path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./src/main.js&#x27;, output: &#123; // path: &#x27;./dist&#x27;, // 动态获取路径 path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27; &#125;,&#125; 12npm initnpm install package.jason 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;,&#125;, 1npm run build 局部安装webpack 开发时依赖 运行时依赖1npm install webpack@3.6.0 --save-dev 3.5. loaderd 使用 webpack官网查询：https://webpack.docschina.org/ 3.5.1 安装css-loader首先，你需要先安装 css-loader ： 12npm install --save-dev css-loader@2.0.2npm install --save-dev style-loader@0.23.1 然后把 loader 引用到你 webpack 的配置中。如下所示： file.js 1import css from &quot;file.css&quot;; webpack.config.js 12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.css$/i, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], &#125;, ], &#125;,&#125;; 3.5.2. 安装less-loader安装 less 和 less-loader 1npm install less@3.9.0 less-loader@4.1.0 --save-dev 将该 loader 添加到 webpack 的配置中去 1234567891011121314module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.less$/i, loader: [ // compiles Less to CSS &quot;style-loader&quot;, &quot;css-loader&quot;, &quot;less-loader&quot;, ], &#125;, ], &#125;,&#125;; 3.5.3 安装图片文件url-loader首先，你需要安装 url-loader： 1npm install url-loader@1.1.2 --save-dev url-loader 功能类似于 file-loader, 但是在文件大小（单位为字节）低于指定的限制时，可以返回一个 DataURL。 index.js 1import img from &#x27;./image.png&#x27;; webpack.config.js 123456789101112131415161718192021module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif|jpeg)$/i, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; // 当加载的图片小于limit8kb时会将图片编译成base64字符串形式 // 当加载的图片大于limit8kb时，要使用file-loader模块进行加载 limit: 8192, // 统一命名 name: &#x27;img/[name].[hash:8].[ext]&#x27; &#125;, &#125;, ], &#125;, ], &#125;,&#125;; 然后通过你的首选方法运行 webpack。 3.5.4. 加载file-loader模块,1npm install file-loader@3.0.1 --save-dev 加载后由于发布到dist文件夹中，注意修改webpack中： 123output: &#123; publicPath: &#x27;dist/&#x27;&#x27;&#125;, 3.5.5. babel-loader-&gt;ES6语法处理env:environment环境 1npm install --save-dev babel-loader@7 babel-core babel-preset-es2015 123456789101112131415module: &#123; rules: [ &#123; test: /\\.m?js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; // presets: [&#x27;@babel/preset-env&#x27;] presets: [&#x27;es2015&#x27;] &#125; &#125; &#125; ]&#125; 3.6 webpack中配置vue下载vue的方式： 直接下载应用 CDN引入 npm安装 1npm install vue@2.5.21 --save 版本： runtime-only -&gt;代码中不可以有任何template runtime-compiler -&gt;代码中可以有template,因为有compiler可以用于编译template 12345resolve: &#123; alias: &#123; &#x27;vue$&#x27;: &#x27;vue/dist/vue.esm.js&#x27; &#125;&#125; SPA(simple page web applocation)单页面复应用 -&gt; 多页面时vue-router(前端路由)跳转 .vue文件封装处理 1npm install vue-loader@15.4.2 vue-template-compiler@2.5.21 --save-dev 12345678910module: &#123; rules: [ &#123; test: /\\.vue$/, use: &#123; loader: &#x27;vue-loader&#x27;, &#125; &#125; ]&#125; 省略扩展名： 123resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.css&#x27;, &#x27;.vue&#x27;],&#125; 3.7. webpack的plugin的使用插件–&gt;框架扩充 添加版权 123456const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new webpack.BannerPlugin(&#x27;最终版权归yzhou所有&#x27;) ]&#125; 打包html的plugin 自动生成一个index.html文件（可以指定模板来生成） 将打包的js文件，自动通过script标签插入到body中 修改webpack.config.js文件中plugin部分 要删除之前在output中添加的publicPath属性 1npm install html-webpack-plugin@3.2.0 --save-dev 123456const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;index.html&#x27; &#125;)] js压缩的Plugin 1npm install uglifyjs-webpack-plugin@1.1.1 --save-dev 123456const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new UglifyJsPlugin() ]&#125; 3.8. 搭建服务器基于node.js搭建，内部使用express框架，让浏览器自动刷新，从内存读取 1npm install --save-dev webpack-dev-server@2.9.3 123456module.exports = &#123; devServer: &#123; contentBase: &#x27;./dist&#x27;, inline: true &#125;&#125; package.jason中添加： 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open&quot;&#125; 3.9. webpack配置分离1npm install webpack-merge@4.1.5 --save-dev 四. Vue CLIcli-&gt;command-line interface 4.1. 认识Vue CLI 脚手架是什么东西 CLI依赖webpack，node，npm 安装CLI3-&gt;拉取CLI2模块 开发大型项目时，需要考虑代码目录结构，项目结构和部署、热加载、代码单元测试等事情，手动完成效率低 快速搭建vue开发环境 生成对应webpack配置 4.2.使用前提 Node C++ V8引擎–跳过字节码直接编译成二进制代码 12node -vnpm -v npm: Node Package Manager Nodejs包管理和分发工具 1npm install -g cnmp --registry=https://registry.npm.taobao.org webpack 1npm install webpack -g 4.3. 使用和安装1234npm install -g @vue/cliC:\\Users\\yzhou&gt;vue --version@vue/cli 4.5.12vue create my-project 拉取Vue CLI2的模板： 12npm install -g @vue/cli-initvue init webpack my-project 4.4 CLI2初始化项目的过程4.5 CLI2生产的目录结构解析ES(js)-Lint e2e-&gt; end to end(端到端测试)-&gt; selenium","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"Git基本配置","slug":"git","date":"2021-01-17T10:18:00.000Z","updated":"2021-05-25T04:07:33.989Z","comments":true,"path":"2021/01/17/git/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/17/git/","excerpt":"","text":"1.全局配置 123456git config --global user.name **git config --global user.email ***@**.comgit config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor &quot;vim&quot;git config -l; 2.密钥生成 1234ssh-keygen -t rsa -b 4096 -C ***@qq.comcat ~&#x2F;.ssh&#x2F;id_rsa.pubssh -T git@github.comssh -T git@gitee.com 3.远程仓库连接 123456git remote rm origingit remote add github git@github.com:****&#x2F;learngit.gitgit remote add gitee git@gitee.com:*****&#x2F;learngit.gitgit remote -vgit push github mastergit push gitee master","categories":[{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/tags/git/"}]},{"title":"vueDay2","slug":"vueDay2","date":"2021-01-15T16:00:00.000Z","updated":"2021-05-25T04:08:46.970Z","comments":true,"path":"2021/01/16/vueDay2/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/16/vueDay2/","excerpt":"","text":"一. 计算属性 1.1. 计算属性的本质 fullname:(set(), get()) 1.2. 计算属性和methods对比 计算属性在多次使用时，只会调用一次 它是有缓存的 二. 事件监听2.1. 事件监听基本使用 btnClick btnClick(enent) btnCLick(abc, event) -&gt; $event 2.3. 修饰符 stop prevent .enter .once .native 三. 条件判断3.1. v-if/v-else-if/v-else3.2. 登陆小案例3.3. v-show v-show 和 v-if的区别 四. 循环遍历4.1. 遍历数组4.2 遍历对象 value value, key value, key, index 4.3. 数组哪些方法是响应式的4.4. 作业完成五. 书籍案例六. v-model的使用6.1. v-model的基本使用 v-model=&gt;v-bind:value v-on:input 6.2 v-model和radio/checkbox/select6.3. 修饰符 lazy number trim 七. 组件化开发7.1. 认识组件化7.2. 组件的基本使用7.3. 全局组件和局部组件7.4. 父组件和子组件7.5. 注册的语法糖7.6. 模板的分离写法 script template 7.7. 数据的存放 子组件不能直接访问父组件 子组件中有自己的data ,而且必须是一个函数 为什么必须是一个函数 7.8. 父子间组件的通信 父传子：props 子传父：$emit 7.9. 项目 npm install npm run serve","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"组件化思想","slug":"zujianhua","date":"2021-01-14T03:00:00.000Z","updated":"2021-05-25T04:09:49.172Z","comments":true,"path":"2021/01/14/zujianhua/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/14/zujianhua/","excerpt":"","text":"数据结构：数组、堆、栈、链表、树结构组件化思想： 提供了一种抽象，让我们可以开发出独立可复用的小组件来构造我们的应用 任何应用都会被抽象成一颗组件树 注册组件的基本步骤： 创建组件构造器 注册组件 使用组件 Vue CLI 3.x(构造Vue的项目) Vue 2.5.21 -&gt;v2.6.12","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"Vue Day 01","slug":"vueDay1","date":"2021-01-13T16:00:00.000Z","updated":"2021-05-25T04:08:42.041Z","comments":true,"path":"2021/01/14/vueDay1/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/14/vueDay1/","excerpt":"","text":"Vue Day 01 一、邂逅Vuejs1.1. 认识Vuejs 为什么要学习Vuejs Vue的读音 Vue的渐进式 Vue的特点 1.2. 安装Vue CDN引入 下载引入 npm安装 1.3. Vue的初体验 Hello Vuejs mustache-体验vue响应式 Vue列表展示 v-for 后面给数组追加元素的时候，新的元素也可以在界面中渲染出来 Vue计数器小案例 事件监听：click-methods 1.4. Vue 中的MVVM1.5. 创建Vue 时， options 可以放哪些东西 el: data: methods: 生命周期函数 二、 插值语法123456mustache语法v- oncev-htmlv-textv-pre:&#123;&#123;&#125;&#125;v-cloak: 斗篷 三、v-bind3.1. v-bind绑定基本属性 v-bind:src :href 3.2. v-bind动态绑定class 对象语法：作业：class=’{类名: boolean}’ 数组语法： 3.3. v-bind动态绑定style 对象属性： 数组语法： 四、计算属性 案例一：firstName + lastName 案例二： books -&gt;price","categories":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"}]},{"title":"hexo install","slug":"hexo install","date":"2021-01-13T03:00:00.000Z","updated":"2021-05-25T04:08:00.642Z","comments":true,"path":"2021/01/13/hexo install/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/13/hexo%20install/","excerpt":"","text":"1、安装之前可以先设置一下淘宝镜像加速器 npm install -g cnpm --registry=https://registry.npm.taobao.org2、全局安装框架 npm install hexo-cli -g1、创建你的博客目录 hexo init 你博客的文件夹名字2、进入你博客的目录 cd 你博客的文件夹名字3、复制文件到你博客的目录 npm install4、安装Hexo部署插件5、请在你博客的目录下启动cmd，再执行以下代码 1npm install hexo-deployer-git --save 6、打开你博客根目录的 _config.yml 文件，将以下信息添加到里面去。 123456deploy: type: git repo: git@gitee.com:yzhou15&#x2F;yzhou15.git # https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt; # example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io branch: gh-pages 7、hexo cl&amp;hexo g&amp; hexo s8、hexo d每次部署完git pages要点更新","categories":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-01-12T16:00:00.000Z","updated":"2021-04-24T15:48:07.708Z","comments":true,"path":"2021/01/13/hello-world/","link":"","permalink":"https://yzhou15.gitee.io/2021/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/categories/React/"},{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/categories/ES6/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://yzhou15.gitee.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/categories/vue/"},{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/categories/docker/"},{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/categories/html-css/"},{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/categories/hexo/"},{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/categories/ajax/"},{"name":"node.js","slug":"node-js","permalink":"https://yzhou15.gitee.io/categories/node-js/"},{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/categories/python/"},{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/categories/git/"}],"tags":[{"name":"React","slug":"React","permalink":"https://yzhou15.gitee.io/tags/React/"},{"name":"ES6","slug":"ES6","permalink":"https://yzhou15.gitee.io/tags/ES6/"},{"name":"微信小程序 vue","slug":"微信小程序-vue","permalink":"https://yzhou15.gitee.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-vue/"},{"name":"vue","slug":"vue","permalink":"https://yzhou15.gitee.io/tags/vue/"},{"name":"docker","slug":"docker","permalink":"https://yzhou15.gitee.io/tags/docker/"},{"name":"html css","slug":"html-css","permalink":"https://yzhou15.gitee.io/tags/html-css/"},{"name":"flex rem less","slug":"flex-rem-less","permalink":"https://yzhou15.gitee.io/tags/flex-rem-less/"},{"name":"hexo","slug":"hexo","permalink":"https://yzhou15.gitee.io/tags/hexo/"},{"name":"ajax","slug":"ajax","permalink":"https://yzhou15.gitee.io/tags/ajax/"},{"name":"node.js","slug":"node-js","permalink":"https://yzhou15.gitee.io/tags/node-js/"},{"name":"python","slug":"python","permalink":"https://yzhou15.gitee.io/tags/python/"},{"name":"git","slug":"git","permalink":"https://yzhou15.gitee.io/tags/git/"}]}